import {
  ArcCurve,
  BackSide,
  Box3,
  BufferGeometry,
  Color,
  DoubleSide,
  EllipseCurve,
  FileLoader,
  Float32BufferAttribute,
  FrontSide,
  Group,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  Line,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearFilter,
  Loader,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshStandardMaterial,
  Object3D,
  PlaneGeometry,
  Points,
  PointsMaterial,
  RGBADepthPacking,
  ShaderChunk,
  Sphere,
  Texture,
  UniformsLib,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-UZOV2HZI.js";

// node_modules/three-dxf-loader/dist/three-dxf-loader.js
var t = { 43: function(e, t2, r2) {
  var n2, a2;
  n2 = function() {
    var e2 = function() {
    }, t3 = "undefined", r3 = typeof window !== t3 && typeof window.navigator !== t3 && /Trident\/|MSIE /.test(window.navigator.userAgent), n3 = ["trace", "debug", "info", "warn", "error"];
    function a3(e3, t4) {
      var r4 = e3[t4];
      if ("function" == typeof r4.bind) return r4.bind(e3);
      try {
        return Function.prototype.bind.call(r4, e3);
      } catch (t5) {
        return function() {
          return Function.prototype.apply.apply(r4, [e3, arguments]);
        };
      }
    }
    function o2() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function i2(t4, r4) {
      for (var a4 = 0; a4 < n3.length; a4++) {
        var o3 = n3[a4];
        this[o3] = a4 < t4 ? e2 : this.methodFactory(o3, t4, r4);
      }
      this.log = this.debug;
    }
    function s(e3, r4, n4) {
      return function() {
        typeof console !== t3 && (i2.call(this, r4, n4), this[e3].apply(this, arguments));
      };
    }
    function l(n4, i3, l2) {
      return function(n5) {
        return "debug" === n5 && (n5 = "log"), typeof console !== t3 && ("trace" === n5 && r3 ? o2 : void 0 !== console[n5] ? a3(console, n5) : void 0 !== console.log ? a3(console, "log") : e2);
      }(n4) || s.apply(this, arguments);
    }
    function c(e3, r4, a4) {
      var o3, s2 = this;
      r4 = null == r4 ? "WARN" : r4;
      var c2 = "loglevel";
      function u2() {
        var e4;
        if (typeof window !== t3 && c2) {
          try {
            e4 = window.localStorage[c2];
          } catch (e5) {
          }
          if (typeof e4 === t3) try {
            var r5 = window.document.cookie, n4 = r5.indexOf(encodeURIComponent(c2) + "=");
            -1 !== n4 && (e4 = /^([^;]+)/.exec(r5.slice(n4))[1]);
          } catch (e5) {
          }
          return void 0 === s2.levels[e4] && (e4 = void 0), e4;
        }
      }
      "string" == typeof e3 ? c2 += ":" + e3 : "symbol" == typeof e3 && (c2 = void 0), s2.name = e3, s2.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }, s2.methodFactory = a4 || l, s2.getLevel = function() {
        return o3;
      }, s2.setLevel = function(r5, a5) {
        if ("string" == typeof r5 && void 0 !== s2.levels[r5.toUpperCase()] && (r5 = s2.levels[r5.toUpperCase()]), !("number" == typeof r5 && r5 >= 0 && r5 <= s2.levels.SILENT)) throw "log.setLevel() called with invalid level: " + r5;
        if (o3 = r5, false !== a5 && function(e4) {
          var r6 = (n3[e4] || "silent").toUpperCase();
          if (typeof window !== t3 && c2) {
            try {
              return void (window.localStorage[c2] = r6);
            } catch (e5) {
            }
            try {
              window.document.cookie = encodeURIComponent(c2) + "=" + r6 + ";";
            } catch (e5) {
            }
          }
        }(r5), i2.call(s2, r5, e3), typeof console === t3 && r5 < s2.levels.SILENT) return "No console available for logging";
      }, s2.setDefaultLevel = function(e4) {
        r4 = e4, u2() || s2.setLevel(e4, false);
      }, s2.resetLevel = function() {
        s2.setLevel(r4, false), function() {
          if (typeof window !== t3 && c2) {
            try {
              return void window.localStorage.removeItem(c2);
            } catch (e4) {
            }
            try {
              window.document.cookie = encodeURIComponent(c2) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (e4) {
            }
          }
        }();
      }, s2.enableAll = function(e4) {
        s2.setLevel(s2.levels.TRACE, e4);
      }, s2.disableAll = function(e4) {
        s2.setLevel(s2.levels.SILENT, e4);
      };
      var f2 = u2();
      null == f2 && (f2 = r4), s2.setLevel(f2, false);
    }
    var u = new c(), f = {};
    u.getLogger = function(e3) {
      if ("symbol" != typeof e3 && "string" != typeof e3 || "" === e3) throw new TypeError("You must supply a name when creating a logger.");
      var t4 = f[e3];
      return t4 || (t4 = f[e3] = new c(e3, u.getLevel(), u.methodFactory)), t4;
    };
    var d = typeof window !== t3 ? window.log : void 0;
    return u.noConflict = function() {
      return typeof window !== t3 && window.log === u && (window.log = d), u;
    }, u.getLoggers = function() {
      return f;
    }, u.default = u, u;
  }, void 0 === (a2 = n2.call(t2, r2, t2, e)) || (e.exports = a2);
}, 939: (e, t2, r2) => {
  r2.d(t2, { Z: () => o2 });
  var n2 = r2(949);
  const a2 = {};
  n2.FontLoader ? a2.FontLoader = n2.FontLoader : import("./FontLoader-CNF7X2UP.js").then((e2) => a2.FontLoader = e2.FontLoader).catch((e2) => console.error(e2)), n2.TextGeometry ? a2.TextGeometry = n2.TextGeometry : import("./TextGeometry-6JYQ2H47.js").then((e2) => a2.TextGeometry = e2.TextGeometry).catch((e2) => console.error(e2));
  const o2 = a2;
}, 949: (t2, r2, n2) => {
  var a2, o2;
  t2.exports = (a2 = { ArcCurve: () => ArcCurve, BackSide: () => BackSide, Box3: () => Box3, BufferGeometry: () => BufferGeometry, Color: () => Color, DoubleSide: () => DoubleSide, EllipseCurve: () => EllipseCurve, FileLoader: () => FileLoader, Float32BufferAttribute: () => Float32BufferAttribute, FontLoader: () => void 0, FrontSide: () => FrontSide, Group: () => Group, InstancedBufferAttribute: () => InstancedBufferAttribute, InstancedBufferGeometry: () => InstancedBufferGeometry, Line: () => Line, LineBasicMaterial: () => LineBasicMaterial, LineDashedMaterial: () => LineDashedMaterial, LinearFilter: () => LinearFilter, Loader: () => Loader, Matrix3: () => Matrix3, Matrix4: () => Matrix4, Mesh: () => Mesh, MeshBasicMaterial: () => MeshBasicMaterial, MeshDepthMaterial: () => MeshDepthMaterial, MeshDistanceMaterial: () => MeshDistanceMaterial, MeshLambertMaterial: () => MeshLambertMaterial, MeshStandardMaterial: () => MeshStandardMaterial, Object3D: () => Object3D, PlaneGeometry: () => PlaneGeometry, Points: () => Points, PointsMaterial: () => PointsMaterial, RGBADepthPacking: () => RGBADepthPacking, ShaderChunk: () => ShaderChunk, Sphere: () => Sphere, TextGeometry: () => void 0, Texture: () => Texture, UniformsLib: () => UniformsLib, UniformsUtils: () => UniformsUtils, Vector2: () => Vector2, Vector3: () => Vector3, Vector4: () => Vector4, XHRLoader: () => void 0 }, o2 = {}, n2.d(o2, a2), o2);
} };
var r = {};
function n(e) {
  var a2 = r[e];
  if (void 0 !== a2) return a2.exports;
  var o2 = r[e] = { exports: {} };
  return t[e].call(o2.exports, o2, o2.exports, n), o2.exports;
}
n.n = (e) => {
  var t2 = e && e.__esModule ? () => e.default : () => e;
  return n.d(t2, { a: t2 }), t2;
}, n.d = (e, t2) => {
  for (var r2 in t2) n.o(t2, r2) && !n.o(e, r2) && Object.defineProperty(e, r2, { enumerable: true, get: t2[r2] });
}, n.o = (e, t2) => Object.prototype.hasOwnProperty.call(e, t2);
var a = {};
(() => {
  n.d(a, { H: () => gt, K: () => ht.Z });
  var e = n(949);
  function t2() {
    var e2 = /* @__PURE__ */ Object.create(null);
    function t3(n2, a2) {
      var o3 = n2.id, i3 = n2.name, s2 = n2.dependencies;
      void 0 === s2 && (s2 = []);
      var l2 = n2.init;
      void 0 === l2 && (l2 = function() {
      });
      var c2 = n2.getTransferables;
      if (void 0 === c2 && (c2 = null), !e2[o3]) try {
        s2 = s2.map(function(r4) {
          return r4 && r4.isWorkerModule && (t3(r4, function(e3) {
            if (e3 instanceof Error) throw e3;
          }), r4 = e2[r4.id].value), r4;
        }), l2 = r3("<" + i3 + ">.init", l2), c2 && (c2 = r3("<" + i3 + ">.getTransferables", c2));
        var u2 = null;
        "function" == typeof l2 ? u2 = l2.apply(void 0, s2) : console.error("worker module init function failed to rehydrate"), e2[o3] = { id: o3, value: u2, getTransferables: c2 }, a2(u2);
      } catch (e3) {
        e3 && e3.noLog || console.error(e3), a2(e3);
      }
    }
    function r3(e3, t4) {
      var r4 = void 0;
      self.troikaDefine = function(e4) {
        return r4 = e4;
      };
      var n2 = URL.createObjectURL(new Blob(["/** " + e3.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + t4 + "\n)"], { type: "application/javascript" }));
      try {
        importScripts(n2);
      } catch (e4) {
        console.error(e4);
      }
      return URL.revokeObjectURL(n2), delete self.troikaDefine, r4;
    }
    self.addEventListener("message", function(r4) {
      var n2 = r4.data, a2 = n2.messageId, o3 = n2.action, i3 = n2.data;
      try {
        "registerModule" === o3 && t3(i3, function(e3) {
          e3 instanceof Error ? postMessage({ messageId: a2, success: false, error: e3.message }) : postMessage({ messageId: a2, success: true, result: { isCallable: "function" == typeof e3 } });
        }), "callModule" === o3 && function(t4, r5) {
          var n3, a3 = t4.id, o4 = t4.args;
          e2[a3] && "function" == typeof e2[a3].value || r5(new Error("Worker module " + a3 + ": not found or its 'init' did not return a function"));
          try {
            var i4 = (n3 = e2[a3]).value.apply(n3, o4);
            i4 && "function" == typeof i4.then ? i4.then(s2, function(e3) {
              return r5(e3 instanceof Error ? e3 : new Error("" + e3));
            }) : s2(i4);
          } catch (e3) {
            r5(e3);
          }
          function s2(t5) {
            try {
              var n4 = e2[a3].getTransferables && e2[a3].getTransferables(t5);
              n4 && Array.isArray(n4) && n4.length || (n4 = void 0), r5(t5, n4);
            } catch (e3) {
              console.error(e3), r5(e3);
            }
          }
        }(i3, function(e3, t4) {
          e3 instanceof Error ? postMessage({ messageId: a2, success: false, error: e3.message }) : postMessage({ messageId: a2, success: true, result: e3 }, t4 || void 0);
        });
      } catch (e3) {
        postMessage({ messageId: a2, success: false, error: e3.stack });
      }
    });
  }
  var r2 = function() {
    var e2 = false;
    if ("undefined" != typeof window && void 0 !== window.document) try {
      new Worker(URL.createObjectURL(new Blob([""], { type: "application/javascript" }))).terminate(), e2 = true;
    } catch (e3) {
      console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + e3.message + "]");
    }
    return r2 = function() {
      return e2;
    }, e2;
  }, o2 = 0, i2 = 0, s = false, l = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null);
  function f(e2) {
    if (!(e2 && "function" == typeof e2.init || s)) throw new Error("requires `options.init` function");
    var t3 = e2.dependencies, n2 = e2.init, a2 = e2.getTransferables, i3 = e2.workerId;
    if (!r2()) return function(e3) {
      var t4 = function() {
        for (var e4 = [], r3 = arguments.length; r3--; ) e4[r3] = arguments[r3];
        return t4._getInitResult().then(function(t5) {
          if ("function" == typeof t5) return t5.apply(void 0, e4);
          throw new Error("Worker module function was called but `init` did not return a callable function");
        });
      };
      return t4._getInitResult = function() {
        var r3 = e3.dependencies, n3 = e3.init;
        r3 = Array.isArray(r3) ? r3.map(function(e4) {
          return e4 && e4._getInitResult ? e4._getInitResult() : e4;
        }) : [];
        var a3 = Promise.all(r3).then(function(e4) {
          return n3.apply(null, e4);
        });
        return t4._getInitResult = function() {
          return a3;
        }, a3;
      }, t4;
    }(e2);
    null == i3 && (i3 = "#default");
    var l2 = "workerModule" + ++o2, u2 = e2.name || l2, v2 = null;
    function p2() {
      for (var e3 = [], t4 = arguments.length; t4--; ) e3[t4] = arguments[t4];
      if (!v2) {
        v2 = h(i3, "registerModule", p2.workerModuleData);
        var r3 = function() {
          v2 = null, c[i3].delete(r3);
        };
        (c[i3] || (c[i3] = /* @__PURE__ */ new Set())).add(r3);
      }
      return v2.then(function(t5) {
        if (t5.isCallable) return h(i3, "callModule", { id: l2, args: e3 });
        throw new Error("Worker module function was called but `init` did not return a callable function");
      });
    }
    return t3 = t3 && t3.map(function(e3) {
      return "function" != typeof e3 || e3.workerModuleData || (s = true, e3 = f({ workerId: i3, name: "<" + u2 + "> function dependency: " + e3.name, init: "function(){return (\n" + d(e3) + "\n)}" }), s = false), e3 && e3.workerModuleData && (e3 = e3.workerModuleData), e3;
    }), p2.workerModuleData = { isWorkerModule: true, id: l2, name: u2, dependencies: t3, init: d(n2), getTransferables: a2 && d(a2) }, p2;
  }
  function d(e2) {
    var t3 = e2.toString();
    return !/^function/.test(t3) && /^\w+\s*\(/.test(t3) && (t3 = "function " + t3), t3;
  }
  function h(e2, r3, n2) {
    return new Promise(function(a2, o3) {
      var s2 = ++i2;
      u[s2] = function(e3) {
        e3.success ? a2(e3.result) : o3(new Error("Error in worker " + r3 + " call: " + e3.error));
      }, function(e3) {
        var r4 = l[e3];
        if (!r4) {
          var n3 = d(t2);
          (r4 = l[e3] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + e3.replace(/\*/g, "") + " **/\n\n;(" + n3 + ")()"], { type: "application/javascript" })))).onmessage = function(e4) {
            var t3 = e4.data, r5 = t3.messageId, n4 = u[r5];
            if (!n4) throw new Error("WorkerModule response with empty or unknown messageId");
            delete u[r5], n4(t3);
          };
        }
        return r4;
      }(e2).postMessage({ messageId: s2, action: r3, data: n2 });
    });
  }
  function v() {
    var e2 = function(e3) {
      function t3(e4, t4, r4, n3, a3, o4, i4, s3, l3, c3) {
        var u3 = 1 - l3;
        c3.x = u3 * u3 * u3 * e4 + 3 * u3 * u3 * l3 * r4 + 3 * u3 * l3 * l3 * a3 + l3 * l3 * l3 * i4, c3.y = u3 * u3 * u3 * t4 + 3 * u3 * u3 * l3 * n3 + 3 * u3 * l3 * l3 * o4 + l3 * l3 * l3 * s3;
      }
      function r3(e4, t4) {
        for (var r4, n3, a3, o4, i4, s3 = /([MLQCZ])([^MLQCZ]*)/g; r4 = s3.exec(e4); ) {
          var l3 = r4[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(e5) {
            return parseFloat(e5);
          });
          switch (r4[1]) {
            case "M":
              o4 = n3 = l3[0], i4 = a3 = l3[1];
              break;
            case "L":
              l3[0] === o4 && l3[1] === i4 || t4("L", o4, i4, o4 = l3[0], i4 = l3[1]);
              break;
            case "Q":
              t4("Q", o4, i4, o4 = l3[2], i4 = l3[3], l3[0], l3[1]);
              break;
            case "C":
              t4("C", o4, i4, o4 = l3[4], i4 = l3[5], l3[0], l3[1], l3[2], l3[3]);
              break;
            case "Z":
              o4 === n3 && i4 === a3 || t4("L", o4, i4, n3, a3);
          }
        }
      }
      function n2(e4, n3, a3) {
        void 0 === a3 && (a3 = 16);
        var o4 = { x: 0, y: 0 };
        r3(e4, function(e5, r4, i4, s3, l3, c3, u3, f3, d3) {
          switch (e5) {
            case "L":
              n3(r4, i4, s3, l3);
              break;
            case "Q":
              for (var h3 = r4, v3 = i4, p3 = 1; p3 < a3; p3++) m3 = i4, x3 = u3, k3 = l3, void 0, U3 = 1 - (w3 = p3 / (a3 - 1)), (S3 = o4).x = U3 * U3 * r4 + 2 * U3 * w3 * c3 + w3 * w3 * s3, S3.y = U3 * U3 * m3 + 2 * U3 * w3 * x3 + w3 * w3 * k3, n3(h3, v3, o4.x, o4.y), h3 = o4.x, v3 = o4.y;
              break;
            case "C":
              for (var g3 = r4, b3 = i4, y3 = 1; y3 < a3; y3++) t3(r4, i4, c3, u3, f3, d3, s3, l3, y3 / (a3 - 1), o4), n3(g3, b3, o4.x, o4.y), g3 = o4.x, b3 = o4.y;
          }
          var m3, x3, k3, w3, S3, U3;
        });
      }
      var a2 = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", o3 = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", i3 = /* @__PURE__ */ new WeakMap(), s2 = { premultipliedAlpha: false, preserveDrawingBuffer: true, antialias: false, depth: false };
      function l2(e4, t4) {
        var r4 = e4.getContext ? e4.getContext("webgl", s2) : e4, n3 = i3.get(r4);
        if (!n3) {
          let d3 = function(e5) {
            var t5 = o4[e5];
            if (!t5 && !(t5 = o4[e5] = r4.getExtension(e5))) throw new Error(e5 + " not supported");
            return t5;
          }, h3 = function(e5, t5) {
            var n4 = r4.createShader(t5);
            return r4.shaderSource(n4, e5), r4.compileShader(n4), n4;
          }, v3 = function(e5, t5, n4, o5) {
            if (!l3[e5]) {
              var i4 = {}, s3 = {}, c4 = r4.createProgram();
              r4.attachShader(c4, h3(t5, r4.VERTEX_SHADER)), r4.attachShader(c4, h3(n4, r4.FRAGMENT_SHADER)), r4.linkProgram(c4), l3[e5] = { program: c4, transaction: function(e6) {
                r4.useProgram(c4), e6({ setUniform: function(e7, t6) {
                  for (var n5 = [], a4 = arguments.length - 2; a4-- > 0; ) n5[a4] = arguments[a4 + 2];
                  var o6 = s3[t6] || (s3[t6] = r4.getUniformLocation(c4, t6));
                  r4["uniform" + e7].apply(r4, [o6].concat(n5));
                }, setAttribute: function(e7, t6, n5, o6, s4) {
                  var l4 = i4[e7];
                  l4 || (l4 = i4[e7] = { buf: r4.createBuffer(), loc: r4.getAttribLocation(c4, e7), data: null }), r4.bindBuffer(r4.ARRAY_BUFFER, l4.buf), r4.vertexAttribPointer(l4.loc, t6, r4.FLOAT, false, 0, 0), r4.enableVertexAttribArray(l4.loc), a3 ? r4.vertexAttribDivisor(l4.loc, o6) : d3("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(l4.loc, o6), s4 !== l4.data && (r4.bufferData(r4.ARRAY_BUFFER, s4, n5), l4.data = s4);
                } });
              } };
            }
            l3[e5].transaction(o5);
          }, p3 = function(e5, t5) {
            u3++;
            try {
              r4.activeTexture(r4.TEXTURE0 + u3);
              var n4 = c3[e5];
              n4 || (n4 = c3[e5] = r4.createTexture(), r4.bindTexture(r4.TEXTURE_2D, n4), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MIN_FILTER, r4.NEAREST), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MAG_FILTER, r4.NEAREST)), r4.bindTexture(r4.TEXTURE_2D, n4), t5(n4, u3);
            } finally {
              u3--;
            }
          }, g3 = function(e5, t5, n4) {
            var a4 = r4.createFramebuffer();
            f3.push(a4), r4.bindFramebuffer(r4.FRAMEBUFFER, a4), r4.activeTexture(r4.TEXTURE0 + t5), r4.bindTexture(r4.TEXTURE_2D, e5), r4.framebufferTexture2D(r4.FRAMEBUFFER, r4.COLOR_ATTACHMENT0, r4.TEXTURE_2D, e5, 0);
            try {
              n4(a4);
            } finally {
              r4.deleteFramebuffer(a4), r4.bindFramebuffer(r4.FRAMEBUFFER, f3[--f3.length - 1] || null);
            }
          }, b3 = function() {
            o4 = {}, l3 = {}, c3 = {}, u3 = -1, f3.length = 0;
          };
          var a3 = "undefined" != typeof WebGL2RenderingContext && r4 instanceof WebGL2RenderingContext, o4 = {}, l3 = {}, c3 = {}, u3 = -1, f3 = [];
          r4.canvas.addEventListener("webglcontextlost", function(e5) {
            b3(), e5.preventDefault();
          }, false), i3.set(r4, n3 = { gl: r4, isWebGL2: a3, getExtension: d3, withProgram: v3, withTexture: p3, withTextureFramebuffer: g3, handleContextLoss: b3 });
        }
        t4(n3);
      }
      function c2(e4, t4, r4, n3, i4, s3, c3, u3) {
        void 0 === c3 && (c3 = 15), void 0 === u3 && (u3 = null), l2(e4, function(e5) {
          var l3 = e5.gl, f3 = e5.withProgram;
          (0, e5.withTexture)("copy", function(e6, d3) {
            l3.texImage2D(l3.TEXTURE_2D, 0, l3.RGBA, i4, s3, 0, l3.RGBA, l3.UNSIGNED_BYTE, t4), f3("copy", a2, o3, function(e7) {
              var t5 = e7.setUniform;
              (0, e7.setAttribute)("aUV", 2, l3.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), t5("1i", "image", d3), l3.bindFramebuffer(l3.FRAMEBUFFER, u3 || null), l3.disable(l3.BLEND), l3.colorMask(8 & c3, 4 & c3, 2 & c3, 1 & c3), l3.viewport(r4, n3, i4, s3), l3.scissor(r4, n3, i4, s3), l3.drawArrays(l3.TRIANGLES, 0, 3);
            });
          });
        });
      }
      var u2 = Object.freeze({ __proto__: null, withWebGLContext: l2, renderImageData: c2, resizeWebGLCanvasWithoutClearing: function(e4, t4, r4) {
        var n3 = e4.width, a3 = e4.height;
        l2(e4, function(o4) {
          var i4 = o4.gl, s3 = new Uint8Array(n3 * a3 * 4);
          i4.readPixels(0, 0, n3, a3, i4.RGBA, i4.UNSIGNED_BYTE, s3), e4.width = t4, e4.height = r4, c2(i4, s3, 0, 0, n3, a3);
        });
      } });
      function f2(e4, t4, r4, a3, o4, i4) {
        void 0 === i4 && (i4 = 1);
        var s3 = new Uint8Array(e4 * t4), l3 = a3[2] - a3[0], c3 = a3[3] - a3[1], u3 = [];
        n2(r4, function(e5, t5, r5, n3) {
          u3.push({ x1: e5, y1: t5, x2: r5, y2: n3, minX: Math.min(e5, r5), minY: Math.min(t5, n3), maxX: Math.max(e5, r5), maxY: Math.max(t5, n3) });
        }), u3.sort(function(e5, t5) {
          return e5.maxX - t5.maxX;
        });
        for (var f3 = 0; f3 < e4; f3++) for (var d3 = 0; d3 < t4; d3++) {
          var h3 = g3(a3[0] + l3 * (f3 + 0.5) / e4, a3[1] + c3 * (d3 + 0.5) / t4), p3 = Math.pow(1 - Math.abs(h3) / o4, i4) / 2;
          h3 < 0 && (p3 = 1 - p3), p3 = Math.max(0, Math.min(255, Math.round(255 * p3))), s3[d3 * e4 + f3] = p3;
        }
        return s3;
        function g3(e5, t5) {
          for (var r5 = 1 / 0, n3 = 1 / 0, a4 = u3.length; a4--; ) {
            var o5 = u3[a4];
            if (o5.maxX + n3 <= e5) break;
            if (e5 + n3 > o5.minX && t5 - n3 < o5.maxY && t5 + n3 > o5.minY) {
              var i5 = v2(e5, t5, o5.x1, o5.y1, o5.x2, o5.y2);
              i5 < r5 && (r5 = i5, n3 = Math.sqrt(r5));
            }
          }
          return function(e6, t6) {
            for (var r6 = 0, n4 = u3.length; n4--; ) {
              var a5 = u3[n4];
              if (a5.maxX <= e6) break;
              a5.y1 > t6 != a5.y2 > t6 && e6 < (a5.x2 - a5.x1) * (t6 - a5.y1) / (a5.y2 - a5.y1) + a5.x1 && (r6 += a5.y1 < a5.y2 ? 1 : -1);
            }
            return 0 !== r6;
          }(e5, t5) && (n3 = -n3), n3;
        }
      }
      function d2(e4, t4, r4, n3, a3, o4, i4, s3, l3, c3) {
        void 0 === o4 && (o4 = 1), void 0 === s3 && (s3 = 0), void 0 === l3 && (l3 = 0), void 0 === c3 && (c3 = 0), h2(e4, t4, r4, n3, a3, o4, i4, null, s3, l3, c3);
      }
      function h2(e4, t4, r4, n3, a3, o4, i4, s3, l3, u3, d3) {
        void 0 === o4 && (o4 = 1), void 0 === l3 && (l3 = 0), void 0 === u3 && (u3 = 0), void 0 === d3 && (d3 = 0);
        for (var h3 = f2(e4, t4, r4, n3, a3, o4), v3 = new Uint8Array(4 * h3.length), p3 = 0; p3 < h3.length; p3++) v3[4 * p3 + d3] = h3[p3];
        c2(i4, v3, l3, u3, e4, t4, 1 << 3 - d3, s3);
      }
      function v2(e4, t4, r4, n3, a3, o4) {
        var i4 = a3 - r4, s3 = o4 - n3, l3 = i4 * i4 + s3 * s3, c3 = l3 ? Math.max(0, Math.min(1, ((e4 - r4) * i4 + (t4 - n3) * s3) / l3)) : 0, u3 = e4 - (r4 + c3 * i4), f3 = t4 - (n3 + c3 * s3);
        return u3 * u3 + f3 * f3;
      }
      var p2 = Object.freeze({ __proto__: null, generate: f2, generateIntoCanvas: d2, generateIntoFramebuffer: h2 }), g2 = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", b2 = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", y2 = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", m2 = new Float32Array([0, 0, 2, 0, 0, 2]), x2 = null, k2 = false, w2 = {}, S2 = /* @__PURE__ */ new WeakMap();
      function U2(e4) {
        if (!k2 && !F2(e4)) throw new Error("WebGL generation not supported");
      }
      function T2(e4, t4, r4, n3, a3, o4, i4) {
        if (void 0 === o4 && (o4 = 1), void 0 === i4 && (i4 = null), !i4 && !(i4 = x2)) {
          var s3 = "function" == typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : "undefined" != typeof document ? document.createElement("canvas") : null;
          if (!s3) throw new Error("OffscreenCanvas or DOM canvas not supported");
          i4 = x2 = s3.getContext("webgl", { depth: false });
        }
        U2(i4);
        var c3 = new Uint8Array(e4 * t4 * 4);
        l2(i4, function(i5) {
          var s4 = i5.gl, l3 = i5.withTexture, u4 = i5.withTextureFramebuffer;
          l3("readable", function(i6, l4) {
            s4.texImage2D(s4.TEXTURE_2D, 0, s4.RGBA, e4, t4, 0, s4.RGBA, s4.UNSIGNED_BYTE, null), u4(i6, l4, function(i7) {
              E2(e4, t4, r4, n3, a3, o4, s4, i7, 0, 0, 0), s4.readPixels(0, 0, e4, t4, s4.RGBA, s4.UNSIGNED_BYTE, c3);
            });
          });
        });
        for (var u3 = new Uint8Array(e4 * t4), f3 = 0, d3 = 0; f3 < c3.length; f3 += 4) u3[d3++] = c3[f3];
        return u3;
      }
      function _2(e4, t4, r4, n3, a3, o4, i4, s3, l3, c3) {
        void 0 === o4 && (o4 = 1), void 0 === s3 && (s3 = 0), void 0 === l3 && (l3 = 0), void 0 === c3 && (c3 = 0), E2(e4, t4, r4, n3, a3, o4, i4, null, s3, l3, c3);
      }
      function E2(e4, t4, r4, o4, i4, s3, c3, u3, f3, d3, h3) {
        void 0 === s3 && (s3 = 1), void 0 === f3 && (f3 = 0), void 0 === d3 && (d3 = 0), void 0 === h3 && (h3 = 0), U2(c3);
        var v3 = [];
        n2(r4, function(e5, t5, r5, n3) {
          v3.push(e5, t5, r5, n3);
        }), v3 = new Float32Array(v3), l2(c3, function(r5) {
          var n3 = r5.gl, l3 = r5.isWebGL2, c4 = r5.getExtension, p3 = r5.withProgram, x3 = r5.withTexture, k3 = r5.withTextureFramebuffer, w3 = r5.handleContextLoss;
          if (x3("rawDistances", function(r6, x4) {
            e4 === r6._lastWidth && t4 === r6._lastHeight || n3.texImage2D(n3.TEXTURE_2D, 0, n3.RGBA, r6._lastWidth = e4, r6._lastHeight = t4, 0, n3.RGBA, n3.UNSIGNED_BYTE, null), p3("main", g2, b2, function(a3) {
              var u4 = a3.setAttribute, f4 = a3.setUniform, d4 = !l3 && c4("ANGLE_instanced_arrays"), h4 = !l3 && c4("EXT_blend_minmax");
              u4("aUV", 2, n3.STATIC_DRAW, 0, m2), u4("aLineSegment", 4, n3.DYNAMIC_DRAW, 1, v3), f4.apply(void 0, ["4f", "uGlyphBounds"].concat(o4)), f4("1f", "uMaxDistance", i4), f4("1f", "uExponent", s3), k3(r6, x4, function(r7) {
                n3.enable(n3.BLEND), n3.colorMask(true, true, true, true), n3.viewport(0, 0, e4, t4), n3.scissor(0, 0, e4, t4), n3.blendFunc(n3.ONE, n3.ONE), n3.blendEquationSeparate(n3.FUNC_ADD, l3 ? n3.MAX : h4.MAX_EXT), n3.clear(n3.COLOR_BUFFER_BIT), l3 ? n3.drawArraysInstanced(n3.TRIANGLES, 0, 3, v3.length / 4) : d4.drawArraysInstancedANGLE(n3.TRIANGLES, 0, 3, v3.length / 4);
              });
            }), p3("post", a2, y2, function(r7) {
              r7.setAttribute("aUV", 2, n3.STATIC_DRAW, 0, m2), r7.setUniform("1i", "tex", x4), n3.bindFramebuffer(n3.FRAMEBUFFER, u3), n3.disable(n3.BLEND), n3.colorMask(0 === h3, 1 === h3, 2 === h3, 3 === h3), n3.viewport(f3, d3, e4, t4), n3.scissor(f3, d3, e4, t4), n3.drawArrays(n3.TRIANGLES, 0, 3);
            });
          }), n3.isContextLost()) throw w3(), new Error("webgl context lost");
        });
      }
      function F2(e4) {
        var t4 = e4 && e4 !== x2 ? e4.canvas || e4 : w2, r4 = S2.get(t4);
        if (void 0 === r4) {
          k2 = true;
          var n3 = null;
          try {
            var a3 = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97], o4 = T2(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, e4);
            (r4 = o4 && a3.length === o4.length && o4.every(function(e5, t5) {
              return e5 === a3[t5];
            })) || (n3 = "bad trial run results", console.info(a3, o4));
          } catch (e5) {
            r4 = false, n3 = e5.message;
          }
          n3 && console.warn("WebGL SDF generation not supported:", n3), k2 = false, S2.set(t4, r4);
        }
        return r4;
      }
      var C2 = Object.freeze({ __proto__: null, generate: T2, generateIntoCanvas: _2, generateIntoFramebuffer: E2, isSupported: F2 });
      return e3.forEachPathCommand = r3, e3.generate = function(e4, t4, r4, n3, a3, o4) {
        void 0 === a3 && (a3 = Math.max(n3[2] - n3[0], n3[3] - n3[1]) / 2), void 0 === o4 && (o4 = 1);
        try {
          return T2.apply(C2, arguments);
        } catch (e5) {
          return console.info("WebGL SDF generation failed, falling back to JS", e5), f2.apply(p2, arguments);
        }
      }, e3.generateIntoCanvas = function(e4, t4, r4, n3, a3, o4, i4, s3, l3, c3) {
        void 0 === a3 && (a3 = Math.max(n3[2] - n3[0], n3[3] - n3[1]) / 2), void 0 === o4 && (o4 = 1), void 0 === s3 && (s3 = 0), void 0 === l3 && (l3 = 0), void 0 === c3 && (c3 = 0);
        try {
          return _2.apply(C2, arguments);
        } catch (e5) {
          return console.info("WebGL SDF generation failed, falling back to JS", e5), d2.apply(p2, arguments);
        }
      }, e3.javascript = p2, e3.pathToLineSegments = n2, e3.webgl = C2, e3.webglUtils = u2, Object.defineProperty(e3, "__esModule", { value: true }), e3;
    }({});
    return e2;
  }
  const p = /\bvoid\s+main\s*\(\s*\)\s*{/g;
  function g(t3) {
    return t3.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t4, r3) {
      let n2 = e.ShaderChunk[r3];
      return n2 ? g(n2) : t4;
    });
  }
  const b = [];
  for (let e2 = 0; e2 < 256; e2++) b[e2] = (e2 < 16 ? "0" : "") + e2.toString(16);
  const y = Object.assign || function() {
    let e2 = arguments[0];
    for (let t3 = 1, r3 = arguments.length; t3 < r3; t3++) {
      let r4 = arguments[t3];
      if (r4) for (let t4 in r4) Object.prototype.hasOwnProperty.call(r4, t4) && (e2[t4] = r4[t4]);
    }
    return e2;
  }, m = Date.now(), x = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new Map();
  let w = 1e10;
  function S(t3, r3) {
    const n2 = function(e2) {
      const t4 = JSON.stringify(e2, T);
      let r4 = E.get(t4);
      return null == r4 && E.set(t4, r4 = ++_), r4;
    }(r3);
    let a2 = x.get(t3);
    if (a2 || x.set(t3, a2 = /* @__PURE__ */ Object.create(null)), a2[n2]) return new a2[n2]();
    const o3 = `_onBeforeCompile${n2}`, i3 = function(e2, a3) {
      t3.onBeforeCompile.call(this, e2, a3);
      const i4 = this.customProgramCacheKey() + "|" + e2.vertexShader + "|" + e2.fragmentShader;
      let s3 = k[i4];
      if (!s3) {
        const t4 = function(e3, { vertexShader: t5, fragmentShader: r4 }, n3, a4) {
          let { vertexDefs: o4, vertexMainIntro: i5, vertexMainOutro: s4, vertexTransform: l3, fragmentDefs: c3, fragmentMainIntro: u2, fragmentMainOutro: f2, fragmentColorTransform: d2, customRewriter: h2, timeUniform: v2 } = n3;
          if (o4 = o4 || "", i5 = i5 || "", s4 = s4 || "", c3 = c3 || "", u2 = u2 || "", f2 = f2 || "", (l3 || h2) && (t5 = g(t5)), (d2 || h2) && (r4 = g(r4 = r4.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"))), h2) {
            let e4 = h2({ vertexShader: t5, fragmentShader: r4 });
            t5 = e4.vertexShader, r4 = e4.fragmentShader;
          }
          if (d2) {
            let e4 = [];
            r4 = r4.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, (t6) => (e4.push(t6), "")), f2 = `${d2}
${e4.join("\n")}
${f2}`;
          }
          if (v2) {
            const e4 = `
uniform float ${v2};
`;
            o4 = e4 + o4, c3 = e4 + c3;
          }
          return l3 && (o4 = `${o4}
void troikaVertexTransform${a4}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l3}
}
`, i5 = `
troika_position_${a4} = vec3(position);
troika_normal_${a4} = vec3(normal);
troika_uv_${a4} = vec2(uv);
troikaVertexTransform${a4}(troika_position_${a4}, troika_normal_${a4}, troika_uv_${a4});
${i5}
`, t5 = (t5 = `vec3 troika_position_${a4};
vec3 troika_normal_${a4};
vec2 troika_uv_${a4};
${t5}
`).replace(/\b(position|normal|uv)\b/g, (e4, t6, r5, n4) => /\battribute\s+vec[23]\s+$/.test(n4.substr(0, r5)) ? t6 : `troika_${t6}_${a4}`), e3.map && e3.map.channel > 0 || (t5 = t5.replace(/\bMAP_UV\b/g, `troika_uv_${a4}`))), { vertexShader: t5 = U(t5, a4, o4, i5, s4), fragmentShader: r4 = U(r4, a4, c3, u2, f2) };
        }(this, e2, r3, n2);
        s3 = k[i4] = t4;
      }
      e2.vertexShader = s3.vertexShader, e2.fragmentShader = s3.fragmentShader, y(e2.uniforms, this.uniforms), r3.timeUniform && (e2.uniforms[r3.timeUniform] = { get value() {
        return Date.now() - m;
      } }), this[o3] && this[o3](e2);
    }, s2 = function() {
      return l2(r3.chained ? t3 : t3.clone());
    }, l2 = function(e2) {
      const a3 = Object.create(e2, c2);
      return Object.defineProperty(a3, "baseMaterial", { value: t3 }), Object.defineProperty(a3, "id", { value: w++ }), a3.uuid = function() {
        const e3 = 4294967295 * Math.random() | 0, t4 = 4294967295 * Math.random() | 0, r4 = 4294967295 * Math.random() | 0, n3 = 4294967295 * Math.random() | 0;
        return (b[255 & e3] + b[e3 >> 8 & 255] + b[e3 >> 16 & 255] + b[e3 >> 24 & 255] + "-" + b[255 & t4] + b[t4 >> 8 & 255] + "-" + b[t4 >> 16 & 15 | 64] + b[t4 >> 24 & 255] + "-" + b[63 & r4 | 128] + b[r4 >> 8 & 255] + "-" + b[r4 >> 16 & 255] + b[r4 >> 24 & 255] + b[255 & n3] + b[n3 >> 8 & 255] + b[n3 >> 16 & 255] + b[n3 >> 24 & 255]).toUpperCase();
      }(), a3.uniforms = y({}, e2.uniforms, r3.uniforms), a3.defines = y({}, e2.defines, r3.defines), a3.defines[`TROIKA_DERIVED_MATERIAL_${n2}`] = "", a3.extensions = y({}, e2.extensions, r3.extensions), a3._listeners = void 0, a3;
    }, c2 = { constructor: { value: s2 }, isDerivedMaterial: { value: true }, customProgramCacheKey: { writable: true, configurable: true, value: function() {
      return t3.customProgramCacheKey() + "|" + n2;
    } }, onBeforeCompile: { get: () => i3, set(e2) {
      this[o3] = e2;
    } }, copy: { writable: true, configurable: true, value: function(r4) {
      return t3.copy.call(this, r4), t3.isShaderMaterial || t3.isDerivedMaterial || (y(this.extensions, r4.extensions), y(this.defines, r4.defines), y(this.uniforms, e.UniformsUtils.clone(r4.uniforms))), this;
    } }, clone: { writable: true, configurable: true, value: function() {
      const e2 = new t3.constructor();
      return l2(e2).copy(this);
    } }, getDepthMaterial: { writable: true, configurable: true, value: function() {
      let n3 = this._depthMaterial;
      return n3 || (n3 = this._depthMaterial = S(t3.isDerivedMaterial ? t3.getDepthMaterial() : new e.MeshDepthMaterial({ depthPacking: e.RGBADepthPacking }), r3), n3.defines.IS_DEPTH_MATERIAL = "", n3.uniforms = this.uniforms), n3;
    } }, getDistanceMaterial: { writable: true, configurable: true, value: function() {
      let n3 = this._distanceMaterial;
      return n3 || (n3 = this._distanceMaterial = S(t3.isDerivedMaterial ? t3.getDistanceMaterial() : new e.MeshDistanceMaterial(), r3), n3.defines.IS_DISTANCE_MATERIAL = "", n3.uniforms = this.uniforms), n3;
    } }, dispose: { writable: true, configurable: true, value() {
      const { _depthMaterial: e2, _distanceMaterial: r4 } = this;
      e2 && e2.dispose(), r4 && r4.dispose(), t3.dispose.call(this);
    } } };
    return a2[n2] = s2, new s2();
  }
  function U(e2, t3, r3, n2, a2) {
    return (n2 || a2 || r3) && (e2 = e2.replace(p, `
${r3}
void troikaOrigMain${t3}() {`), e2 += `
void main() {
  ${n2}
  troikaOrigMain${t3}();
  ${a2}
}`), e2;
  }
  function T(e2, t3) {
    return "uniforms" === e2 ? void 0 : "function" == typeof t3 ? t3.toString() : t3;
  }
  let _ = 0;
  const E = /* @__PURE__ */ new Map();
  e.DoubleSide;
  const F = f({ name: "Typr Font Parser", dependencies: [function() {
    return "undefined" == typeof window && (self.window = self), function(e2) {
      var t3 = { parse: function(e3) {
        var r4 = t3._bin, n3 = new Uint8Array(e3);
        if ("ttcf" == r4.readASCII(n3, 0, 4)) {
          var a2 = 4;
          r4.readUshort(n3, a2), a2 += 2, r4.readUshort(n3, a2), a2 += 2;
          var o3 = r4.readUint(n3, a2);
          a2 += 4;
          for (var i3 = [], s2 = 0; s2 < o3; s2++) {
            var l2 = r4.readUint(n3, a2);
            a2 += 4, i3.push(t3._readFont(n3, l2));
          }
          return i3;
        }
        return [t3._readFont(n3, 0)];
      }, _readFont: function(e3, r4) {
        var n3 = t3._bin, a2 = r4;
        n3.readFixed(e3, r4), r4 += 4;
        var o3 = n3.readUshort(e3, r4);
        r4 += 2, n3.readUshort(e3, r4), r4 += 2, n3.readUshort(e3, r4), r4 += 2, n3.readUshort(e3, r4), r4 += 2;
        for (var i3 = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], s2 = { _data: e3, _offset: a2 }, l2 = {}, c2 = 0; c2 < o3; c2++) {
          var u2 = n3.readASCII(e3, r4, 4);
          r4 += 4, n3.readUint(e3, r4), r4 += 4;
          var f2 = n3.readUint(e3, r4);
          r4 += 4;
          var d2 = n3.readUint(e3, r4);
          r4 += 4, l2[u2] = { offset: f2, length: d2 };
        }
        for (c2 = 0; c2 < i3.length; c2++) {
          var h2 = i3[c2];
          l2[h2] && (s2[h2.trim()] = t3[h2.trim()].parse(e3, l2[h2].offset, l2[h2].length, s2));
        }
        return s2;
      }, _tabOffset: function(e3, r4, n3) {
        for (var a2 = t3._bin, o3 = a2.readUshort(e3, n3 + 4), i3 = n3 + 12, s2 = 0; s2 < o3; s2++) {
          var l2 = a2.readASCII(e3, i3, 4);
          i3 += 4, a2.readUint(e3, i3), i3 += 4;
          var c2 = a2.readUint(e3, i3);
          if (i3 += 4, a2.readUint(e3, i3), i3 += 4, l2 == r4) return c2;
        }
        return 0;
      } };
      t3._bin = { readFixed: function(e3, t4) {
        return (e3[t4] << 8 | e3[t4 + 1]) + (e3[t4 + 2] << 8 | e3[t4 + 3]) / 65540;
      }, readF2dot14: function(e3, r4) {
        return t3._bin.readShort(e3, r4) / 16384;
      }, readInt: function(e3, r4) {
        return t3._bin._view(e3).getInt32(r4);
      }, readInt8: function(e3, r4) {
        return t3._bin._view(e3).getInt8(r4);
      }, readShort: function(e3, r4) {
        return t3._bin._view(e3).getInt16(r4);
      }, readUshort: function(e3, r4) {
        return t3._bin._view(e3).getUint16(r4);
      }, readUshorts: function(e3, r4, n3) {
        for (var a2 = [], o3 = 0; o3 < n3; o3++) a2.push(t3._bin.readUshort(e3, r4 + 2 * o3));
        return a2;
      }, readUint: function(e3, r4) {
        return t3._bin._view(e3).getUint32(r4);
      }, readUint64: function(e3, r4) {
        return 4294967296 * t3._bin.readUint(e3, r4) + t3._bin.readUint(e3, r4 + 4);
      }, readASCII: function(e3, t4, r4) {
        for (var n3 = "", a2 = 0; a2 < r4; a2++) n3 += String.fromCharCode(e3[t4 + a2]);
        return n3;
      }, readUnicode: function(e3, t4, r4) {
        for (var n3 = "", a2 = 0; a2 < r4; a2++) {
          var o3 = e3[t4++] << 8 | e3[t4++];
          n3 += String.fromCharCode(o3);
        }
        return n3;
      }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(e3, r4, n3) {
        var a2 = t3._bin._tdec;
        return a2 && 0 == r4 && n3 == e3.length ? a2.decode(e3) : t3._bin.readASCII(e3, r4, n3);
      }, readBytes: function(e3, t4, r4) {
        for (var n3 = [], a2 = 0; a2 < r4; a2++) n3.push(e3[t4 + a2]);
        return n3;
      }, readASCIIArray: function(e3, t4, r4) {
        for (var n3 = [], a2 = 0; a2 < r4; a2++) n3.push(String.fromCharCode(e3[t4 + a2]));
        return n3;
      }, _view: function(e3) {
        return e3._dataView || (e3._dataView = e3.buffer ? new DataView(e3.buffer, e3.byteOffset, e3.byteLength) : new DataView(new Uint8Array(e3).buffer));
      } }, t3._lctf = {}, t3._lctf.parse = function(e3, r4, n3, a2, o3) {
        var i3 = t3._bin, s2 = {}, l2 = r4;
        i3.readFixed(e3, r4), r4 += 4;
        var c2 = i3.readUshort(e3, r4);
        r4 += 2;
        var u2 = i3.readUshort(e3, r4);
        r4 += 2;
        var f2 = i3.readUshort(e3, r4);
        return r4 += 2, s2.scriptList = t3._lctf.readScriptList(e3, l2 + c2), s2.featureList = t3._lctf.readFeatureList(e3, l2 + u2), s2.lookupList = t3._lctf.readLookupList(e3, l2 + f2, o3), s2;
      }, t3._lctf.readLookupList = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = r4, i3 = [], s2 = a2.readUshort(e3, r4);
        r4 += 2;
        for (var l2 = 0; l2 < s2; l2++) {
          var c2 = a2.readUshort(e3, r4);
          r4 += 2;
          var u2 = t3._lctf.readLookupTable(e3, o3 + c2, n3);
          i3.push(u2);
        }
        return i3;
      }, t3._lctf.readLookupTable = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = r4, i3 = { tabs: [] };
        i3.ltype = a2.readUshort(e3, r4), r4 += 2, i3.flag = a2.readUshort(e3, r4), r4 += 2;
        var s2 = a2.readUshort(e3, r4);
        r4 += 2;
        for (var l2 = i3.ltype, c2 = 0; c2 < s2; c2++) {
          var u2 = a2.readUshort(e3, r4);
          r4 += 2;
          var f2 = n3(e3, l2, o3 + u2, i3);
          i3.tabs.push(f2);
        }
        return i3;
      }, t3._lctf.numOfOnes = function(e3) {
        for (var t4 = 0, r4 = 0; r4 < 32; r4++) 0 != (e3 >>> r4 & 1) && t4++;
        return t4;
      }, t3._lctf.readClassDef = function(e3, r4) {
        var n3 = t3._bin, a2 = [], o3 = n3.readUshort(e3, r4);
        if (r4 += 2, 1 == o3) {
          var i3 = n3.readUshort(e3, r4);
          r4 += 2;
          var s2 = n3.readUshort(e3, r4);
          r4 += 2;
          for (var l2 = 0; l2 < s2; l2++) a2.push(i3 + l2), a2.push(i3 + l2), a2.push(n3.readUshort(e3, r4)), r4 += 2;
        }
        if (2 == o3) {
          var c2 = n3.readUshort(e3, r4);
          for (r4 += 2, l2 = 0; l2 < c2; l2++) a2.push(n3.readUshort(e3, r4)), r4 += 2, a2.push(n3.readUshort(e3, r4)), r4 += 2, a2.push(n3.readUshort(e3, r4)), r4 += 2;
        }
        return a2;
      }, t3._lctf.getInterval = function(e3, t4) {
        for (var r4 = 0; r4 < e3.length; r4 += 3) {
          var n3 = e3[r4], a2 = e3[r4 + 1];
          if (e3[r4 + 2], n3 <= t4 && t4 <= a2) return r4;
        }
        return -1;
      }, t3._lctf.readCoverage = function(e3, r4) {
        var n3 = t3._bin, a2 = {};
        a2.fmt = n3.readUshort(e3, r4), r4 += 2;
        var o3 = n3.readUshort(e3, r4);
        return r4 += 2, 1 == a2.fmt && (a2.tab = n3.readUshorts(e3, r4, o3)), 2 == a2.fmt && (a2.tab = n3.readUshorts(e3, r4, 3 * o3)), a2;
      }, t3._lctf.coverageIndex = function(e3, r4) {
        var n3 = e3.tab;
        if (1 == e3.fmt) return n3.indexOf(r4);
        if (2 == e3.fmt) {
          var a2 = t3._lctf.getInterval(n3, r4);
          if (-1 != a2) return n3[a2 + 2] + (r4 - n3[a2]);
        }
        return -1;
      }, t3._lctf.readFeatureList = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = [], i3 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = n3.readASCII(e3, r4, 4);
          r4 += 4;
          var c2 = n3.readUshort(e3, r4);
          r4 += 2;
          var u2 = t3._lctf.readFeatureTable(e3, a2 + c2);
          u2.tag = l2.trim(), o3.push(u2);
        }
        return o3;
      }, t3._lctf.readFeatureTable = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = {}, i3 = n3.readUshort(e3, r4);
        r4 += 2, i3 > 0 && (o3.featureParams = a2 + i3);
        var s2 = n3.readUshort(e3, r4);
        r4 += 2, o3.tab = [];
        for (var l2 = 0; l2 < s2; l2++) o3.tab.push(n3.readUshort(e3, r4 + 2 * l2));
        return o3;
      }, t3._lctf.readScriptList = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = {}, i3 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = n3.readASCII(e3, r4, 4);
          r4 += 4;
          var c2 = n3.readUshort(e3, r4);
          r4 += 2, o3[l2.trim()] = t3._lctf.readScriptTable(e3, a2 + c2);
        }
        return o3;
      }, t3._lctf.readScriptTable = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = {}, i3 = n3.readUshort(e3, r4);
        r4 += 2, i3 > 0 && (o3.default = t3._lctf.readLangSysTable(e3, a2 + i3));
        var s2 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var l2 = 0; l2 < s2; l2++) {
          var c2 = n3.readASCII(e3, r4, 4);
          r4 += 4;
          var u2 = n3.readUshort(e3, r4);
          r4 += 2, o3[c2.trim()] = t3._lctf.readLangSysTable(e3, a2 + u2);
        }
        return o3;
      }, t3._lctf.readLangSysTable = function(e3, r4) {
        var n3 = t3._bin, a2 = {};
        n3.readUshort(e3, r4), r4 += 2, a2.reqFeature = n3.readUshort(e3, r4), r4 += 2;
        var o3 = n3.readUshort(e3, r4);
        return r4 += 2, a2.features = n3.readUshorts(e3, r4, o3), a2;
      }, t3.CFF = {}, t3.CFF.parse = function(e3, r4, n3) {
        var a2 = t3._bin;
        (e3 = new Uint8Array(e3.buffer, r4, n3))[r4 = 0], e3[++r4], e3[++r4], e3[++r4], r4++;
        var o3 = [];
        r4 = t3.CFF.readIndex(e3, r4, o3);
        for (var i3 = [], s2 = 0; s2 < o3.length - 1; s2++) i3.push(a2.readASCII(e3, r4 + o3[s2], o3[s2 + 1] - o3[s2]));
        r4 += o3[o3.length - 1];
        var l2 = [];
        r4 = t3.CFF.readIndex(e3, r4, l2);
        var c2 = [];
        for (s2 = 0; s2 < l2.length - 1; s2++) c2.push(t3.CFF.readDict(e3, r4 + l2[s2], r4 + l2[s2 + 1]));
        r4 += l2[l2.length - 1];
        var u2 = c2[0], f2 = [];
        r4 = t3.CFF.readIndex(e3, r4, f2);
        var d2 = [];
        for (s2 = 0; s2 < f2.length - 1; s2++) d2.push(a2.readASCII(e3, r4 + f2[s2], f2[s2 + 1] - f2[s2]));
        if (r4 += f2[f2.length - 1], t3.CFF.readSubrs(e3, r4, u2), u2.CharStrings) {
          r4 = u2.CharStrings, f2 = [], r4 = t3.CFF.readIndex(e3, r4, f2);
          var h2 = [];
          for (s2 = 0; s2 < f2.length - 1; s2++) h2.push(a2.readBytes(e3, r4 + f2[s2], f2[s2 + 1] - f2[s2]));
          u2.CharStrings = h2;
        }
        if (u2.ROS) {
          r4 = u2.FDArray;
          var v2 = [];
          for (r4 = t3.CFF.readIndex(e3, r4, v2), u2.FDArray = [], s2 = 0; s2 < v2.length - 1; s2++) {
            var p2 = t3.CFF.readDict(e3, r4 + v2[s2], r4 + v2[s2 + 1]);
            t3.CFF._readFDict(e3, p2, d2), u2.FDArray.push(p2);
          }
          r4 += v2[v2.length - 1], r4 = u2.FDSelect, u2.FDSelect = [];
          var g2 = e3[r4];
          if (r4++, 3 != g2) throw g2;
          var b2 = a2.readUshort(e3, r4);
          for (r4 += 2, s2 = 0; s2 < b2 + 1; s2++) u2.FDSelect.push(a2.readUshort(e3, r4), e3[r4 + 2]), r4 += 3;
        }
        return u2.Encoding && (u2.Encoding = t3.CFF.readEncoding(e3, u2.Encoding, u2.CharStrings.length)), u2.charset && (u2.charset = t3.CFF.readCharset(e3, u2.charset, u2.CharStrings.length)), t3.CFF._readFDict(e3, u2, d2), u2;
      }, t3.CFF._readFDict = function(e3, r4, n3) {
        var a2;
        for (var o3 in r4.Private && (a2 = r4.Private[1], r4.Private = t3.CFF.readDict(e3, a2, a2 + r4.Private[0]), r4.Private.Subrs && t3.CFF.readSubrs(e3, a2 + r4.Private.Subrs, r4.Private)), r4) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o3) && (r4[o3] = n3[r4[o3] - 426 + 35]);
      }, t3.CFF.readSubrs = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = [];
        r4 = t3.CFF.readIndex(e3, r4, o3);
        var i3, s2 = o3.length;
        i3 = s2 < 1240 ? 107 : s2 < 33900 ? 1131 : 32768, n3.Bias = i3, n3.Subrs = [];
        for (var l2 = 0; l2 < o3.length - 1; l2++) n3.Subrs.push(a2.readBytes(e3, r4 + o3[l2], o3[l2 + 1] - o3[l2]));
      }, t3.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], t3.CFF.glyphByUnicode = function(e3, t4) {
        for (var r4 = 0; r4 < e3.charset.length; r4++) if (e3.charset[r4] == t4) return r4;
        return -1;
      }, t3.CFF.glyphBySE = function(e3, r4) {
        return r4 < 0 || r4 > 255 ? -1 : t3.CFF.glyphByUnicode(e3, t3.CFF.tableSE[r4]);
      }, t3.CFF.readEncoding = function(e3, r4, n3) {
        t3._bin;
        var a2 = [".notdef"], o3 = e3[r4];
        if (r4++, 0 != o3) throw "error: unknown encoding format: " + o3;
        var i3 = e3[r4];
        r4++;
        for (var s2 = 0; s2 < i3; s2++) a2.push(e3[r4 + s2]);
        return a2;
      }, t3.CFF.readCharset = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = [".notdef"], i3 = e3[r4];
        if (r4++, 0 == i3) for (var s2 = 0; s2 < n3; s2++) {
          var l2 = a2.readUshort(e3, r4);
          r4 += 2, o3.push(l2);
        }
        else {
          if (1 != i3 && 2 != i3) throw "error: format: " + i3;
          for (; o3.length < n3; ) {
            l2 = a2.readUshort(e3, r4), r4 += 2;
            var c2 = 0;
            for (1 == i3 ? (c2 = e3[r4], r4++) : (c2 = a2.readUshort(e3, r4), r4 += 2), s2 = 0; s2 <= c2; s2++) o3.push(l2), l2++;
          }
        }
        return o3;
      }, t3.CFF.readIndex = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = a2.readUshort(e3, r4) + 1, i3 = e3[r4 += 2];
        if (r4++, 1 == i3) for (var s2 = 0; s2 < o3; s2++) n3.push(e3[r4 + s2]);
        else if (2 == i3) for (s2 = 0; s2 < o3; s2++) n3.push(a2.readUshort(e3, r4 + 2 * s2));
        else if (3 == i3) for (s2 = 0; s2 < o3; s2++) n3.push(16777215 & a2.readUint(e3, r4 + 3 * s2 - 1));
        else if (1 != o3) throw "unsupported offset size: " + i3 + ", count: " + o3;
        return (r4 += o3 * i3) - 1;
      }, t3.CFF.getCharString = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = e3[r4], i3 = e3[r4 + 1];
        e3[r4 + 2], e3[r4 + 3], e3[r4 + 4];
        var s2 = 1, l2 = null, c2 = null;
        o3 <= 20 && (l2 = o3, s2 = 1), 12 == o3 && (l2 = 100 * o3 + i3, s2 = 2), 21 <= o3 && o3 <= 27 && (l2 = o3, s2 = 1), 28 == o3 && (c2 = a2.readShort(e3, r4 + 1), s2 = 3), 29 <= o3 && o3 <= 31 && (l2 = o3, s2 = 1), 32 <= o3 && o3 <= 246 && (c2 = o3 - 139, s2 = 1), 247 <= o3 && o3 <= 250 && (c2 = 256 * (o3 - 247) + i3 + 108, s2 = 2), 251 <= o3 && o3 <= 254 && (c2 = 256 * -(o3 - 251) - i3 - 108, s2 = 2), 255 == o3 && (c2 = a2.readInt(e3, r4 + 1) / 65535, s2 = 5), n3.val = null != c2 ? c2 : "o" + l2, n3.size = s2;
      }, t3.CFF.readCharString = function(e3, r4, n3) {
        for (var a2 = r4 + n3, o3 = t3._bin, i3 = []; r4 < a2; ) {
          var s2 = e3[r4], l2 = e3[r4 + 1];
          e3[r4 + 2], e3[r4 + 3], e3[r4 + 4];
          var c2 = 1, u2 = null, f2 = null;
          s2 <= 20 && (u2 = s2, c2 = 1), 12 == s2 && (u2 = 100 * s2 + l2, c2 = 2), 19 != s2 && 20 != s2 || (u2 = s2, c2 = 2), 21 <= s2 && s2 <= 27 && (u2 = s2, c2 = 1), 28 == s2 && (f2 = o3.readShort(e3, r4 + 1), c2 = 3), 29 <= s2 && s2 <= 31 && (u2 = s2, c2 = 1), 32 <= s2 && s2 <= 246 && (f2 = s2 - 139, c2 = 1), 247 <= s2 && s2 <= 250 && (f2 = 256 * (s2 - 247) + l2 + 108, c2 = 2), 251 <= s2 && s2 <= 254 && (f2 = 256 * -(s2 - 251) - l2 - 108, c2 = 2), 255 == s2 && (f2 = o3.readInt(e3, r4 + 1) / 65535, c2 = 5), i3.push(null != f2 ? f2 : "o" + u2), r4 += c2;
        }
        return i3;
      }, t3.CFF.readDict = function(e3, r4, n3) {
        for (var a2 = t3._bin, o3 = {}, i3 = []; r4 < n3; ) {
          var s2 = e3[r4], l2 = e3[r4 + 1];
          e3[r4 + 2], e3[r4 + 3], e3[r4 + 4];
          var c2 = 1, u2 = null, f2 = null;
          if (28 == s2 && (f2 = a2.readShort(e3, r4 + 1), c2 = 3), 29 == s2 && (f2 = a2.readInt(e3, r4 + 1), c2 = 5), 32 <= s2 && s2 <= 246 && (f2 = s2 - 139, c2 = 1), 247 <= s2 && s2 <= 250 && (f2 = 256 * (s2 - 247) + l2 + 108, c2 = 2), 251 <= s2 && s2 <= 254 && (f2 = 256 * -(s2 - 251) - l2 - 108, c2 = 2), 255 == s2) throw f2 = a2.readInt(e3, r4 + 1) / 65535, c2 = 5, "unknown number";
          if (30 == s2) {
            var d2 = [];
            for (c2 = 1; ; ) {
              var h2 = e3[r4 + c2];
              c2++;
              var v2 = h2 >> 4, p2 = 15 & h2;
              if (15 != v2 && d2.push(v2), 15 != p2 && d2.push(p2), 15 == p2) break;
            }
            for (var g2 = "", b2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], y2 = 0; y2 < d2.length; y2++) g2 += b2[d2[y2]];
            f2 = parseFloat(g2);
          }
          s2 <= 21 && (u2 = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][s2], c2 = 1, 12 == s2 && (u2 = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][l2], c2 = 2)), null != u2 ? (o3[u2] = 1 == i3.length ? i3[0] : i3, i3 = []) : i3.push(f2), r4 += c2;
        }
        return o3;
      }, t3.cmap = {}, t3.cmap.parse = function(e3, r4, n3) {
        e3 = new Uint8Array(e3.buffer, r4, n3), r4 = 0;
        var a2 = t3._bin, o3 = {};
        a2.readUshort(e3, r4), r4 += 2;
        var i3 = a2.readUshort(e3, r4);
        r4 += 2;
        var s2 = [];
        o3.tables = [];
        for (var l2 = 0; l2 < i3; l2++) {
          var c2 = a2.readUshort(e3, r4);
          r4 += 2;
          var u2 = a2.readUshort(e3, r4);
          r4 += 2;
          var f2 = a2.readUint(e3, r4);
          r4 += 4;
          var d2 = "p" + c2 + "e" + u2, h2 = s2.indexOf(f2);
          if (-1 == h2) {
            var v2;
            h2 = o3.tables.length, s2.push(f2);
            var p2 = a2.readUshort(e3, f2);
            0 == p2 ? v2 = t3.cmap.parse0(e3, f2) : 4 == p2 ? v2 = t3.cmap.parse4(e3, f2) : 6 == p2 ? v2 = t3.cmap.parse6(e3, f2) : 12 == p2 ? v2 = t3.cmap.parse12(e3, f2) : console.debug("unknown format: " + p2, c2, u2, f2), o3.tables.push(v2);
          }
          if (null != o3[d2]) throw "multiple tables for one platform+encoding";
          o3[d2] = h2;
        }
        return o3;
      }, t3.cmap.parse0 = function(e3, r4) {
        var n3 = t3._bin, a2 = {};
        a2.format = n3.readUshort(e3, r4), r4 += 2;
        var o3 = n3.readUshort(e3, r4);
        r4 += 2, n3.readUshort(e3, r4), r4 += 2, a2.map = [];
        for (var i3 = 0; i3 < o3 - 6; i3++) a2.map.push(e3[r4 + i3]);
        return a2;
      }, t3.cmap.parse4 = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = {};
        o3.format = n3.readUshort(e3, r4), r4 += 2;
        var i3 = n3.readUshort(e3, r4);
        r4 += 2, n3.readUshort(e3, r4), r4 += 2;
        var s2 = n3.readUshort(e3, r4);
        r4 += 2;
        var l2 = s2 / 2;
        o3.searchRange = n3.readUshort(e3, r4), r4 += 2, o3.entrySelector = n3.readUshort(e3, r4), r4 += 2, o3.rangeShift = n3.readUshort(e3, r4), r4 += 2, o3.endCount = n3.readUshorts(e3, r4, l2), r4 += 2 * l2, r4 += 2, o3.startCount = n3.readUshorts(e3, r4, l2), r4 += 2 * l2, o3.idDelta = [];
        for (var c2 = 0; c2 < l2; c2++) o3.idDelta.push(n3.readShort(e3, r4)), r4 += 2;
        for (o3.idRangeOffset = n3.readUshorts(e3, r4, l2), r4 += 2 * l2, o3.glyphIdArray = []; r4 < a2 + i3; ) o3.glyphIdArray.push(n3.readUshort(e3, r4)), r4 += 2;
        return o3;
      }, t3.cmap.parse6 = function(e3, r4) {
        var n3 = t3._bin, a2 = {};
        a2.format = n3.readUshort(e3, r4), r4 += 2, n3.readUshort(e3, r4), r4 += 2, n3.readUshort(e3, r4), r4 += 2, a2.firstCode = n3.readUshort(e3, r4), r4 += 2;
        var o3 = n3.readUshort(e3, r4);
        r4 += 2, a2.glyphIdArray = [];
        for (var i3 = 0; i3 < o3; i3++) a2.glyphIdArray.push(n3.readUshort(e3, r4)), r4 += 2;
        return a2;
      }, t3.cmap.parse12 = function(e3, r4) {
        var n3 = t3._bin, a2 = {};
        a2.format = n3.readUshort(e3, r4), r4 += 2, r4 += 2, n3.readUint(e3, r4), r4 += 4, n3.readUint(e3, r4), r4 += 4;
        var o3 = n3.readUint(e3, r4);
        r4 += 4, a2.groups = [];
        for (var i3 = 0; i3 < o3; i3++) {
          var s2 = r4 + 12 * i3, l2 = n3.readUint(e3, s2 + 0), c2 = n3.readUint(e3, s2 + 4), u2 = n3.readUint(e3, s2 + 8);
          a2.groups.push([l2, c2, u2]);
        }
        return a2;
      }, t3.glyf = {}, t3.glyf.parse = function(e3, t4, r4, n3) {
        for (var a2 = [], o3 = 0; o3 < n3.maxp.numGlyphs; o3++) a2.push(null);
        return a2;
      }, t3.glyf._parseGlyf = function(e3, r4) {
        var n3 = t3._bin, a2 = e3._data, o3 = t3._tabOffset(a2, "glyf", e3._offset) + e3.loca[r4];
        if (e3.loca[r4] == e3.loca[r4 + 1]) return null;
        var i3 = {};
        if (i3.noc = n3.readShort(a2, o3), o3 += 2, i3.xMin = n3.readShort(a2, o3), o3 += 2, i3.yMin = n3.readShort(a2, o3), o3 += 2, i3.xMax = n3.readShort(a2, o3), o3 += 2, i3.yMax = n3.readShort(a2, o3), o3 += 2, i3.xMin >= i3.xMax || i3.yMin >= i3.yMax) return null;
        if (i3.noc > 0) {
          i3.endPts = [];
          for (var s2 = 0; s2 < i3.noc; s2++) i3.endPts.push(n3.readUshort(a2, o3)), o3 += 2;
          var l2 = n3.readUshort(a2, o3);
          if (o3 += 2, a2.length - o3 < l2) return null;
          i3.instructions = n3.readBytes(a2, o3, l2), o3 += l2;
          var c2 = i3.endPts[i3.noc - 1] + 1;
          for (i3.flags = [], s2 = 0; s2 < c2; s2++) {
            var u2 = a2[o3];
            if (o3++, i3.flags.push(u2), 0 != (8 & u2)) {
              var f2 = a2[o3];
              o3++;
              for (var d2 = 0; d2 < f2; d2++) i3.flags.push(u2), s2++;
            }
          }
          for (i3.xs = [], s2 = 0; s2 < c2; s2++) {
            var h2 = 0 != (2 & i3.flags[s2]), v2 = 0 != (16 & i3.flags[s2]);
            h2 ? (i3.xs.push(v2 ? a2[o3] : -a2[o3]), o3++) : v2 ? i3.xs.push(0) : (i3.xs.push(n3.readShort(a2, o3)), o3 += 2);
          }
          for (i3.ys = [], s2 = 0; s2 < c2; s2++) h2 = 0 != (4 & i3.flags[s2]), v2 = 0 != (32 & i3.flags[s2]), h2 ? (i3.ys.push(v2 ? a2[o3] : -a2[o3]), o3++) : v2 ? i3.ys.push(0) : (i3.ys.push(n3.readShort(a2, o3)), o3 += 2);
          var p2 = 0, g2 = 0;
          for (s2 = 0; s2 < c2; s2++) p2 += i3.xs[s2], g2 += i3.ys[s2], i3.xs[s2] = p2, i3.ys[s2] = g2;
        } else {
          var b2;
          i3.parts = [];
          do {
            b2 = n3.readUshort(a2, o3), o3 += 2;
            var y2 = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
            if (i3.parts.push(y2), y2.glyphIndex = n3.readUshort(a2, o3), o3 += 2, 1 & b2) {
              var m2 = n3.readShort(a2, o3);
              o3 += 2;
              var x2 = n3.readShort(a2, o3);
              o3 += 2;
            } else m2 = n3.readInt8(a2, o3), o3++, x2 = n3.readInt8(a2, o3), o3++;
            2 & b2 ? (y2.m.tx = m2, y2.m.ty = x2) : (y2.p1 = m2, y2.p2 = x2), 8 & b2 ? (y2.m.a = y2.m.d = n3.readF2dot14(a2, o3), o3 += 2) : 64 & b2 ? (y2.m.a = n3.readF2dot14(a2, o3), o3 += 2, y2.m.d = n3.readF2dot14(a2, o3), o3 += 2) : 128 & b2 && (y2.m.a = n3.readF2dot14(a2, o3), o3 += 2, y2.m.b = n3.readF2dot14(a2, o3), o3 += 2, y2.m.c = n3.readF2dot14(a2, o3), o3 += 2, y2.m.d = n3.readF2dot14(a2, o3), o3 += 2);
          } while (32 & b2);
          if (256 & b2) {
            var k2 = n3.readUshort(a2, o3);
            for (o3 += 2, i3.instr = [], s2 = 0; s2 < k2; s2++) i3.instr.push(a2[o3]), o3++;
          }
        }
        return i3;
      }, t3.GPOS = {}, t3.GPOS.parse = function(e3, r4, n3, a2) {
        return t3._lctf.parse(e3, r4, n3, a2, t3.GPOS.subt);
      }, t3.GPOS.subt = function(e3, r4, n3, a2) {
        var o3 = t3._bin, i3 = n3, s2 = {};
        if (s2.fmt = o3.readUshort(e3, n3), n3 += 2, 1 == r4 || 2 == r4 || 3 == r4 || 7 == r4 || 8 == r4 && s2.fmt <= 2) {
          var l2 = o3.readUshort(e3, n3);
          n3 += 2, s2.coverage = t3._lctf.readCoverage(e3, l2 + i3);
        }
        if (1 == r4 && 1 == s2.fmt) {
          var c2 = o3.readUshort(e3, n3);
          n3 += 2;
          var u2 = t3._lctf.numOfOnes(c2);
          0 != c2 && (s2.pos = t3.GPOS.readValueRecord(e3, n3, c2));
        } else if (2 == r4 && s2.fmt >= 1 && s2.fmt <= 2) {
          c2 = o3.readUshort(e3, n3), n3 += 2;
          var f2 = o3.readUshort(e3, n3);
          n3 += 2, u2 = t3._lctf.numOfOnes(c2);
          var d2 = t3._lctf.numOfOnes(f2);
          if (1 == s2.fmt) {
            s2.pairsets = [];
            var h2 = o3.readUshort(e3, n3);
            n3 += 2;
            for (var v2 = 0; v2 < h2; v2++) {
              var p2 = i3 + o3.readUshort(e3, n3);
              n3 += 2;
              var g2 = o3.readUshort(e3, p2);
              p2 += 2;
              for (var b2 = [], y2 = 0; y2 < g2; y2++) {
                var m2 = o3.readUshort(e3, p2);
                p2 += 2, 0 != c2 && (T2 = t3.GPOS.readValueRecord(e3, p2, c2), p2 += 2 * u2), 0 != f2 && (_2 = t3.GPOS.readValueRecord(e3, p2, f2), p2 += 2 * d2), b2.push({ gid2: m2, val1: T2, val2: _2 });
              }
              s2.pairsets.push(b2);
            }
          }
          if (2 == s2.fmt) {
            var x2 = o3.readUshort(e3, n3);
            n3 += 2;
            var k2 = o3.readUshort(e3, n3);
            n3 += 2;
            var w2 = o3.readUshort(e3, n3);
            n3 += 2;
            var S2 = o3.readUshort(e3, n3);
            for (n3 += 2, s2.classDef1 = t3._lctf.readClassDef(e3, i3 + x2), s2.classDef2 = t3._lctf.readClassDef(e3, i3 + k2), s2.matrix = [], v2 = 0; v2 < w2; v2++) {
              var U2 = [];
              for (y2 = 0; y2 < S2; y2++) {
                var T2 = null, _2 = null;
                0 != c2 && (T2 = t3.GPOS.readValueRecord(e3, n3, c2), n3 += 2 * u2), 0 != f2 && (_2 = t3.GPOS.readValueRecord(e3, n3, f2), n3 += 2 * d2), U2.push({ val1: T2, val2: _2 });
              }
              s2.matrix.push(U2);
            }
          }
        } else {
          if (9 == r4 && 1 == s2.fmt) {
            var E2 = o3.readUshort(e3, n3);
            n3 += 2;
            var F2 = o3.readUint(e3, n3);
            if (n3 += 4, 9 == a2.ltype) a2.ltype = E2;
            else if (a2.ltype != E2) throw "invalid extension substitution";
            return t3.GPOS.subt(e3, a2.ltype, i3 + F2);
          }
          console.debug("unsupported GPOS table LookupType", r4, "format", s2.fmt);
        }
        return s2;
      }, t3.GPOS.readValueRecord = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = [];
        return o3.push(1 & n3 ? a2.readShort(e3, r4) : 0), r4 += 1 & n3 ? 2 : 0, o3.push(2 & n3 ? a2.readShort(e3, r4) : 0), r4 += 2 & n3 ? 2 : 0, o3.push(4 & n3 ? a2.readShort(e3, r4) : 0), r4 += 4 & n3 ? 2 : 0, o3.push(8 & n3 ? a2.readShort(e3, r4) : 0), r4 += 8 & n3 ? 2 : 0, o3;
      }, t3.GSUB = {}, t3.GSUB.parse = function(e3, r4, n3, a2) {
        return t3._lctf.parse(e3, r4, n3, a2, t3.GSUB.subt);
      }, t3.GSUB.subt = function(e3, r4, n3, a2) {
        var o3 = t3._bin, i3 = n3, s2 = {};
        if (s2.fmt = o3.readUshort(e3, n3), n3 += 2, 1 != r4 && 4 != r4 && 5 != r4 && 6 != r4) return null;
        if (1 == r4 || 4 == r4 || 5 == r4 && s2.fmt <= 2 || 6 == r4 && s2.fmt <= 2) {
          var l2 = o3.readUshort(e3, n3);
          n3 += 2, s2.coverage = t3._lctf.readCoverage(e3, i3 + l2);
        }
        if (1 == r4 && s2.fmt >= 1 && s2.fmt <= 2) {
          if (1 == s2.fmt) s2.delta = o3.readShort(e3, n3), n3 += 2;
          else if (2 == s2.fmt) {
            var c2 = o3.readUshort(e3, n3);
            n3 += 2, s2.newg = o3.readUshorts(e3, n3, c2), n3 += 2 * s2.newg.length;
          }
        } else if (4 == r4) {
          s2.vals = [], c2 = o3.readUshort(e3, n3), n3 += 2;
          for (var u2 = 0; u2 < c2; u2++) {
            var f2 = o3.readUshort(e3, n3);
            n3 += 2, s2.vals.push(t3.GSUB.readLigatureSet(e3, i3 + f2));
          }
        } else if (5 == r4 && 2 == s2.fmt) {
          if (2 == s2.fmt) {
            var d2 = o3.readUshort(e3, n3);
            n3 += 2, s2.cDef = t3._lctf.readClassDef(e3, i3 + d2), s2.scset = [];
            var h2 = o3.readUshort(e3, n3);
            for (n3 += 2, u2 = 0; u2 < h2; u2++) {
              var v2 = o3.readUshort(e3, n3);
              n3 += 2, s2.scset.push(0 == v2 ? null : t3.GSUB.readSubClassSet(e3, i3 + v2));
            }
          }
        } else if (6 == r4 && 3 == s2.fmt) {
          if (3 == s2.fmt) {
            for (u2 = 0; u2 < 3; u2++) {
              c2 = o3.readUshort(e3, n3), n3 += 2;
              for (var p2 = [], g2 = 0; g2 < c2; g2++) p2.push(t3._lctf.readCoverage(e3, i3 + o3.readUshort(e3, n3 + 2 * g2)));
              n3 += 2 * c2, 0 == u2 && (s2.backCvg = p2), 1 == u2 && (s2.inptCvg = p2), 2 == u2 && (s2.ahedCvg = p2);
            }
            c2 = o3.readUshort(e3, n3), n3 += 2, s2.lookupRec = t3.GSUB.readSubstLookupRecords(e3, n3, c2);
          }
        } else {
          if (7 == r4 && 1 == s2.fmt) {
            var b2 = o3.readUshort(e3, n3);
            n3 += 2;
            var y2 = o3.readUint(e3, n3);
            if (n3 += 4, 9 == a2.ltype) a2.ltype = b2;
            else if (a2.ltype != b2) throw "invalid extension substitution";
            return t3.GSUB.subt(e3, a2.ltype, i3 + y2);
          }
          console.debug("unsupported GSUB table LookupType", r4, "format", s2.fmt);
        }
        return s2;
      }, t3.GSUB.readSubClassSet = function(e3, r4) {
        var n3 = t3._bin.readUshort, a2 = r4, o3 = [], i3 = n3(e3, r4);
        r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = n3(e3, r4);
          r4 += 2, o3.push(t3.GSUB.readSubClassRule(e3, a2 + l2));
        }
        return o3;
      }, t3.GSUB.readSubClassRule = function(e3, r4) {
        var n3 = t3._bin.readUshort, a2 = {}, o3 = n3(e3, r4), i3 = n3(e3, r4 += 2);
        r4 += 2, a2.input = [];
        for (var s2 = 0; s2 < o3 - 1; s2++) a2.input.push(n3(e3, r4)), r4 += 2;
        return a2.substLookupRecords = t3.GSUB.readSubstLookupRecords(e3, r4, i3), a2;
      }, t3.GSUB.readSubstLookupRecords = function(e3, r4, n3) {
        for (var a2 = t3._bin.readUshort, o3 = [], i3 = 0; i3 < n3; i3++) o3.push(a2(e3, r4), a2(e3, r4 + 2)), r4 += 4;
        return o3;
      }, t3.GSUB.readChainSubClassSet = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = [], i3 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = n3.readUshort(e3, r4);
          r4 += 2, o3.push(t3.GSUB.readChainSubClassRule(e3, a2 + l2));
        }
        return o3;
      }, t3.GSUB.readChainSubClassRule = function(e3, r4) {
        for (var n3 = t3._bin, a2 = {}, o3 = ["backtrack", "input", "lookahead"], i3 = 0; i3 < o3.length; i3++) {
          var s2 = n3.readUshort(e3, r4);
          r4 += 2, 1 == i3 && s2--, a2[o3[i3]] = n3.readUshorts(e3, r4, s2), r4 += 2 * a2[o3[i3]].length;
        }
        return s2 = n3.readUshort(e3, r4), r4 += 2, a2.subst = n3.readUshorts(e3, r4, 2 * s2), r4 += 2 * a2.subst.length, a2;
      }, t3.GSUB.readLigatureSet = function(e3, r4) {
        var n3 = t3._bin, a2 = r4, o3 = [], i3 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = n3.readUshort(e3, r4);
          r4 += 2, o3.push(t3.GSUB.readLigature(e3, a2 + l2));
        }
        return o3;
      }, t3.GSUB.readLigature = function(e3, r4) {
        var n3 = t3._bin, a2 = { chain: [] };
        a2.nglyph = n3.readUshort(e3, r4), r4 += 2;
        var o3 = n3.readUshort(e3, r4);
        r4 += 2;
        for (var i3 = 0; i3 < o3 - 1; i3++) a2.chain.push(n3.readUshort(e3, r4)), r4 += 2;
        return a2;
      }, t3.head = {}, t3.head.parse = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = {};
        return a2.readFixed(e3, r4), r4 += 4, o3.fontRevision = a2.readFixed(e3, r4), r4 += 4, a2.readUint(e3, r4), r4 += 4, a2.readUint(e3, r4), r4 += 4, o3.flags = a2.readUshort(e3, r4), r4 += 2, o3.unitsPerEm = a2.readUshort(e3, r4), r4 += 2, o3.created = a2.readUint64(e3, r4), r4 += 8, o3.modified = a2.readUint64(e3, r4), r4 += 8, o3.xMin = a2.readShort(e3, r4), r4 += 2, o3.yMin = a2.readShort(e3, r4), r4 += 2, o3.xMax = a2.readShort(e3, r4), r4 += 2, o3.yMax = a2.readShort(e3, r4), r4 += 2, o3.macStyle = a2.readUshort(e3, r4), r4 += 2, o3.lowestRecPPEM = a2.readUshort(e3, r4), r4 += 2, o3.fontDirectionHint = a2.readShort(e3, r4), r4 += 2, o3.indexToLocFormat = a2.readShort(e3, r4), r4 += 2, o3.glyphDataFormat = a2.readShort(e3, r4), r4 += 2, o3;
      }, t3.hhea = {}, t3.hhea.parse = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = {};
        return a2.readFixed(e3, r4), r4 += 4, o3.ascender = a2.readShort(e3, r4), r4 += 2, o3.descender = a2.readShort(e3, r4), r4 += 2, o3.lineGap = a2.readShort(e3, r4), r4 += 2, o3.advanceWidthMax = a2.readUshort(e3, r4), r4 += 2, o3.minLeftSideBearing = a2.readShort(e3, r4), r4 += 2, o3.minRightSideBearing = a2.readShort(e3, r4), r4 += 2, o3.xMaxExtent = a2.readShort(e3, r4), r4 += 2, o3.caretSlopeRise = a2.readShort(e3, r4), r4 += 2, o3.caretSlopeRun = a2.readShort(e3, r4), r4 += 2, o3.caretOffset = a2.readShort(e3, r4), r4 += 2, r4 += 8, o3.metricDataFormat = a2.readShort(e3, r4), r4 += 2, o3.numberOfHMetrics = a2.readUshort(e3, r4), r4 += 2, o3;
      }, t3.hmtx = {}, t3.hmtx.parse = function(e3, r4, n3, a2) {
        for (var o3 = t3._bin, i3 = { aWidth: [], lsBearing: [] }, s2 = 0, l2 = 0, c2 = 0; c2 < a2.maxp.numGlyphs; c2++) c2 < a2.hhea.numberOfHMetrics && (s2 = o3.readUshort(e3, r4), r4 += 2, l2 = o3.readShort(e3, r4), r4 += 2), i3.aWidth.push(s2), i3.lsBearing.push(l2);
        return i3;
      }, t3.kern = {}, t3.kern.parse = function(e3, r4, n3, a2) {
        var o3 = t3._bin, i3 = o3.readUshort(e3, r4);
        if (r4 += 2, 1 == i3) return t3.kern.parseV1(e3, r4 - 2, n3, a2);
        var s2 = o3.readUshort(e3, r4);
        r4 += 2;
        for (var l2 = { glyph1: [], rval: [] }, c2 = 0; c2 < s2; c2++) {
          r4 += 2, n3 = o3.readUshort(e3, r4), r4 += 2;
          var u2 = o3.readUshort(e3, r4);
          r4 += 2;
          var f2 = u2 >>> 8;
          if (0 != (f2 &= 15)) throw "unknown kern table format: " + f2;
          r4 = t3.kern.readFormat0(e3, r4, l2);
        }
        return l2;
      }, t3.kern.parseV1 = function(e3, r4, n3, a2) {
        var o3 = t3._bin;
        o3.readFixed(e3, r4), r4 += 4;
        var i3 = o3.readUint(e3, r4);
        r4 += 4;
        for (var s2 = { glyph1: [], rval: [] }, l2 = 0; l2 < i3; l2++) {
          o3.readUint(e3, r4), r4 += 4;
          var c2 = o3.readUshort(e3, r4);
          r4 += 2, o3.readUshort(e3, r4), r4 += 2;
          var u2 = c2 >>> 8;
          if (0 != (u2 &= 15)) throw "unknown kern table format: " + u2;
          r4 = t3.kern.readFormat0(e3, r4, s2);
        }
        return s2;
      }, t3.kern.readFormat0 = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = -1, i3 = a2.readUshort(e3, r4);
        r4 += 2, a2.readUshort(e3, r4), r4 += 2, a2.readUshort(e3, r4), r4 += 2, a2.readUshort(e3, r4), r4 += 2;
        for (var s2 = 0; s2 < i3; s2++) {
          var l2 = a2.readUshort(e3, r4);
          r4 += 2;
          var c2 = a2.readUshort(e3, r4);
          r4 += 2;
          var u2 = a2.readShort(e3, r4);
          r4 += 2, l2 != o3 && (n3.glyph1.push(l2), n3.rval.push({ glyph2: [], vals: [] }));
          var f2 = n3.rval[n3.rval.length - 1];
          f2.glyph2.push(c2), f2.vals.push(u2), o3 = l2;
        }
        return r4;
      }, t3.loca = {}, t3.loca.parse = function(e3, r4, n3, a2) {
        var o3 = t3._bin, i3 = [], s2 = a2.head.indexToLocFormat, l2 = a2.maxp.numGlyphs + 1;
        if (0 == s2) for (var c2 = 0; c2 < l2; c2++) i3.push(o3.readUshort(e3, r4 + (c2 << 1)) << 1);
        if (1 == s2) for (c2 = 0; c2 < l2; c2++) i3.push(o3.readUint(e3, r4 + (c2 << 2)));
        return i3;
      }, t3.maxp = {}, t3.maxp.parse = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = {}, i3 = a2.readUint(e3, r4);
        return r4 += 4, o3.numGlyphs = a2.readUshort(e3, r4), r4 += 2, 65536 == i3 && (o3.maxPoints = a2.readUshort(e3, r4), r4 += 2, o3.maxContours = a2.readUshort(e3, r4), r4 += 2, o3.maxCompositePoints = a2.readUshort(e3, r4), r4 += 2, o3.maxCompositeContours = a2.readUshort(e3, r4), r4 += 2, o3.maxZones = a2.readUshort(e3, r4), r4 += 2, o3.maxTwilightPoints = a2.readUshort(e3, r4), r4 += 2, o3.maxStorage = a2.readUshort(e3, r4), r4 += 2, o3.maxFunctionDefs = a2.readUshort(e3, r4), r4 += 2, o3.maxInstructionDefs = a2.readUshort(e3, r4), r4 += 2, o3.maxStackElements = a2.readUshort(e3, r4), r4 += 2, o3.maxSizeOfInstructions = a2.readUshort(e3, r4), r4 += 2, o3.maxComponentElements = a2.readUshort(e3, r4), r4 += 2, o3.maxComponentDepth = a2.readUshort(e3, r4), r4 += 2), o3;
      }, t3.name = {}, t3.name.parse = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = {};
        a2.readUshort(e3, r4), r4 += 2;
        var i3 = a2.readUshort(e3, r4);
        r4 += 2, a2.readUshort(e3, r4);
        for (var s2, l2 = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], c2 = r4 += 2, u2 = 0; u2 < i3; u2++) {
          var f2 = a2.readUshort(e3, r4);
          r4 += 2;
          var d2 = a2.readUshort(e3, r4);
          r4 += 2;
          var h2 = a2.readUshort(e3, r4);
          r4 += 2;
          var v2 = a2.readUshort(e3, r4);
          r4 += 2;
          var p2 = a2.readUshort(e3, r4);
          r4 += 2;
          var g2 = a2.readUshort(e3, r4);
          r4 += 2;
          var b2, y2 = l2[v2], m2 = c2 + 12 * i3 + g2;
          if (0 == f2) b2 = a2.readUnicode(e3, m2, p2 / 2);
          else if (3 == f2 && 0 == d2) b2 = a2.readUnicode(e3, m2, p2 / 2);
          else if (0 == d2) b2 = a2.readASCII(e3, m2, p2);
          else if (1 == d2) b2 = a2.readUnicode(e3, m2, p2 / 2);
          else if (3 == d2) b2 = a2.readUnicode(e3, m2, p2 / 2);
          else {
            if (1 != f2) throw "unknown encoding " + d2 + ", platformID: " + f2;
            b2 = a2.readASCII(e3, m2, p2), console.debug("reading unknown MAC encoding " + d2 + " as ASCII");
          }
          var x2 = "p" + f2 + "," + h2.toString(16);
          null == o3[x2] && (o3[x2] = {}), o3[x2][void 0 !== y2 ? y2 : v2] = b2, o3[x2]._lang = h2;
        }
        for (var k2 in o3) if (null != o3[k2].postScriptName && 1033 == o3[k2]._lang) return o3[k2];
        for (var k2 in o3) if (null != o3[k2].postScriptName && 0 == o3[k2]._lang) return o3[k2];
        for (var k2 in o3) if (null != o3[k2].postScriptName && 3084 == o3[k2]._lang) return o3[k2];
        for (var k2 in o3) if (null != o3[k2].postScriptName) return o3[k2];
        for (var k2 in o3) {
          s2 = k2;
          break;
        }
        return console.debug("returning name table with languageID " + o3[s2]._lang), o3[s2];
      }, t3["OS/2"] = {}, t3["OS/2"].parse = function(e3, r4, n3) {
        var a2 = t3._bin.readUshort(e3, r4);
        r4 += 2;
        var o3 = {};
        if (0 == a2) t3["OS/2"].version0(e3, r4, o3);
        else if (1 == a2) t3["OS/2"].version1(e3, r4, o3);
        else if (2 == a2 || 3 == a2 || 4 == a2) t3["OS/2"].version2(e3, r4, o3);
        else {
          if (5 != a2) throw "unknown OS/2 table version: " + a2;
          t3["OS/2"].version5(e3, r4, o3);
        }
        return o3;
      }, t3["OS/2"].version0 = function(e3, r4, n3) {
        var a2 = t3._bin;
        return n3.xAvgCharWidth = a2.readShort(e3, r4), r4 += 2, n3.usWeightClass = a2.readUshort(e3, r4), r4 += 2, n3.usWidthClass = a2.readUshort(e3, r4), r4 += 2, n3.fsType = a2.readUshort(e3, r4), r4 += 2, n3.ySubscriptXSize = a2.readShort(e3, r4), r4 += 2, n3.ySubscriptYSize = a2.readShort(e3, r4), r4 += 2, n3.ySubscriptXOffset = a2.readShort(e3, r4), r4 += 2, n3.ySubscriptYOffset = a2.readShort(e3, r4), r4 += 2, n3.ySuperscriptXSize = a2.readShort(e3, r4), r4 += 2, n3.ySuperscriptYSize = a2.readShort(e3, r4), r4 += 2, n3.ySuperscriptXOffset = a2.readShort(e3, r4), r4 += 2, n3.ySuperscriptYOffset = a2.readShort(e3, r4), r4 += 2, n3.yStrikeoutSize = a2.readShort(e3, r4), r4 += 2, n3.yStrikeoutPosition = a2.readShort(e3, r4), r4 += 2, n3.sFamilyClass = a2.readShort(e3, r4), r4 += 2, n3.panose = a2.readBytes(e3, r4, 10), r4 += 10, n3.ulUnicodeRange1 = a2.readUint(e3, r4), r4 += 4, n3.ulUnicodeRange2 = a2.readUint(e3, r4), r4 += 4, n3.ulUnicodeRange3 = a2.readUint(e3, r4), r4 += 4, n3.ulUnicodeRange4 = a2.readUint(e3, r4), r4 += 4, n3.achVendID = [a2.readInt8(e3, r4), a2.readInt8(e3, r4 + 1), a2.readInt8(e3, r4 + 2), a2.readInt8(e3, r4 + 3)], r4 += 4, n3.fsSelection = a2.readUshort(e3, r4), r4 += 2, n3.usFirstCharIndex = a2.readUshort(e3, r4), r4 += 2, n3.usLastCharIndex = a2.readUshort(e3, r4), r4 += 2, n3.sTypoAscender = a2.readShort(e3, r4), r4 += 2, n3.sTypoDescender = a2.readShort(e3, r4), r4 += 2, n3.sTypoLineGap = a2.readShort(e3, r4), r4 += 2, n3.usWinAscent = a2.readUshort(e3, r4), r4 += 2, n3.usWinDescent = a2.readUshort(e3, r4), r4 + 2;
      }, t3["OS/2"].version1 = function(e3, r4, n3) {
        var a2 = t3._bin;
        return r4 = t3["OS/2"].version0(e3, r4, n3), n3.ulCodePageRange1 = a2.readUint(e3, r4), r4 += 4, n3.ulCodePageRange2 = a2.readUint(e3, r4), r4 + 4;
      }, t3["OS/2"].version2 = function(e3, r4, n3) {
        var a2 = t3._bin;
        return r4 = t3["OS/2"].version1(e3, r4, n3), n3.sxHeight = a2.readShort(e3, r4), r4 += 2, n3.sCapHeight = a2.readShort(e3, r4), r4 += 2, n3.usDefault = a2.readUshort(e3, r4), r4 += 2, n3.usBreak = a2.readUshort(e3, r4), r4 += 2, n3.usMaxContext = a2.readUshort(e3, r4), r4 + 2;
      }, t3["OS/2"].version5 = function(e3, r4, n3) {
        var a2 = t3._bin;
        return r4 = t3["OS/2"].version2(e3, r4, n3), n3.usLowerOpticalPointSize = a2.readUshort(e3, r4), r4 += 2, n3.usUpperOpticalPointSize = a2.readUshort(e3, r4), r4 + 2;
      }, t3.post = {}, t3.post.parse = function(e3, r4, n3) {
        var a2 = t3._bin, o3 = {};
        return o3.version = a2.readFixed(e3, r4), r4 += 4, o3.italicAngle = a2.readFixed(e3, r4), r4 += 4, o3.underlinePosition = a2.readShort(e3, r4), r4 += 2, o3.underlineThickness = a2.readShort(e3, r4), r4 += 2, o3;
      }, null == t3 && (t3 = {}), null == t3.U && (t3.U = {}), t3.U.codeToGlyph = function(e3, t4) {
        var r4 = e3.cmap, n3 = -1;
        if (null != r4.p0e4 ? n3 = r4.p0e4 : null != r4.p3e1 ? n3 = r4.p3e1 : null != r4.p1e0 ? n3 = r4.p1e0 : null != r4.p0e3 && (n3 = r4.p0e3), -1 == n3) throw "no familiar platform and encoding!";
        var a2 = r4.tables[n3];
        if (0 == a2.format) return t4 >= a2.map.length ? 0 : a2.map[t4];
        if (4 == a2.format) {
          for (var o3 = -1, i3 = 0; i3 < a2.endCount.length; i3++) if (t4 <= a2.endCount[i3]) {
            o3 = i3;
            break;
          }
          return -1 == o3 || a2.startCount[o3] > t4 ? 0 : 65535 & (0 != a2.idRangeOffset[o3] ? a2.glyphIdArray[t4 - a2.startCount[o3] + (a2.idRangeOffset[o3] >> 1) - (a2.idRangeOffset.length - o3)] : t4 + a2.idDelta[o3]);
        }
        if (12 == a2.format) {
          if (t4 > a2.groups[a2.groups.length - 1][1]) return 0;
          for (i3 = 0; i3 < a2.groups.length; i3++) {
            var s2 = a2.groups[i3];
            if (s2[0] <= t4 && t4 <= s2[1]) return s2[2] + (t4 - s2[0]);
          }
          return 0;
        }
        throw "unknown cmap table format " + a2.format;
      }, t3.U.glyphToPath = function(e3, r4) {
        var n3 = { cmds: [], crds: [] };
        if (e3.SVG && e3.SVG.entries[r4]) {
          var a2 = e3.SVG.entries[r4];
          return null == a2 ? n3 : ("string" == typeof a2 && (a2 = t3.SVG.toPath(a2), e3.SVG.entries[r4] = a2), a2);
        }
        if (e3.CFF) {
          var o3 = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: e3.CFF.Private ? e3.CFF.Private.defaultWidthX : 0, open: false }, i3 = e3.CFF, s2 = e3.CFF.Private;
          if (i3.ROS) {
            for (var l2 = 0; i3.FDSelect[l2 + 2] <= r4; ) l2 += 2;
            s2 = i3.FDArray[i3.FDSelect[l2 + 1]].Private;
          }
          t3.U._drawCFF(e3.CFF.CharStrings[r4], o3, i3, s2, n3);
        } else e3.glyf && t3.U._drawGlyf(r4, e3, n3);
        return n3;
      }, t3.U._drawGlyf = function(e3, r4, n3) {
        var a2 = r4.glyf[e3];
        null == a2 && (a2 = r4.glyf[e3] = t3.glyf._parseGlyf(r4, e3)), null != a2 && (a2.noc > -1 ? t3.U._simpleGlyph(a2, n3) : t3.U._compoGlyph(a2, r4, n3));
      }, t3.U._simpleGlyph = function(e3, r4) {
        for (var n3 = 0; n3 < e3.noc; n3++) {
          for (var a2 = 0 == n3 ? 0 : e3.endPts[n3 - 1] + 1, o3 = e3.endPts[n3], i3 = a2; i3 <= o3; i3++) {
            var s2 = i3 == a2 ? o3 : i3 - 1, l2 = i3 == o3 ? a2 : i3 + 1, c2 = 1 & e3.flags[i3], u2 = 1 & e3.flags[s2], f2 = 1 & e3.flags[l2], d2 = e3.xs[i3], h2 = e3.ys[i3];
            if (i3 == a2) if (c2) {
              if (!u2) {
                t3.U.P.moveTo(r4, d2, h2);
                continue;
              }
              t3.U.P.moveTo(r4, e3.xs[s2], e3.ys[s2]);
            } else u2 ? t3.U.P.moveTo(r4, e3.xs[s2], e3.ys[s2]) : t3.U.P.moveTo(r4, (e3.xs[s2] + d2) / 2, (e3.ys[s2] + h2) / 2);
            c2 ? u2 && t3.U.P.lineTo(r4, d2, h2) : f2 ? t3.U.P.qcurveTo(r4, d2, h2, e3.xs[l2], e3.ys[l2]) : t3.U.P.qcurveTo(r4, d2, h2, (d2 + e3.xs[l2]) / 2, (h2 + e3.ys[l2]) / 2);
          }
          t3.U.P.closePath(r4);
        }
      }, t3.U._compoGlyph = function(e3, r4, n3) {
        for (var a2 = 0; a2 < e3.parts.length; a2++) {
          var o3 = { cmds: [], crds: [] }, i3 = e3.parts[a2];
          t3.U._drawGlyf(i3.glyphIndex, r4, o3);
          for (var s2 = i3.m, l2 = 0; l2 < o3.crds.length; l2 += 2) {
            var c2 = o3.crds[l2], u2 = o3.crds[l2 + 1];
            n3.crds.push(c2 * s2.a + u2 * s2.b + s2.tx), n3.crds.push(c2 * s2.c + u2 * s2.d + s2.ty);
          }
          for (l2 = 0; l2 < o3.cmds.length; l2++) n3.cmds.push(o3.cmds[l2]);
        }
      }, t3.U._getGlyphClass = function(e3, r4) {
        var n3 = t3._lctf.getInterval(r4, e3);
        return -1 == n3 ? 0 : r4[n3 + 2];
      }, t3.U.getPairAdjustment = function(e3, r4, n3) {
        var a2 = false;
        if (e3.GPOS) for (var o3 = e3.GPOS, i3 = o3.lookupList, s2 = o3.featureList, l2 = [], c2 = 0; c2 < s2.length; c2++) {
          var u2 = s2[c2];
          if ("kern" == u2.tag) {
            a2 = true;
            for (var f2 = 0; f2 < u2.tab.length; f2++) if (!l2[u2.tab[f2]]) {
              l2[u2.tab[f2]] = true;
              for (var d2 = i3[u2.tab[f2]], h2 = 0; h2 < d2.tabs.length; h2++) if (null != d2.tabs[h2]) {
                var v2, p2 = d2.tabs[h2];
                if (!p2.coverage || -1 != (v2 = t3._lctf.coverageIndex(p2.coverage, r4))) {
                  if (1 == d2.ltype) ;
                  else if (2 == d2.ltype) {
                    var g2 = null;
                    if (1 == p2.fmt) {
                      var b2 = p2.pairsets[v2];
                      for (c2 = 0; c2 < b2.length; c2++) b2[c2].gid2 == n3 && (g2 = b2[c2]);
                    } else if (2 == p2.fmt) {
                      var y2 = t3.U._getGlyphClass(r4, p2.classDef1), m2 = t3.U._getGlyphClass(n3, p2.classDef2);
                      g2 = p2.matrix[y2][m2];
                    }
                    if (g2) {
                      var x2 = 0;
                      return g2.val1 && g2.val1[2] && (x2 += g2.val1[2]), g2.val2 && g2.val2[0] && (x2 += g2.val2[0]), x2;
                    }
                  }
                }
              }
            }
          }
        }
        if (e3.kern && !a2) {
          var k2 = e3.kern.glyph1.indexOf(r4);
          if (-1 != k2) {
            var w2 = e3.kern.rval[k2].glyph2.indexOf(n3);
            if (-1 != w2) return e3.kern.rval[k2].vals[w2];
          }
        }
        return 0;
      }, t3.U._applySubs = function(e3, r4, n3, a2) {
        for (var o3 = e3.length - r4 - 1, i3 = 0; i3 < n3.tabs.length; i3++) if (null != n3.tabs[i3]) {
          var s2, l2 = n3.tabs[i3];
          if (!l2.coverage || -1 != (s2 = t3._lctf.coverageIndex(l2.coverage, e3[r4]))) {
            if (1 == n3.ltype) e3[r4], 1 == l2.fmt ? e3[r4] = e3[r4] + l2.delta : e3[r4] = l2.newg[s2];
            else if (4 == n3.ltype) for (var c2 = l2.vals[s2], u2 = 0; u2 < c2.length; u2++) {
              var f2 = c2[u2], d2 = f2.chain.length;
              if (!(d2 > o3)) {
                for (var h2 = true, v2 = 0, p2 = 0; p2 < d2; p2++) {
                  for (; -1 == e3[r4 + v2 + (1 + p2)]; ) v2++;
                  f2.chain[p2] != e3[r4 + v2 + (1 + p2)] && (h2 = false);
                }
                if (h2) {
                  for (e3[r4] = f2.nglyph, p2 = 0; p2 < d2 + v2; p2++) e3[r4 + p2 + 1] = -1;
                  break;
                }
              }
            }
            else if (5 == n3.ltype && 2 == l2.fmt) for (var g2 = t3._lctf.getInterval(l2.cDef, e3[r4]), b2 = l2.cDef[g2 + 2], y2 = l2.scset[b2], m2 = 0; m2 < y2.length; m2++) {
              var x2 = y2[m2], k2 = x2.input;
              if (!(k2.length > o3)) {
                for (h2 = true, p2 = 0; p2 < k2.length; p2++) {
                  var w2 = t3._lctf.getInterval(l2.cDef, e3[r4 + 1 + p2]);
                  if (-1 == g2 && l2.cDef[w2 + 2] != k2[p2]) {
                    h2 = false;
                    break;
                  }
                }
                if (h2) {
                  var S2 = x2.substLookupRecords;
                  for (u2 = 0; u2 < S2.length; u2 += 2) S2[u2], S2[u2 + 1];
                }
              }
            }
            else if (6 == n3.ltype && 3 == l2.fmt) {
              if (!t3.U._glsCovered(e3, l2.backCvg, r4 - l2.backCvg.length)) continue;
              if (!t3.U._glsCovered(e3, l2.inptCvg, r4)) continue;
              if (!t3.U._glsCovered(e3, l2.ahedCvg, r4 + l2.inptCvg.length)) continue;
              var U2 = l2.lookupRec;
              for (m2 = 0; m2 < U2.length; m2 += 2) {
                g2 = U2[m2];
                var T2 = a2[U2[m2 + 1]];
                t3.U._applySubs(e3, r4 + g2, T2, a2);
              }
            }
          }
        }
      }, t3.U._glsCovered = function(e3, r4, n3) {
        for (var a2 = 0; a2 < r4.length; a2++) if (-1 == t3._lctf.coverageIndex(r4[a2], e3[n3 + a2])) return false;
        return true;
      }, t3.U.glyphsToPath = function(e3, r4, n3) {
        for (var a2 = { cmds: [], crds: [] }, o3 = 0, i3 = 0; i3 < r4.length; i3++) {
          var s2 = r4[i3];
          if (-1 != s2) {
            for (var l2 = i3 < r4.length - 1 && -1 != r4[i3 + 1] ? r4[i3 + 1] : 0, c2 = t3.U.glyphToPath(e3, s2), u2 = 0; u2 < c2.crds.length; u2 += 2) a2.crds.push(c2.crds[u2] + o3), a2.crds.push(c2.crds[u2 + 1]);
            for (n3 && a2.cmds.push(n3), u2 = 0; u2 < c2.cmds.length; u2++) a2.cmds.push(c2.cmds[u2]);
            n3 && a2.cmds.push("X"), o3 += e3.hmtx.aWidth[s2], i3 < r4.length - 1 && (o3 += t3.U.getPairAdjustment(e3, s2, l2));
          }
        }
        return a2;
      }, t3.U.P = {}, t3.U.P.moveTo = function(e3, t4, r4) {
        e3.cmds.push("M"), e3.crds.push(t4, r4);
      }, t3.U.P.lineTo = function(e3, t4, r4) {
        e3.cmds.push("L"), e3.crds.push(t4, r4);
      }, t3.U.P.curveTo = function(e3, t4, r4, n3, a2, o3, i3) {
        e3.cmds.push("C"), e3.crds.push(t4, r4, n3, a2, o3, i3);
      }, t3.U.P.qcurveTo = function(e3, t4, r4, n3, a2) {
        e3.cmds.push("Q"), e3.crds.push(t4, r4, n3, a2);
      }, t3.U.P.closePath = function(e3) {
        e3.cmds.push("Z");
      }, t3.U._drawCFF = function(e3, r4, n3, a2, o3) {
        for (var i3 = r4.stack, s2 = r4.nStems, l2 = r4.haveWidth, c2 = r4.width, u2 = r4.open, f2 = 0, d2 = r4.x, h2 = r4.y, v2 = 0, p2 = 0, g2 = 0, b2 = 0, y2 = 0, m2 = 0, x2 = 0, k2 = 0, w2 = 0, S2 = 0, U2 = { val: 0, size: 0 }; f2 < e3.length; ) {
          t3.CFF.getCharString(e3, f2, U2);
          var T2 = U2.val;
          if (f2 += U2.size, "o1" == T2 || "o18" == T2) i3.length % 2 != 0 && !l2 && (c2 = i3.shift() + a2.nominalWidthX), s2 += i3.length >> 1, i3.length = 0, l2 = true;
          else if ("o3" == T2 || "o23" == T2) i3.length % 2 != 0 && !l2 && (c2 = i3.shift() + a2.nominalWidthX), s2 += i3.length >> 1, i3.length = 0, l2 = true;
          else if ("o4" == T2) i3.length > 1 && !l2 && (c2 = i3.shift() + a2.nominalWidthX, l2 = true), u2 && t3.U.P.closePath(o3), h2 += i3.pop(), t3.U.P.moveTo(o3, d2, h2), u2 = true;
          else if ("o5" == T2) for (; i3.length > 0; ) d2 += i3.shift(), h2 += i3.shift(), t3.U.P.lineTo(o3, d2, h2);
          else if ("o6" == T2 || "o7" == T2) for (var _2 = i3.length, E2 = "o6" == T2, F2 = 0; F2 < _2; F2++) {
            var C2 = i3.shift();
            E2 ? d2 += C2 : h2 += C2, E2 = !E2, t3.U.P.lineTo(o3, d2, h2);
          }
          else if ("o8" == T2 || "o24" == T2) {
            _2 = i3.length;
            for (var D2 = 0; D2 + 6 <= _2; ) v2 = d2 + i3.shift(), p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), b2 = p2 + i3.shift(), d2 = g2 + i3.shift(), h2 = b2 + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, d2, h2), D2 += 6;
            "o24" == T2 && (d2 += i3.shift(), h2 += i3.shift(), t3.U.P.lineTo(o3, d2, h2));
          } else {
            if ("o11" == T2) break;
            if ("o1234" == T2 || "o1235" == T2 || "o1236" == T2 || "o1237" == T2) "o1234" == T2 && (p2 = h2, g2 = (v2 = d2 + i3.shift()) + i3.shift(), S2 = b2 = p2 + i3.shift(), m2 = b2, k2 = h2, d2 = (x2 = (y2 = (w2 = g2 + i3.shift()) + i3.shift()) + i3.shift()) + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, w2, S2), t3.U.P.curveTo(o3, y2, m2, x2, k2, d2, h2)), "o1235" == T2 && (v2 = d2 + i3.shift(), p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), b2 = p2 + i3.shift(), w2 = g2 + i3.shift(), S2 = b2 + i3.shift(), y2 = w2 + i3.shift(), m2 = S2 + i3.shift(), x2 = y2 + i3.shift(), k2 = m2 + i3.shift(), d2 = x2 + i3.shift(), h2 = k2 + i3.shift(), i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, w2, S2), t3.U.P.curveTo(o3, y2, m2, x2, k2, d2, h2)), "o1236" == T2 && (v2 = d2 + i3.shift(), p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), S2 = b2 = p2 + i3.shift(), m2 = b2, x2 = (y2 = (w2 = g2 + i3.shift()) + i3.shift()) + i3.shift(), k2 = m2 + i3.shift(), d2 = x2 + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, w2, S2), t3.U.P.curveTo(o3, y2, m2, x2, k2, d2, h2)), "o1237" == T2 && (v2 = d2 + i3.shift(), p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), b2 = p2 + i3.shift(), w2 = g2 + i3.shift(), S2 = b2 + i3.shift(), y2 = w2 + i3.shift(), m2 = S2 + i3.shift(), x2 = y2 + i3.shift(), k2 = m2 + i3.shift(), Math.abs(x2 - d2) > Math.abs(k2 - h2) ? d2 = x2 + i3.shift() : h2 = k2 + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, w2, S2), t3.U.P.curveTo(o3, y2, m2, x2, k2, d2, h2));
            else if ("o14" == T2) {
              if (i3.length > 0 && !l2 && (c2 = i3.shift() + n3.nominalWidthX, l2 = true), 4 == i3.length) {
                var A2 = i3.shift(), M2 = i3.shift(), P2 = i3.shift(), I2 = i3.shift(), L2 = t3.CFF.glyphBySE(n3, P2), O2 = t3.CFF.glyphBySE(n3, I2);
                t3.U._drawCFF(n3.CharStrings[L2], r4, n3, a2, o3), r4.x = A2, r4.y = M2, t3.U._drawCFF(n3.CharStrings[O2], r4, n3, a2, o3);
              }
              u2 && (t3.U.P.closePath(o3), u2 = false);
            } else if ("o19" == T2 || "o20" == T2) i3.length % 2 != 0 && !l2 && (c2 = i3.shift() + a2.nominalWidthX), s2 += i3.length >> 1, i3.length = 0, l2 = true, f2 += s2 + 7 >> 3;
            else if ("o21" == T2) i3.length > 2 && !l2 && (c2 = i3.shift() + a2.nominalWidthX, l2 = true), h2 += i3.pop(), d2 += i3.pop(), u2 && t3.U.P.closePath(o3), t3.U.P.moveTo(o3, d2, h2), u2 = true;
            else if ("o22" == T2) i3.length > 1 && !l2 && (c2 = i3.shift() + a2.nominalWidthX, l2 = true), d2 += i3.pop(), u2 && t3.U.P.closePath(o3), t3.U.P.moveTo(o3, d2, h2), u2 = true;
            else if ("o25" == T2) {
              for (; i3.length > 6; ) d2 += i3.shift(), h2 += i3.shift(), t3.U.P.lineTo(o3, d2, h2);
              v2 = d2 + i3.shift(), p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), b2 = p2 + i3.shift(), d2 = g2 + i3.shift(), h2 = b2 + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, d2, h2);
            } else if ("o26" == T2) for (i3.length % 2 && (d2 += i3.shift()); i3.length > 0; ) v2 = d2, p2 = h2 + i3.shift(), d2 = g2 = v2 + i3.shift(), h2 = (b2 = p2 + i3.shift()) + i3.shift(), t3.U.P.curveTo(o3, v2, p2, g2, b2, d2, h2);
            else if ("o27" == T2) for (i3.length % 2 && (h2 += i3.shift()); i3.length > 0; ) p2 = h2, g2 = (v2 = d2 + i3.shift()) + i3.shift(), b2 = p2 + i3.shift(), d2 = g2 + i3.shift(), h2 = b2, t3.U.P.curveTo(o3, v2, p2, g2, b2, d2, h2);
            else if ("o10" == T2 || "o29" == T2) {
              var R2 = "o10" == T2 ? a2 : n3;
              if (0 == i3.length) console.debug("error: empty stack");
              else {
                var B2 = i3.pop(), G2 = R2.Subrs[B2 + R2.Bias];
                r4.x = d2, r4.y = h2, r4.nStems = s2, r4.haveWidth = l2, r4.width = c2, r4.open = u2, t3.U._drawCFF(G2, r4, n3, a2, o3), d2 = r4.x, h2 = r4.y, s2 = r4.nStems, l2 = r4.haveWidth, c2 = r4.width, u2 = r4.open;
              }
            } else if ("o30" == T2 || "o31" == T2) {
              var N2 = i3.length, z2 = (D2 = 0, "o31" == T2);
              for (D2 += N2 - (_2 = -3 & N2); D2 < _2; ) z2 ? (p2 = h2, g2 = (v2 = d2 + i3.shift()) + i3.shift(), h2 = (b2 = p2 + i3.shift()) + i3.shift(), _2 - D2 == 5 ? (d2 = g2 + i3.shift(), D2++) : d2 = g2, z2 = false) : (v2 = d2, p2 = h2 + i3.shift(), g2 = v2 + i3.shift(), b2 = p2 + i3.shift(), d2 = g2 + i3.shift(), _2 - D2 == 5 ? (h2 = b2 + i3.shift(), D2++) : h2 = b2, z2 = true), t3.U.P.curveTo(o3, v2, p2, g2, b2, d2, h2), D2 += 4;
            } else {
              if ("o" == (T2 + "").charAt(0)) throw console.debug("Unknown operation: " + T2, e3), T2;
              i3.push(T2);
            }
          }
        }
        r4.x = d2, r4.y = h2, r4.nStems = s2, r4.haveWidth = l2, r4.width = c2, r4.open = u2;
      };
      var r3 = t3, n2 = { Typr: r3 };
      return e2.Typr = r3, e2.default = n2, Object.defineProperty(e2, "__esModule", { value: true }), e2;
    }({}).Typr;
  }, function() {
    return function(e2) {
      var t3 = Uint8Array, r3 = Uint16Array, n2 = Uint32Array, a2 = new t3([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o3 = new t3([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), i3 = new t3([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), s2 = function(e3, t4) {
        for (var a3 = new r3(31), o4 = 0; o4 < 31; ++o4) a3[o4] = t4 += 1 << e3[o4 - 1];
        var i4 = new n2(a3[30]);
        for (o4 = 1; o4 < 30; ++o4) for (var s3 = a3[o4]; s3 < a3[o4 + 1]; ++s3) i4[s3] = s3 - a3[o4] << 5 | o4;
        return [a3, i4];
      }, l2 = s2(a2, 2), c2 = l2[0], u2 = l2[1];
      c2[28] = 258, u2[258] = 28;
      for (var f2 = s2(o3, 0)[0], d2 = new r3(32768), h2 = 0; h2 < 32768; ++h2) {
        var v2 = (43690 & h2) >>> 1 | (21845 & h2) << 1;
        v2 = (61680 & (v2 = (52428 & v2) >>> 2 | (13107 & v2) << 2)) >>> 4 | (3855 & v2) << 4, d2[h2] = ((65280 & v2) >>> 8 | (255 & v2) << 8) >>> 1;
      }
      var p2 = function(e3, t4, n3) {
        for (var a3 = e3.length, o4 = 0, i4 = new r3(t4); o4 < a3; ++o4) ++i4[e3[o4] - 1];
        var s3, l3 = new r3(t4);
        for (o4 = 0; o4 < t4; ++o4) l3[o4] = l3[o4 - 1] + i4[o4 - 1] << 1;
        if (n3) {
          s3 = new r3(1 << t4);
          var c3 = 15 - t4;
          for (o4 = 0; o4 < a3; ++o4) if (e3[o4]) for (var u3 = o4 << 4 | e3[o4], f3 = t4 - e3[o4], h3 = l3[e3[o4] - 1]++ << f3, v3 = h3 | (1 << f3) - 1; h3 <= v3; ++h3) s3[d2[h3] >>> c3] = u3;
        } else for (s3 = new r3(a3), o4 = 0; o4 < a3; ++o4) e3[o4] && (s3[o4] = d2[l3[e3[o4] - 1]++] >>> 15 - e3[o4]);
        return s3;
      }, g2 = new t3(288);
      for (h2 = 0; h2 < 144; ++h2) g2[h2] = 8;
      for (h2 = 144; h2 < 256; ++h2) g2[h2] = 9;
      for (h2 = 256; h2 < 280; ++h2) g2[h2] = 7;
      for (h2 = 280; h2 < 288; ++h2) g2[h2] = 8;
      var b2 = new t3(32);
      for (h2 = 0; h2 < 32; ++h2) b2[h2] = 5;
      var y2 = p2(g2, 9, 1), m2 = p2(b2, 5, 1), x2 = function(e3) {
        for (var t4 = e3[0], r4 = 1; r4 < e3.length; ++r4) e3[r4] > t4 && (t4 = e3[r4]);
        return t4;
      }, k2 = function(e3, t4, r4) {
        var n3 = t4 / 8 | 0;
        return (e3[n3] | e3[n3 + 1] << 8) >> (7 & t4) & r4;
      }, w2 = function(e3, t4) {
        var r4 = t4 / 8 | 0;
        return (e3[r4] | e3[r4 + 1] << 8 | e3[r4 + 2] << 16) >> (7 & t4);
      }, S2 = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], U2 = function(e3, t4, r4) {
        var n3 = new Error(t4 || S2[e3]);
        if (n3.code = e3, Error.captureStackTrace && Error.captureStackTrace(n3, U2), !r4) throw n3;
        return n3;
      }, T2 = function(e3, s3, l3) {
        var u3 = e3.length;
        if (!u3 || l3 && !l3.l && u3 < 5) return s3 || new t3(0);
        var d3 = !s3 || l3, h3 = !l3 || l3.i;
        l3 || (l3 = {}), s3 || (s3 = new t3(3 * u3));
        var v3, g3 = function(e4) {
          var r4 = s3.length;
          if (e4 > r4) {
            var n3 = new t3(Math.max(2 * r4, e4));
            n3.set(s3), s3 = n3;
          }
        }, b3 = l3.f || 0, S3 = l3.p || 0, T3 = l3.b || 0, _3 = l3.l, E3 = l3.d, F2 = l3.m, C2 = l3.n, D2 = 8 * u3;
        do {
          if (!_3) {
            l3.f = b3 = k2(e3, S3, 1);
            var A2 = k2(e3, S3 + 1, 3);
            if (S3 += 3, !A2) {
              var M2 = e3[(j2 = ((v3 = S3) / 8 | 0) + (7 & v3 && 1) + 4) - 4] | e3[j2 - 3] << 8, P2 = j2 + M2;
              if (P2 > u3) {
                h3 && U2(0);
                break;
              }
              d3 && g3(T3 + M2), s3.set(e3.subarray(j2, P2), T3), l3.b = T3 += M2, l3.p = S3 = 8 * P2;
              continue;
            }
            if (1 == A2) _3 = y2, E3 = m2, F2 = 9, C2 = 5;
            else if (2 == A2) {
              var I2 = k2(e3, S3, 31) + 257, L2 = k2(e3, S3 + 10, 15) + 4, O2 = I2 + k2(e3, S3 + 5, 31) + 1;
              S3 += 14;
              for (var R2 = new t3(O2), B2 = new t3(19), G2 = 0; G2 < L2; ++G2) B2[i3[G2]] = k2(e3, S3 + 3 * G2, 7);
              S3 += 3 * L2;
              var N2 = x2(B2), z2 = (1 << N2) - 1, V2 = p2(B2, N2, 1);
              for (G2 = 0; G2 < O2; ) {
                var j2, W2 = V2[k2(e3, S3, z2)];
                if (S3 += 15 & W2, (j2 = W2 >>> 4) < 16) R2[G2++] = j2;
                else {
                  var H2 = 0, X2 = 0;
                  for (16 == j2 ? (X2 = 3 + k2(e3, S3, 3), S3 += 2, H2 = R2[G2 - 1]) : 17 == j2 ? (X2 = 3 + k2(e3, S3, 7), S3 += 3) : 18 == j2 && (X2 = 11 + k2(e3, S3, 127), S3 += 7); X2--; ) R2[G2++] = H2;
                }
              }
              var q2 = R2.subarray(0, I2), Y2 = R2.subarray(I2);
              F2 = x2(q2), C2 = x2(Y2), _3 = p2(q2, F2, 1), E3 = p2(Y2, C2, 1);
            } else U2(1);
            if (S3 > D2) {
              h3 && U2(0);
              break;
            }
          }
          d3 && g3(T3 + 131072);
          for (var $2 = (1 << F2) - 1, Z2 = (1 << C2) - 1, K2 = S3; ; K2 = S3) {
            var Q2 = (H2 = _3[w2(e3, S3) & $2]) >>> 4;
            if ((S3 += 15 & H2) > D2) {
              h3 && U2(0);
              break;
            }
            if (H2 || U2(2), Q2 < 256) s3[T3++] = Q2;
            else {
              if (256 == Q2) {
                K2 = S3, _3 = null;
                break;
              }
              var J2 = Q2 - 254;
              if (Q2 > 264) {
                var ee2 = a2[G2 = Q2 - 257];
                J2 = k2(e3, S3, (1 << ee2) - 1) + c2[G2], S3 += ee2;
              }
              var te2 = E3[w2(e3, S3) & Z2], re2 = te2 >>> 4;
              if (te2 || U2(3), S3 += 15 & te2, Y2 = f2[re2], re2 > 3 && (ee2 = o3[re2], Y2 += w2(e3, S3) & (1 << ee2) - 1, S3 += ee2), S3 > D2) {
                h3 && U2(0);
                break;
              }
              d3 && g3(T3 + 131072);
              for (var ne2 = T3 + J2; T3 < ne2; T3 += 4) s3[T3] = s3[T3 - Y2], s3[T3 + 1] = s3[T3 + 1 - Y2], s3[T3 + 2] = s3[T3 + 2 - Y2], s3[T3 + 3] = s3[T3 + 3 - Y2];
              T3 = ne2;
            }
          }
          l3.l = _3, l3.p = K2, l3.b = T3, _3 && (b3 = 1, l3.m = F2, l3.d = E3, l3.n = C2);
        } while (!b3);
        return T3 == s3.length ? s3 : function(e4, a3, o4) {
          (null == a3 || a3 < 0) && (a3 = 0), (null == o4 || o4 > e4.length) && (o4 = e4.length);
          var i4 = new (e4 instanceof r3 ? r3 : e4 instanceof n2 ? n2 : t3)(o4 - a3);
          return i4.set(e4.subarray(a3, o4)), i4;
        }(s3, 0, T3);
      }, _2 = new t3(0), E2 = "undefined" != typeof TextDecoder && new TextDecoder();
      try {
        E2.decode(_2, { stream: true });
      } catch (e3) {
      }
      return e2.convert_streams = function(e3) {
        var t4 = new DataView(e3), r4 = 0;
        function n3() {
          var e4 = t4.getUint16(r4);
          return r4 += 2, e4;
        }
        function a3() {
          var e4 = t4.getUint32(r4);
          return r4 += 4, e4;
        }
        function o4(e4) {
          b3.setUint16(y3, e4), y3 += 2;
        }
        function i4(e4) {
          b3.setUint32(y3, e4), y3 += 4;
        }
        for (var s3 = { signature: a3(), flavor: a3(), length: a3(), numTables: n3(), reserved: n3(), totalSfntSize: a3(), majorVersion: n3(), minorVersion: n3(), metaOffset: a3(), metaLength: a3(), metaOrigLength: a3(), privOffset: a3(), privLength: a3() }, l3 = 0; Math.pow(2, l3) <= s3.numTables; ) l3++;
        l3--;
        for (var c3 = 16 * Math.pow(2, l3), u3 = 16 * s3.numTables - c3, f3 = 12, d3 = [], h3 = 0; h3 < s3.numTables; h3++) d3.push({ tag: a3(), offset: a3(), compLength: a3(), origLength: a3(), origChecksum: a3() }), f3 += 16;
        var v3, p3 = new Uint8Array(12 + 16 * d3.length + d3.reduce(function(e4, t5) {
          return e4 + t5.origLength + 4;
        }, 0)), g3 = p3.buffer, b3 = new DataView(g3), y3 = 0;
        return i4(s3.flavor), o4(s3.numTables), o4(c3), o4(l3), o4(u3), d3.forEach(function(e4) {
          i4(e4.tag), i4(e4.origChecksum), i4(f3), i4(e4.origLength), e4.outOffset = f3, (f3 += e4.origLength) % 4 != 0 && (f3 += 4 - f3 % 4);
        }), d3.forEach(function(t5) {
          var r5, n4 = e3.slice(t5.offset, t5.offset + t5.compLength);
          if (t5.compLength != t5.origLength) {
            var a4 = new Uint8Array(t5.origLength);
            r5 = new Uint8Array(n4, 2), T2(r5, a4);
          } else a4 = new Uint8Array(n4);
          p3.set(a4, t5.outOffset);
          var o5 = 0;
          (f3 = t5.outOffset + t5.origLength) % 4 != 0 && (o5 = 4 - f3 % 4), p3.set(new Uint8Array(o5).buffer, t5.outOffset + t5.origLength), v3 = f3 + o5;
        }), g3.slice(0, v3);
      }, Object.defineProperty(e2, "__esModule", { value: true }), e2;
    }({}).convert_streams;
  }, function(e2, t3) {
    const r3 = { M: 2, L: 2, Q: 4, C: 6, Z: 0 }, n2 = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, a2 = 1, o3 = 2, i3 = 4, s2 = 8, l2 = 16, c2 = 32;
    let u2;
    function f2(e3) {
      if (!u2) {
        const e4 = { R: o3, L: a2, D: i3, C: l2, U: c2, T: s2 };
        u2 = /* @__PURE__ */ new Map();
        for (let t4 in n2) {
          let r4 = 0;
          n2[t4].split(",").forEach((n3) => {
            let [a3, o4] = n3.split("+");
            a3 = parseInt(a3, 36), o4 = o4 ? parseInt(o4, 36) : 0, u2.set(r4 += a3, e4[t4]);
            for (let n4 = o4; n4--; ) u2.set(++r4, e4[t4]);
          });
        }
      }
      return u2.get(e3) || c2;
    }
    const d2 = 1, h2 = 2, v2 = 3, p2 = 4, g2 = [null, "isol", "init", "fina", "medi"];
    function b2(e3) {
      const t4 = new Uint8Array(e3.length);
      let r4 = c2, n3 = d2, u3 = -1;
      for (let g3 = 0; g3 < e3.length; g3++) {
        const b3 = e3.codePointAt(g3);
        let y3 = 0 | f2(b3), m2 = d2;
        y3 & s2 || (r4 & (a2 | i3 | l2) ? y3 & (o3 | i3 | l2) ? (m2 = v2, n3 !== d2 && n3 !== v2 || t4[u3]++) : y3 & (a2 | c2) && (n3 !== h2 && n3 !== p2 || t4[u3]--) : r4 & (o3 | c2) && (n3 !== h2 && n3 !== p2 || t4[u3]--), n3 = t4[g3] = m2, r4 = y3, u3 = g3, b3 > 65535 && g3++);
      }
      return t4;
    }
    function y2(...e3) {
      for (let t4 = 0; t4 < e3.length; t4++) if ("number" == typeof e3[t4]) return e3[t4];
    }
    return function(n3) {
      const a3 = new Uint8Array(n3, 0, 4), o4 = e2._bin.readASCII(a3, 0, 4);
      if ("wOFF" === o4) n3 = t3(n3);
      else if ("wOF2" === o4) throw new Error("woff2 fonts not supported");
      return function(t4) {
        const n4 = /* @__PURE__ */ Object.create(null), a4 = t4["OS/2"], o5 = t4.hhea, i4 = t4.head.unitsPerEm, s3 = y2(a4 && a4.sTypoAscender, o5 && o5.ascender, i4), l3 = { unitsPerEm: i4, ascender: s3, descender: y2(a4 && a4.sTypoDescender, o5 && o5.descender, 0), capHeight: y2(a4 && a4.sCapHeight, s3), xHeight: y2(a4 && a4.sxHeight, s3), lineGap: y2(a4 && a4.sTypoLineGap, o5 && o5.lineGap), supportsCodePoint: (r4) => e2.U.codeToGlyph(t4, r4) > 0, forEachGlyph(a5, o6, i5, s4) {
          let c3 = 0;
          const u3 = 1 / l3.unitsPerEm * o6, f3 = function(t5, r4) {
            const n5 = [];
            for (let a7 = 0; a7 < r4.length; a7++) {
              const o7 = r4.codePointAt(a7);
              o7 > 65535 && a7++, n5.push(e2.U.codeToGlyph(t5, o7));
            }
            const a6 = t5.GSUB;
            if (a6) {
              const { lookupList: t6, featureList: o7 } = a6;
              let i6;
              const s5 = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, l4 = [];
              o7.forEach((a7) => {
                if (s5.test(a7.tag)) for (let o8 = 0; o8 < a7.tab.length; o8++) {
                  if (l4[a7.tab[o8]]) continue;
                  l4[a7.tab[o8]] = true;
                  const s6 = t6[a7.tab[o8]], c4 = /^(isol|init|fina|medi)$/.test(a7.tag);
                  c4 && !i6 && (i6 = b2(r4));
                  for (let r5 = 0; r5 < n5.length; r5++) i6 && c4 && g2[i6[r5]] !== a7.tag || e2.U._applySubs(n5, r5, s6, t6);
                }
              });
            }
            return n5;
          }(t4, a5);
          let d3 = 0, h3 = -1;
          return f3.forEach((l4, f4) => {
            if (-1 !== l4) {
              let a6 = n4[l4];
              if (!a6) {
                const { cmds: o7, crds: i6 } = e2.U.glyphToPath(t4, l4);
                let s5, c4, u4, f5, d4 = "", h4 = 0;
                for (let e3 = 0, t5 = o7.length; e3 < t5; e3++) {
                  const t6 = r3[o7[e3]];
                  d4 += o7[e3];
                  for (let e4 = 1; e4 <= t6; e4++) d4 += (e4 > 1 ? "," : "") + i6[h4++];
                }
                if (i6.length) {
                  s5 = c4 = 1 / 0, u4 = f5 = -1 / 0;
                  for (let e3 = 0, t5 = i6.length; e3 < t5; e3 += 2) {
                    let t6 = i6[e3], r4 = i6[e3 + 1];
                    t6 < s5 && (s5 = t6), r4 < c4 && (c4 = r4), t6 > u4 && (u4 = t6), r4 > f5 && (f5 = r4);
                  }
                } else s5 = u4 = c4 = f5 = 0;
                a6 = n4[l4] = { index: l4, advanceWidth: t4.hmtx.aWidth[l4], xMin: s5, yMin: c4, xMax: u4, yMax: f5, path: d4, pathCommandCount: o7.length };
              }
              -1 !== h3 && (c3 += e2.U.getPairAdjustment(t4, h3, l4) * u3), s4.call(null, a6, c3, d3), a6.advanceWidth && (c3 += a6.advanceWidth * u3), i5 && (c3 += i5 * o6), h3 = l4;
            }
            d3 += a5.codePointAt(d3) > 65535 ? 2 : 1;
          }), c3;
        } };
        return l3;
      }(e2.parse(n3)[0]);
    };
  }], init: (e2, t3, r3) => r3(e2(), t3()) }), C = f({ name: "FontResolver", dependencies: [function(e2, t3) {
    const r3 = /* @__PURE__ */ Object.create(null), n2 = /* @__PURE__ */ Object.create(null);
    function a2(t4, a3) {
      let o3 = r3[t4];
      o3 ? a3(o3) : n2[t4] ? n2[t4].push(a3) : (n2[t4] = [a3], function(a4, o4) {
        const i3 = (e3) => {
          console.error(`Failure loading font ${a4}`, e3);
        };
        try {
          const o5 = new XMLHttpRequest();
          o5.open("get", a4, true), o5.responseType = "arraybuffer", o5.onload = function() {
            if (o5.status >= 400) i3(new Error(o5.statusText));
            else if (o5.status > 0) try {
              const i4 = e2(o5.response);
              i4.src = a4, ((e3) => {
                e3.src = t4, r3[t4] = e3, n2[t4].forEach((t5) => t5(e3)), delete n2[t4];
              })(i4);
            } catch (e3) {
              i3(e3);
            }
          }, o5.onerror = i3, o5.send();
        } catch (e3) {
          i3(e3);
        }
      }(t4));
    }
    return function(e3, n3, { lang: o3, fonts: i3 = [], style: s2 = "normal", weight: l2 = "normal", unicodeFontsURL: c2 } = {}) {
      const u2 = new Uint8Array(e3.length), f2 = [];
      e3.length || p2();
      const d2 = /* @__PURE__ */ new Map(), h2 = [];
      if ("italic" !== s2 && (s2 = "normal"), "number" != typeof l2 && (l2 = "bold" === l2 ? 700 : 400), i3 && !Array.isArray(i3) && (i3 = [i3]), (i3 = i3.slice().filter((e4) => !e4.lang || e4.lang.test(o3)).reverse()).length) {
        const t4 = 1, n4 = 2;
        let o4 = 0;
        !function s3(l3 = 0) {
          for (let c3 = l3, v3 = e3.length; c3 < v3; c3++) {
            const l4 = e3.codePointAt(c3);
            if (o4 === t4 && f2[u2[c3 - 1]].supportsCodePoint(l4) || /\s/.test(e3[c3])) u2[c3] = u2[c3 - 1], o4 === n4 && (h2[h2.length - 1][1] = c3);
            else for (let e4 = u2[c3], v4 = i3.length; e4 <= v4; e4++) if (e4 === v4) (o4 === n4 ? h2[h2.length - 1] : h2[h2.length] = [c3, c3])[1] = c3, o4 = n4;
            else {
              u2[c3] = e4;
              const { src: n5, unicodeRange: h3 } = i3[e4];
              if (!h3 || g2(l4, h3)) {
                const e5 = r3[n5];
                if (!e5) return void a2(n5, () => {
                  s3(c3);
                });
                if (e5.supportsCodePoint(l4)) {
                  let r4 = d2.get(e5);
                  "number" != typeof r4 && (r4 = f2.length, f2.push(e5), d2.set(e5, r4)), u2[c3] = r4, o4 = t4;
                  break;
                }
              }
            }
            l4 > 65535 && c3 + 1 < v3 && (u2[c3 + 1] = u2[c3], c3++, o4 === n4 && (h2[h2.length - 1][1] = c3));
          }
          v2();
        }();
      } else h2.push([0, e3.length - 1]), v2();
      function v2() {
        if (h2.length) {
          const r4 = h2.map((t4) => e3.substring(t4[0], t4[1] + 1)).join("\n");
          t3.getFontsForString(r4, { lang: o3 || void 0, style: s2, weight: l2, dataUrl: c2 }).then(({ fontUrls: e4, chars: t4 }) => {
            const r5 = f2.length;
            let n4 = 0;
            h2.forEach((e5) => {
              for (let a3 = 0, o5 = e5[1] - e5[0]; a3 <= o5; a3++) u2[e5[0] + a3] = t4[n4++] + r5;
              n4++;
            });
            let o4 = 0;
            e4.forEach((t5, n5) => {
              a2(t5, (t6) => {
                f2[n5 + r5] = t6, ++o4 === e4.length && p2();
              });
            });
          });
        } else p2();
      }
      function p2() {
        n3({ chars: u2, fonts: f2 });
      }
      function g2(e4, t4) {
        for (let r4 = 0; r4 < t4.length; r4++) {
          const [n4, a3 = n4] = t4[r4];
          if (n4 <= e4 && e4 <= a3) return true;
        }
        return false;
      }
    };
  }, F, function() {
    return function(e2) {
      var t3 = function() {
        this.buckets = /* @__PURE__ */ new Map();
      };
      t3.prototype.add = function(e3) {
        var t4 = e3 >> 5;
        this.buckets.set(t4, (this.buckets.get(t4) || 0) | 1 << (31 & e3));
      }, t3.prototype.has = function(e3) {
        var t4 = this.buckets.get(e3 >> 5);
        return void 0 !== t4 && 0 != (t4 & 1 << (31 & e3));
      }, t3.prototype.serialize = function() {
        var e3 = [];
        return this.buckets.forEach(function(t4, r4) {
          e3.push((+r4).toString(36) + ":" + t4.toString(36));
        }), e3.join(",");
      }, t3.prototype.deserialize = function(e3) {
        var t4 = this;
        this.buckets.clear(), e3.split(",").forEach(function(e4) {
          var r4 = e4.split(":");
          t4.buckets.set(parseInt(r4[0], 36), parseInt(r4[1], 36));
        });
      };
      var r3 = Math.pow(2, 8), n2 = r3 - 1, a2 = ~n2;
      function o3(e3) {
        var t4 = function(e4) {
          return e4 & a2;
        }(e3).toString(16), n3 = function(e4) {
          return (e4 & a2) + r3 - 1;
        }(e3).toString(16);
        return "codepoint-index/plane" + (e3 >> 16) + "/" + t4 + "-" + n3 + ".json";
      }
      function i3(e3, t4) {
        var r4 = e3 & n2, a3 = t4.codePointAt(r4 / 6 | 0);
        return 0 != ((a3 = (a3 || 48) - 48) & 1 << r4 % 6);
      }
      function s2(e3, t4) {
        !function(e4, t5) {
          var r4;
          (r4 = e4, r4.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(e5) {
            return e5.split("-").map(function(e6) {
              return parseInt(e6.trim(), 16);
            });
          })).forEach(function(e5) {
            var r5 = e5[0], n3 = e5[1];
            void 0 === n3 && (n3 = r5), t5(r5, n3);
          });
        }(e3, function(e4, r4) {
          for (var n3 = e4; n3 <= r4; n3++) t4(n3);
        });
      }
      var l2 = {}, c2 = {}, u2 = /* @__PURE__ */ new WeakMap(), f2 = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
      function d2(e3) {
        var r4 = u2.get(e3);
        return r4 || (r4 = new t3(), s2(e3.ranges, function(e4) {
          return r4.add(e4);
        }), u2.set(e3, r4)), r4;
      }
      var h2, v2 = /* @__PURE__ */ new Map();
      function p2(e3, t4, r4) {
        return e3[t4] ? t4 : e3[r4] ? r4 : function(e4) {
          for (var t5 in e4) return t5;
        }(e3);
      }
      function g2(e3, t4) {
        var r4 = t4;
        if (!e3.includes(r4)) {
          r4 = 1 / 0;
          for (var n3 = 0; n3 < e3.length; n3++) Math.abs(e3[n3] - t4) < Math.abs(r4 - t4) && (r4 = e3[n3]);
        }
        return r4;
      }
      function b2(e3) {
        return h2 || (h2 = /* @__PURE__ */ new Set(), s2("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(e4) {
          h2.add(e4);
        })), h2.has(e3);
      }
      return e2.CodePointSet = t3, e2.clearCache = function() {
        l2 = {}, c2 = {};
      }, e2.getFontsForString = function(e3, t4) {
        void 0 === t4 && (t4 = {});
        var r4, n3 = t4.lang;
        void 0 === n3 && (n3 = new RegExp("\\p{Script=Hangul}", "u").test(r4 = e3) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(r4) ? "ja" : "en");
        var a3 = t4.category;
        void 0 === a3 && (a3 = "sans-serif");
        var s3 = t4.style;
        void 0 === s3 && (s3 = "normal");
        var u3 = t4.weight;
        void 0 === u3 && (u3 = 400);
        var h3 = (t4.dataUrl || f2).replace(/\/$/g, ""), y2 = /* @__PURE__ */ new Map(), m2 = new Uint8Array(e3.length), x2 = {}, k2 = {}, w2 = new Array(e3.length), S2 = /* @__PURE__ */ new Map(), U2 = false;
        function T2(e4) {
          var t5 = v2.get(e4);
          return t5 || (t5 = fetch(h3 + "/" + e4).then(function(e5) {
            if (!e5.ok) throw new Error(e5.statusText);
            return e5.json().then(function(e6) {
              if (!Array.isArray(e6) || 1 !== e6[0]) throw new Error("Incorrect schema version; need 1, got " + e6[0]);
              return e6[1];
            });
          }).catch(function(t6) {
            if (h3 !== f2) return U2 || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + h3 + '", trying default CDN. ' + t6.message), U2 = true), h3 = f2, v2.delete(e4), T2(e4);
            throw t6;
          }), v2.set(e4, t5)), t5;
        }
        for (var _2 = function(t5) {
          var r5 = e3.codePointAt(t5), n4 = o3(r5);
          w2[t5] = n4, l2[n4] || S2.has(n4) || S2.set(n4, T2(n4).then(function(e4) {
            l2[n4] = e4;
          })), r5 > 65535 && (t5++, E2 = t5);
        }, E2 = 0; E2 < e3.length; E2++) _2(E2);
        return Promise.all(S2.values()).then(function() {
          S2.clear();
          for (var t5 = function(t6) {
            var a4 = e3.codePointAt(t6), o4 = null, s4 = l2[w2[t6]], u4 = void 0;
            for (var f3 in s4) {
              var d3 = k2[f3];
              if (void 0 === d3 && (d3 = k2[f3] = new RegExp(f3).test(n3 || "en")), d3) {
                for (var h4 in u4 = f3, s4[f3]) if (i3(a4, s4[f3][h4])) {
                  o4 = h4;
                  break;
                }
                break;
              }
            }
            if (!o4) {
              e: for (var v3 in s4) if (v3 !== u4) {
                for (var p3 in s4[v3]) if (i3(a4, s4[v3][p3])) {
                  o4 = p3;
                  break e;
                }
              }
            }
            o4 || (console.debug("No font coverage for U+" + a4.toString(16)), o4 = "latin"), w2[t6] = o4, c2[o4] || S2.has(o4) || S2.set(o4, T2("font-meta/" + o4 + ".json").then(function(e4) {
              c2[o4] = e4;
            })), a4 > 65535 && (t6++, r5 = t6);
          }, r5 = 0; r5 < e3.length; r5++) t5(r5);
          return Promise.all(S2.values());
        }).then(function() {
          for (var t5, r5 = null, n4 = 0; n4 < e3.length; n4++) {
            var o4 = e3.codePointAt(n4);
            if (r5 && (b2(o4) || d2(r5).has(o4))) m2[n4] = m2[n4 - 1];
            else {
              r5 = c2[w2[n4]];
              var i4 = x2[r5.id];
              if (!i4) {
                var l3 = r5.typeforms, f3 = p2(l3, a3, "sans-serif"), v3 = p2(l3[f3], s3, "normal"), k3 = g2(null === (t5 = l3[f3]) || void 0 === t5 ? void 0 : t5[v3], u3);
                i4 = x2[r5.id] = h3 + "/font-files/" + r5.id + "/" + f3 + "." + v3 + "." + k3 + ".woff";
              }
              var S3 = y2.get(i4);
              null == S3 && (S3 = y2.size, y2.set(i4, S3)), m2[n4] = S3;
            }
            o4 > 65535 && (n4++, m2[n4] = m2[n4 - 1]);
          }
          return { fontUrls: Array.from(y2.keys()), chars: m2 };
        });
      }, Object.defineProperty(e2, "__esModule", { value: true }), e2;
    }({});
  }], init: (e2, t3, r3) => e2(t3, r3()) }), D = () => (self.performance || Date).now(), A = v();
  let M;
  const P = [];
  let I = 0;
  function L() {
    const e2 = D();
    for (; P.length && D() - e2 < 5; ) P.shift()();
    I = P.length ? setTimeout(L, 0) : 0;
  }
  const O = (...e2) => new Promise((t3, r3) => {
    P.push(() => {
      const n2 = D();
      try {
        A.webgl.generateIntoCanvas(...e2), t3({ timing: D() - n2 });
      } catch (e3) {
        r3(e3);
      }
    }), I || (I = setTimeout(L, 0));
  }), R = 4, B = 2e3, G = {};
  let N = 0;
  function z(e2, t3, r3, n2, a2, o3, i3, s2, u2, d2) {
    const h2 = "TroikaTextSDFGenerator_JS_" + N++ % R;
    let p2 = G[h2];
    return p2 || (p2 = G[h2] = { workerModule: f({ name: h2, workerId: h2, dependencies: [v, D], init(e3, t4) {
      const r4 = e3().javascript.generate;
      return function(...e4) {
        const n3 = t4();
        return { textureData: r4(...e4), timing: t4() - n3 };
      };
    }, getTransferables: (e3) => [e3.textureData.buffer] }), requests: 0, idleTimer: null }), p2.requests++, clearTimeout(p2.idleTimer), p2.workerModule(e2, t3, r3, n2, a2, o3).then(({ textureData: r4, timing: n3 }) => {
      const a3 = D(), o4 = new Uint8Array(4 * r4.length);
      for (let e3 = 0; e3 < r4.length; e3++) o4[4 * e3 + d2] = r4[e3];
      return A.webglUtils.renderImageData(i3, o4, s2, u2, e2, t3, 1 << 3 - d2), n3 += D() - a3, 0 == --p2.requests && (p2.idleTimer = setTimeout(() => {
        !function(e3) {
          c[e3] && c[e3].forEach(function(e4) {
            e4();
          }), l[e3] && (l[e3].terminate(), delete l[e3]);
        }(h2);
      }, B)), { timing: n3 };
    });
  }
  const V = A.webglUtils.resizeWebGLCanvasWithoutClearing, j = { defaultFontURL: null, unicodeFontsURL: null, sdfGlyphSize: 64, sdfMargin: 1 / 16, sdfExponent: 9, textureWidth: 2048 }, W = new e.Color();
  let H = false;
  function X() {
    return (self.performance || Date).now();
  }
  const q = /* @__PURE__ */ Object.create(null);
  function Y({ path: e2, atlasIndex: t3, sdfViewBox: r3 }, { sdfGlyphSize: n2, sdfCanvas: a2, contextLost: o3 }, i3) {
    if (o3) return Promise.resolve({ timing: -1 });
    const { textureWidth: s2, sdfExponent: l2 } = j, c2 = Math.max(r3[2] - r3[0], r3[3] - r3[1]), u2 = Math.floor(t3 / 4);
    return function(e3, t4, r4, n3, a3, o4, i4, s3, l3, c3, u3 = true) {
      return u3 ? O(e3, t4, r4, n3, a3, o4, i4, s3, l3, c3).then(null, (u4) => (M || (console.warn("WebGL SDF generation failed, falling back to JS", u4), M = true), z(e3, t4, r4, n3, a3, o4, i4, s3, l3, c3))) : z(e3, t4, r4, n3, a3, o4, i4, s3, l3, c3);
    }(n2, n2, e2, r3, c2, l2, a2, u2 % (s2 / n2) * n2, Math.floor(u2 / (s2 / n2)) * n2, t3 % 4, i3);
  }
  let $;
  function Z(e2) {
    return $ || ($ = "undefined" == typeof document ? {} : document.createElement("a")), $.href = e2, $.href;
  }
  function K(e2) {
    if ("function" != typeof createImageBitmap) {
      console.info("Safari<15: applying SDF canvas workaround");
      const { sdfCanvas: t3, sdfTexture: r3 } = e2, { width: n2, height: a2 } = t3, o3 = e2.sdfCanvas.getContext("webgl");
      let i3 = r3.image.data;
      i3 && i3.length === n2 * a2 * 4 || (i3 = new Uint8Array(n2 * a2 * 4), r3.image = { width: n2, height: a2, data: i3 }, r3.flipY = false, r3.isDataTexture = true), o3.readPixels(0, 0, n2, a2, o3.RGBA, o3.UNSIGNED_BYTE, i3);
    }
  }
  const Q = f({ name: "Typesetter", dependencies: [function(e2, t3) {
    const r3 = 1 / 0, n2 = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, a2 = "[^\\S\\u00A0]", o3 = new RegExp(`${a2}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
    function i3({ text: i4 = "", font: f3, lang: d2, sdfGlyphSize: h2 = 64, fontSize: v2 = 400, fontWeight: p2 = 1, fontStyle: g2 = "normal", letterSpacing: b2 = 0, lineHeight: y2 = "normal", maxWidth: m2 = r3, direction: x2, textAlign: k2 = "left", textIndent: w2 = 0, whiteSpace: S2 = "normal", overflowWrap: U2 = "normal", anchorX: T2 = 0, anchorY: _2 = 0, metricsOnly: E2 = false, unicodeFontsURL: F2, preResolvedFonts: C2 = null, includeCaretPositions: D2 = false, chunkedBoundsSize: A2 = 8192, colorRanges: M2 = null }, P2) {
      const I2 = c2(), L2 = { fontLoad: 0, typesetting: 0 };
      i4.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), i4 = i4.replace(/\r\n/g, "\n").replace(/\r/g, "\n")), v2 = +v2, b2 = +b2, m2 = +m2, y2 = y2 || "normal", w2 = +w2, function({ text: t4, lang: r4, fonts: n3, style: a3, weight: o4, preResolvedFonts: i5, unicodeFontsURL: s3 }, l3) {
        const c3 = ({ chars: e3, fonts: t5 }) => {
          let r5, n4;
          const a4 = [];
          for (let o5 = 0; o5 < e3.length; o5++) e3[o5] !== n4 ? (n4 = e3[o5], a4.push(r5 = { start: o5, end: o5, fontObj: t5[e3[o5]] })) : r5.end = o5;
          l3(a4);
        };
        i5 ? c3(i5) : e2(t4, c3, { lang: r4, fonts: n3, style: a3, weight: o4, unicodeFontsURL: s3 });
      }({ text: i4, lang: d2, style: g2, weight: p2, fonts: "string" == typeof f3 ? [{ src: f3 }] : f3, unicodeFontsURL: F2, preResolvedFonts: C2 }, (e3) => {
        L2.fontLoad = c2() - I2;
        const f4 = isFinite(m2);
        let d3 = null, h3 = null, p3 = null, g3 = null, F3 = null, C3 = null, O2 = null, R2 = null, B2 = 0, G2 = 0, N2 = "nowrap" !== S2;
        const z2 = /* @__PURE__ */ new Map(), V2 = c2();
        let j2 = w2, W2 = 0, H2 = new u2();
        const X2 = [H2];
        e3.forEach((e4) => {
          const { fontObj: t4 } = e4, { ascender: r4, descender: s3, unitsPerEm: l3, lineGap: c3, capHeight: d4, xHeight: h4 } = t4;
          let p4 = z2.get(t4);
          if (!p4) {
            const e5 = v2 / l3, n3 = "normal" === y2 ? (r4 - s3 + c3) * e5 : y2 * v2, a3 = (n3 - (r4 - s3) * e5) / 2, o4 = Math.min(n3, (r4 - s3) * e5), i5 = (r4 + s3) / 2 * e5 + o4 / 2;
            p4 = { index: z2.size, src: t4.src, fontObj: t4, fontSizeMult: e5, unitsPerEm: l3, ascender: r4 * e5, descender: s3 * e5, capHeight: d4 * e5, xHeight: h4 * e5, lineHeight: n3, baseline: -a3 - r4 * e5, caretTop: (r4 + s3) / 2 * e5 + o4 / 2, caretBottom: i5 - o4 }, z2.set(t4, p4);
          }
          const { fontSizeMult: g4 } = p4, x3 = i4.slice(e4.start, e4.end + 1);
          let k3, S3;
          t4.forEachGlyph(x3, v2, b2, (t5, r5, s4) => {
            r5 += W2, s4 += e4.start, k3 = r5, S3 = t5;
            const l4 = i4.charAt(s4), c4 = t5.advanceWidth * g4, d5 = H2.count;
            let h5;
            if ("isEmpty" in t5 || (t5.isWhitespace = !!l4 && new RegExp(a2).test(l4), t5.canBreakAfter = !!l4 && o3.test(l4), t5.isEmpty = t5.xMin === t5.xMax || t5.yMin === t5.yMax || n2.test(l4)), t5.isWhitespace || t5.isEmpty || G2++, N2 && f4 && !t5.isWhitespace && r5 + c4 + j2 > m2 && d5) {
              if (H2.glyphAt(d5 - 1).glyphObj.canBreakAfter) h5 = new u2(), j2 = -r5;
              else for (let e5 = d5; e5--; ) {
                if (0 === e5 && "break-word" === U2) {
                  h5 = new u2(), j2 = -r5;
                  break;
                }
                if (H2.glyphAt(e5).glyphObj.canBreakAfter) {
                  h5 = H2.splitAt(e5 + 1);
                  const t6 = h5.glyphAt(0).x;
                  j2 -= t6;
                  for (let e6 = h5.count; e6--; ) h5.glyphAt(e6).x -= t6;
                  break;
                }
              }
              h5 && (H2.isSoftWrapped = true, H2 = h5, X2.push(H2), B2 = m2);
            }
            let y3 = H2.glyphAt(H2.count);
            y3.glyphObj = t5, y3.x = r5 + j2, y3.width = c4, y3.charIndex = s4, y3.fontData = p4, "\n" === l4 && (H2 = new u2(), X2.push(H2), j2 = -(r5 + c4 + b2 * v2) + w2);
          }), W2 = k3 + S3.advanceWidth * g4 + b2 * v2;
        });
        let q2 = 0;
        X2.forEach((e4) => {
          let t4 = true;
          for (let r4 = e4.count; r4--; ) {
            const n3 = e4.glyphAt(r4);
            t4 && !n3.glyphObj.isWhitespace && (e4.width = n3.x + n3.width, e4.width > B2 && (B2 = e4.width), t4 = false);
            let { lineHeight: a3, capHeight: o4, xHeight: i5, baseline: s3 } = n3.fontData;
            a3 > e4.lineHeight && (e4.lineHeight = a3);
            const l3 = s3 - e4.baseline;
            l3 < 0 && (e4.baseline += l3, e4.cap += l3, e4.ex += l3), e4.cap = Math.max(e4.cap, e4.baseline + o4), e4.ex = Math.max(e4.ex, e4.baseline + i5);
          }
          e4.baseline -= q2, e4.cap -= q2, e4.ex -= q2, q2 += e4.lineHeight;
        });
        let Y2 = 0, $2 = 0;
        if (T2 && ("number" == typeof T2 ? Y2 = -T2 : "string" == typeof T2 && (Y2 = -B2 * ("left" === T2 ? 0 : "center" === T2 ? 0.5 : "right" === T2 ? 1 : s2(T2)))), _2 && ("number" == typeof _2 ? $2 = -_2 : "string" == typeof _2 && ($2 = "top" === _2 ? 0 : "top-baseline" === _2 ? -X2[0].baseline : "top-cap" === _2 ? -X2[0].cap : "top-ex" === _2 ? -X2[0].ex : "middle" === _2 ? q2 / 2 : "bottom" === _2 ? q2 : "bottom-baseline" === _2 ? X2[X2.length - 1].baseline : s2(_2) * q2)), !E2) {
          const e4 = t3.getEmbeddingLevels(i4, x2);
          d3 = new Uint16Array(G2), h3 = new Uint8Array(G2), p3 = new Float32Array(2 * G2), g3 = {}, O2 = [r3, r3, -1 / 0, -1 / 0], R2 = [], D2 && (C3 = new Float32Array(4 * i4.length)), M2 && (F3 = new Uint8Array(3 * G2));
          let n3, a3, o4 = 0, s3 = -1, c3 = -1;
          if (X2.forEach((u3, f5) => {
            let { count: v3, width: b3 } = u3;
            if (v3 > 0) {
              let f6 = 0;
              for (let e5 = v3; e5-- && u3.glyphAt(e5).glyphObj.isWhitespace; ) f6++;
              let y3 = 0, m3 = 0;
              if ("center" === k2) y3 = (B2 - b3) / 2;
              else if ("right" === k2) y3 = B2 - b3;
              else if ("justify" === k2 && u3.isSoftWrapped) {
                let e5 = 0;
                for (let t4 = v3 - f6; t4--; ) u3.glyphAt(t4).glyphObj.isWhitespace && e5++;
                m3 = (B2 - b3) / e5;
              }
              if (m3 || y3) {
                let e5 = 0;
                for (let t4 = 0; t4 < v3; t4++) {
                  let r4 = u3.glyphAt(t4);
                  const n4 = r4.glyphObj;
                  r4.x += y3 + e5, 0 !== m3 && n4.isWhitespace && t4 < v3 - f6 && (e5 += m3, r4.width += m3);
                }
              }
              const x3 = t3.getReorderSegments(i4, e4, u3.glyphAt(0).charIndex, u3.glyphAt(u3.count - 1).charIndex);
              for (let e5 = 0; e5 < x3.length; e5++) {
                const [t4, r4] = x3[e5];
                let n4 = 1 / 0, a4 = -1 / 0;
                for (let e6 = 0; e6 < v3; e6++) if (u3.glyphAt(e6).charIndex >= t4) {
                  let t5 = e6, o5 = e6;
                  for (; o5 < v3; o5++) {
                    let e7 = u3.glyphAt(o5);
                    if (e7.charIndex > r4) break;
                    o5 < v3 - f6 && (n4 = Math.min(n4, e7.x), a4 = Math.max(a4, e7.x + e7.width));
                  }
                  for (let e7 = t5; e7 < o5; e7++) {
                    const t6 = u3.glyphAt(e7);
                    t6.x = a4 - (t6.x + t6.width - n4);
                  }
                  break;
                }
              }
              let w3;
              const S3 = (e5) => w3 = e5;
              for (let f7 = 0; f7 < v3; f7++) {
                const v4 = u3.glyphAt(f7);
                w3 = v4.glyphObj;
                const b4 = w3.index, y4 = 1 & e4.levels[v4.charIndex];
                if (y4) {
                  const e5 = t3.getMirroredCharacter(i4[v4.charIndex]);
                  e5 && v4.fontData.fontObj.forEachGlyph(e5, 0, 0, S3);
                }
                if (D2) {
                  const { charIndex: e5, fontData: t4 } = v4, r4 = v4.x + Y2, n4 = v4.x + v4.width + Y2;
                  C3[4 * e5] = y4 ? n4 : r4, C3[4 * e5 + 1] = y4 ? r4 : n4, C3[4 * e5 + 2] = u3.baseline + t4.caretBottom + $2, C3[4 * e5 + 3] = u3.baseline + t4.caretTop + $2;
                  const a4 = e5 - s3;
                  a4 > 1 && l2(C3, s3, a4), s3 = e5;
                }
                if (M2) {
                  const { charIndex: e5 } = v4;
                  for (; e5 > c3; ) c3++, M2.hasOwnProperty(c3) && (a3 = M2[c3]);
                }
                if (!w3.isWhitespace && !w3.isEmpty) {
                  const e5 = o4++, { fontSizeMult: t4, src: i5, index: s4 } = v4.fontData, l3 = g3[i5] || (g3[i5] = {});
                  l3[b4] || (l3[b4] = { path: w3.path, pathBounds: [w3.xMin, w3.yMin, w3.xMax, w3.yMax] });
                  const c4 = v4.x + Y2, f8 = u3.baseline + $2;
                  p3[2 * e5] = c4, p3[2 * e5 + 1] = f8;
                  const y5 = c4 + w3.xMin * t4, m4 = f8 + w3.yMin * t4, x4 = c4 + w3.xMax * t4, k3 = f8 + w3.yMax * t4;
                  y5 < O2[0] && (O2[0] = y5), m4 < O2[1] && (O2[1] = m4), x4 > O2[2] && (O2[2] = x4), k3 > O2[3] && (O2[3] = k3), e5 % A2 == 0 && (n3 = { start: e5, end: e5, rect: [r3, r3, -1 / 0, -1 / 0] }, R2.push(n3)), n3.end++;
                  const S4 = n3.rect;
                  if (y5 < S4[0] && (S4[0] = y5), m4 < S4[1] && (S4[1] = m4), x4 > S4[2] && (S4[2] = x4), k3 > S4[3] && (S4[3] = k3), d3[e5] = b4, h3[e5] = s4, M2) {
                    const t5 = 3 * e5;
                    F3[t5] = a3 >> 16 & 255, F3[t5 + 1] = a3 >> 8 & 255, F3[t5 + 2] = 255 & a3;
                  }
                }
              }
            }
          }), C3) {
            const e5 = i4.length - s3;
            e5 > 1 && l2(C3, s3, e5);
          }
        }
        const Z2 = [];
        z2.forEach(({ index: e4, src: t4, unitsPerEm: r4, ascender: n3, descender: a3, lineHeight: o4, capHeight: i5, xHeight: s3 }) => {
          Z2[e4] = { src: t4, unitsPerEm: r4, ascender: n3, descender: a3, lineHeight: o4, capHeight: i5, xHeight: s3 };
        }), L2.typesetting = c2() - V2, P2({ glyphIds: d3, glyphFontIndices: h3, glyphPositions: p3, glyphData: g3, fontData: Z2, caretPositions: C3, glyphColors: F3, chunkedBounds: R2, fontSize: v2, topBaseline: $2 + X2[0].baseline, blockBounds: [Y2, $2 - q2, Y2 + B2, $2], visibleBounds: O2, timings: L2 });
      });
    }
    function s2(e3) {
      let t4 = e3.match(/^([\d.]+)%$/), r4 = t4 ? parseFloat(t4[1]) : NaN;
      return isNaN(r4) ? 0 : r4 / 100;
    }
    function l2(e3, t4, r4) {
      const n3 = e3[4 * t4], a3 = e3[4 * t4 + 1], o4 = e3[4 * t4 + 2], i4 = e3[4 * t4 + 3], s3 = (a3 - n3) / r4;
      for (let a4 = 0; a4 < r4; a4++) {
        const r5 = 4 * (t4 + a4);
        e3[r5] = n3 + s3 * a4, e3[r5 + 1] = n3 + s3 * (a4 + 1), e3[r5 + 2] = o4, e3[r5 + 3] = i4;
      }
    }
    function c2() {
      return (self.performance || Date).now();
    }
    function u2() {
      this.data = [];
    }
    const f2 = ["glyphObj", "x", "width", "charIndex", "fontData"];
    return u2.prototype = { width: 0, lineHeight: 0, baseline: 0, cap: 0, ex: 0, isSoftWrapped: false, get count() {
      return Math.ceil(this.data.length / f2.length);
    }, glyphAt(e3) {
      let t4 = u2.flyweight;
      return t4.data = this.data, t4.index = e3, t4;
    }, splitAt(e3) {
      let t4 = new u2();
      return t4.data = this.data.splice(e3 * f2.length), t4;
    } }, u2.flyweight = f2.reduce((e3, t4, r4, n3) => (Object.defineProperty(e3, t4, { get() {
      return this.data[this.index * f2.length + r4];
    }, set(e4) {
      this.data[this.index * f2.length + r4] = e4;
    } }), e3), { data: null, index: 0 }), { typeset: i3, measure: function(e3, t4) {
      i3({ ...e3, metricsOnly: true }, (e4) => {
        const [r4, n3, a3, o4] = e4.blockBounds;
        t4({ width: a3 - r4, height: o4 - n3 });
      });
    } };
  }, C, function() {
    return function(e2) {
      var t3 = { R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73", EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9", ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2", ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj", AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u", CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b", B: "a,3,f+2,2v,690", S: "9,2,k", WS: "c,k,4f4,1vk+a,u,1j,335", ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i", BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1", NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n", AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d", LRO: "6ct", RLO: "6cu", LRE: "6cq", RLE: "6cr", PDF: "6cs", LRI: "6ee", RLI: "6ef", FSI: "6eg", PDI: "6eh" }, r3 = {}, n2 = {};
      r3.L = 1, n2[1] = "L", Object.keys(t3).forEach(function(e3, t4) {
        r3[e3] = 1 << t4 + 1, n2[r3[e3]] = e3;
      }), Object.freeze(r3);
      var a2 = r3.LRI | r3.RLI | r3.FSI, o3 = r3.L | r3.R | r3.AL, i3 = r3.B | r3.S | r3.WS | r3.ON | r3.FSI | r3.LRI | r3.RLI | r3.PDI, s2 = r3.BN | r3.RLE | r3.LRE | r3.RLO | r3.LRO | r3.PDF, l2 = r3.S | r3.WS | r3.B | a2 | r3.PDI | s2, c2 = null;
      function u2(e3) {
        return function() {
          if (!c2) {
            c2 = /* @__PURE__ */ new Map();
            var e4 = function(e5) {
              if (t3.hasOwnProperty(e5)) {
                var n4 = 0;
                t3[e5].split(",").forEach(function(t4) {
                  var a3 = t4.split("+"), o4 = a3[0], i4 = a3[1];
                  o4 = parseInt(o4, 36), i4 = i4 ? parseInt(i4, 36) : 0, c2.set(n4 += o4, r3[e5]);
                  for (var s3 = 0; s3 < i4; s3++) c2.set(++n4, r3[e5]);
                });
              }
            };
            for (var n3 in t3) e4(n3);
          }
        }(), c2.get(e3.codePointAt(0)) || r3.L;
      }
      var f2, d2, h2, v2 = { pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1", canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye" };
      function p2(e3, t4) {
        var r4, n3 = 0, a3 = /* @__PURE__ */ new Map(), o4 = t4 && /* @__PURE__ */ new Map();
        return e3.split(",").forEach(function e4(i4) {
          if (-1 !== i4.indexOf("+")) for (var s3 = +i4; s3--; ) e4(r4);
          else {
            r4 = i4;
            var l3 = i4.split(">"), c3 = l3[0], u3 = l3[1];
            c3 = String.fromCodePoint(n3 += parseInt(c3, 36)), u3 = String.fromCodePoint(n3 += parseInt(u3, 36)), a3.set(c3, u3), t4 && o4.set(u3, c3);
          }
        }), { map: a3, reverseMap: o4 };
      }
      function g2() {
        if (!f2) {
          var e3 = p2(v2.pairs, true), t4 = e3.map, r4 = e3.reverseMap;
          f2 = t4, d2 = r4, h2 = p2(v2.canonical, false).map;
        }
      }
      function b2(e3) {
        return g2(), f2.get(e3) || null;
      }
      function y2(e3) {
        return g2(), d2.get(e3) || null;
      }
      function m2(e3) {
        return g2(), h2.get(e3) || null;
      }
      var x2, k2 = r3.L, w2 = r3.R, S2 = r3.EN, U2 = r3.ES, T2 = r3.ET, _2 = r3.AN, E2 = r3.CS, F2 = r3.B, C2 = r3.S, D2 = r3.ON, A2 = r3.BN, M2 = r3.NSM, P2 = r3.AL, I2 = r3.LRO, L2 = r3.RLO, O2 = r3.LRE, R2 = r3.RLE, B2 = r3.PDF, G2 = r3.LRI, N2 = r3.RLI, z2 = r3.FSI, V2 = r3.PDI;
      function j2(e3) {
        return function() {
          if (!x2) {
            var e4 = p2("14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", true), t4 = e4.map;
            e4.reverseMap.forEach(function(e5, r4) {
              t4.set(r4, e5);
            }), x2 = t4;
          }
        }(), x2.get(e3) || null;
      }
      function W2(e3, t4, r4, n3) {
        var a3 = e3.length;
        r4 = Math.max(0, null == r4 ? 0 : +r4), n3 = Math.min(a3 - 1, null == n3 ? a3 - 1 : +n3);
        var o4 = [];
        return t4.paragraphs.forEach(function(a4) {
          var i4 = Math.max(r4, a4.start), s3 = Math.min(n3, a4.end);
          if (i4 < s3) {
            for (var c3 = t4.levels.slice(i4, s3 + 1), f3 = s3; f3 >= i4 && u2(e3[f3]) & l2; f3--) c3[f3] = a4.level;
            for (var d3 = a4.level, h3 = 1 / 0, v3 = 0; v3 < c3.length; v3++) {
              var p3 = c3[v3];
              p3 > d3 && (d3 = p3), p3 < h3 && (h3 = 1 | p3);
            }
            for (var g3 = d3; g3 >= h3; g3--) for (var b3 = 0; b3 < c3.length; b3++) if (c3[b3] >= g3) {
              for (var y3 = b3; b3 + 1 < c3.length && c3[b3 + 1] >= g3; ) b3++;
              b3 > y3 && o4.push([y3 + i4, b3 + i4]);
            }
          }
        }), o4;
      }
      function H2(e3, t4, r4, n3) {
        for (var a3 = W2(e3, t4, r4, n3), o4 = [], i4 = 0; i4 < e3.length; i4++) o4[i4] = i4;
        return a3.forEach(function(e4) {
          for (var t5 = e4[0], r5 = e4[1], n4 = o4.slice(t5, r5 + 1), a4 = n4.length; a4--; ) o4[r5 - a4] = n4[a4];
        }), o4;
      }
      return e2.closingToOpeningBracket = y2, e2.getBidiCharType = u2, e2.getBidiCharTypeName = function(e3) {
        return n2[u2(e3)];
      }, e2.getCanonicalBracket = m2, e2.getEmbeddingLevels = function(e3, t4) {
        for (var r4 = new Uint32Array(e3.length), n3 = 0; n3 < e3.length; n3++) r4[n3] = u2(e3[n3]);
        var c3 = /* @__PURE__ */ new Map();
        function f3(e4, t5) {
          var n4 = r4[e4];
          r4[e4] = t5, c3.set(n4, c3.get(n4) - 1), n4 & i3 && c3.set(i3, c3.get(i3) - 1), c3.set(t5, (c3.get(t5) || 0) + 1), t5 & i3 && c3.set(i3, (c3.get(i3) || 0) + 1);
        }
        for (var d3 = new Uint8Array(e3.length), h3 = /* @__PURE__ */ new Map(), v3 = [], p3 = null, g3 = 0; g3 < e3.length; g3++) p3 || v3.push(p3 = { start: g3, end: e3.length - 1, level: "rtl" === t4 ? 1 : "ltr" === t4 ? 0 : zt(g3, false) }), r4[g3] & F2 && (p3.end = g3, p3 = null);
        for (var x3 = R2 | O2 | L2 | I2 | a2 | V2 | B2 | F2, j3 = function(e4) {
          return e4 + (1 & e4 ? 1 : 2);
        }, W3 = function(e4) {
          return e4 + (1 & e4 ? 2 : 1);
        }, H3 = 0; H3 < v3.length; H3++) {
          var X2 = [{ _level: (p3 = v3[H3]).level, _override: 0, _isolate: 0 }], q2 = void 0, Y2 = 0, $2 = 0, Z2 = 0;
          c3.clear();
          for (var K2 = p3.start; K2 <= p3.end; K2++) {
            var Q2 = r4[K2];
            if (q2 = X2[X2.length - 1], c3.set(Q2, (c3.get(Q2) || 0) + 1), Q2 & i3 && c3.set(i3, (c3.get(i3) || 0) + 1), Q2 & x3) if (Q2 & (R2 | O2)) {
              d3[K2] = q2._level;
              var J2 = (Q2 === R2 ? W3 : j3)(q2._level);
              J2 <= 125 && !Y2 && !$2 ? X2.push({ _level: J2, _override: 0, _isolate: 0 }) : Y2 || $2++;
            } else if (Q2 & (L2 | I2)) {
              d3[K2] = q2._level;
              var ee2 = (Q2 === L2 ? W3 : j3)(q2._level);
              ee2 <= 125 && !Y2 && !$2 ? X2.push({ _level: ee2, _override: Q2 & L2 ? w2 : k2, _isolate: 0 }) : Y2 || $2++;
            } else if (Q2 & a2) {
              Q2 & z2 && (Q2 = 1 === zt(K2 + 1, true) ? N2 : G2), d3[K2] = q2._level, q2._override && f3(K2, q2._override);
              var te2 = (Q2 === N2 ? W3 : j3)(q2._level);
              te2 <= 125 && 0 === Y2 && 0 === $2 ? (Z2++, X2.push({ _level: te2, _override: 0, _isolate: 1, _isolInitIndex: K2 })) : Y2++;
            } else if (Q2 & V2) {
              if (Y2 > 0) Y2--;
              else if (Z2 > 0) {
                for ($2 = 0; !X2[X2.length - 1]._isolate; ) X2.pop();
                var re2 = X2[X2.length - 1]._isolInitIndex;
                null != re2 && (h3.set(re2, K2), h3.set(K2, re2)), X2.pop(), Z2--;
              }
              q2 = X2[X2.length - 1], d3[K2] = q2._level, q2._override && f3(K2, q2._override);
            } else Q2 & B2 ? (0 === Y2 && ($2 > 0 ? $2-- : !q2._isolate && X2.length > 1 && (X2.pop(), q2 = X2[X2.length - 1])), d3[K2] = q2._level) : Q2 & F2 && (d3[K2] = p3.level);
            else d3[K2] = q2._level, q2._override && Q2 !== A2 && f3(K2, q2._override);
          }
          for (var ne2 = [], ae2 = null, oe2 = p3.start; oe2 <= p3.end; oe2++) {
            var ie2 = r4[oe2];
            if (!(ie2 & s2)) {
              var se2 = d3[oe2], le2 = ie2 & a2, ce2 = ie2 === V2;
              ae2 && se2 === ae2._level ? (ae2._end = oe2, ae2._endsWithIsolInit = le2) : ne2.push(ae2 = { _start: oe2, _end: oe2, _level: se2, _startsWithPDI: ce2, _endsWithIsolInit: le2 });
            }
          }
          for (var ue2 = [], fe2 = 0; fe2 < ne2.length; fe2++) {
            var de2 = ne2[fe2];
            if (!de2._startsWithPDI || de2._startsWithPDI && !h3.has(de2._start)) {
              for (var he2 = [ae2 = de2], ve2 = void 0; ae2 && ae2._endsWithIsolInit && null != (ve2 = h3.get(ae2._end)); ) for (var pe2 = fe2 + 1; pe2 < ne2.length; pe2++) if (ne2[pe2]._start === ve2) {
                he2.push(ae2 = ne2[pe2]);
                break;
              }
              for (var ge2 = [], be2 = 0; be2 < he2.length; be2++) for (var ye2 = he2[be2], me2 = ye2._start; me2 <= ye2._end; me2++) ge2.push(me2);
              for (var xe2 = d3[ge2[0]], ke2 = p3.level, we2 = ge2[0] - 1; we2 >= 0; we2--) if (!(r4[we2] & s2)) {
                ke2 = d3[we2];
                break;
              }
              var Se2 = ge2[ge2.length - 1], Ue2 = d3[Se2], Te2 = p3.level;
              if (!(r4[Se2] & a2)) {
                for (var _e2 = Se2 + 1; _e2 <= p3.end; _e2++) if (!(r4[_e2] & s2)) {
                  Te2 = d3[_e2];
                  break;
                }
              }
              ue2.push({ _seqIndices: ge2, _sosType: Math.max(ke2, xe2) % 2 ? w2 : k2, _eosType: Math.max(Te2, Ue2) % 2 ? w2 : k2 });
            }
          }
          for (var Ee2 = 0; Ee2 < ue2.length; Ee2++) {
            var Fe2 = ue2[Ee2], Ce2 = Fe2._seqIndices, De2 = Fe2._sosType, Ae2 = Fe2._eosType, Me2 = 1 & d3[Ce2[0]] ? w2 : k2;
            if (c3.get(M2)) for (var Pe2 = 0; Pe2 < Ce2.length; Pe2++) {
              var Ie2 = Ce2[Pe2];
              if (r4[Ie2] & M2) {
                for (var Le2 = De2, Oe2 = Pe2 - 1; Oe2 >= 0; Oe2--) if (!(r4[Ce2[Oe2]] & s2)) {
                  Le2 = r4[Ce2[Oe2]];
                  break;
                }
                f3(Ie2, Le2 & (a2 | V2) ? D2 : Le2);
              }
            }
            if (c3.get(S2)) for (var Re2 = 0; Re2 < Ce2.length; Re2++) {
              var Be2 = Ce2[Re2];
              if (r4[Be2] & S2) for (var Ge2 = Re2 - 1; Ge2 >= -1; Ge2--) {
                var Ne2 = -1 === Ge2 ? De2 : r4[Ce2[Ge2]];
                if (Ne2 & o3) {
                  Ne2 === P2 && f3(Be2, _2);
                  break;
                }
              }
            }
            if (c3.get(P2)) for (var ze2 = 0; ze2 < Ce2.length; ze2++) {
              var Ve2 = Ce2[ze2];
              r4[Ve2] & P2 && f3(Ve2, w2);
            }
            if (c3.get(U2) || c3.get(E2)) for (var je2 = 1; je2 < Ce2.length - 1; je2++) {
              var We2 = Ce2[je2];
              if (r4[We2] & (U2 | E2)) {
                for (var He2 = 0, Xe2 = 0, qe2 = je2 - 1; qe2 >= 0 && (He2 = r4[Ce2[qe2]]) & s2; qe2--) ;
                for (var Ye2 = je2 + 1; Ye2 < Ce2.length && (Xe2 = r4[Ce2[Ye2]]) & s2; Ye2++) ;
                He2 === Xe2 && (r4[We2] === U2 ? He2 === S2 : He2 & (S2 | _2)) && f3(We2, He2);
              }
            }
            if (c3.get(S2)) for (var $e2 = 0; $e2 < Ce2.length; $e2++) {
              var Ze2 = Ce2[$e2];
              if (r4[Ze2] & S2) {
                for (var Ke2 = $e2 - 1; Ke2 >= 0 && r4[Ce2[Ke2]] & (T2 | s2); Ke2--) f3(Ce2[Ke2], S2);
                for ($e2++; $e2 < Ce2.length && r4[Ce2[$e2]] & (T2 | s2 | S2); $e2++) r4[Ce2[$e2]] !== S2 && f3(Ce2[$e2], S2);
              }
            }
            if (c3.get(T2) || c3.get(U2) || c3.get(E2)) for (var Qe2 = 0; Qe2 < Ce2.length; Qe2++) {
              var Je2 = Ce2[Qe2];
              if (r4[Je2] & (T2 | U2 | E2)) {
                f3(Je2, D2);
                for (var et2 = Qe2 - 1; et2 >= 0 && r4[Ce2[et2]] & s2; et2--) f3(Ce2[et2], D2);
                for (var tt2 = Qe2 + 1; tt2 < Ce2.length && r4[Ce2[tt2]] & s2; tt2++) f3(Ce2[tt2], D2);
              }
            }
            if (c3.get(S2)) for (var rt2 = 0, nt2 = De2; rt2 < Ce2.length; rt2++) {
              var at2 = Ce2[rt2], ot2 = r4[at2];
              ot2 & S2 ? nt2 === k2 && f3(at2, k2) : ot2 & o3 && (nt2 = ot2);
            }
            if (c3.get(i3)) {
              for (var it2 = w2 | S2 | _2, st2 = it2 | k2, lt2 = [], ct2 = [], ut2 = 0; ut2 < Ce2.length; ut2++) if (r4[Ce2[ut2]] & i3) {
                var ft2 = e3[Ce2[ut2]], dt2 = void 0;
                if (null !== b2(ft2)) {
                  if (!(ct2.length < 63)) break;
                  ct2.push({ char: ft2, seqIndex: ut2 });
                } else if (null !== (dt2 = y2(ft2))) for (var ht2 = ct2.length - 1; ht2 >= 0; ht2--) {
                  var vt2 = ct2[ht2].char;
                  if (vt2 === dt2 || vt2 === y2(m2(ft2)) || b2(m2(vt2)) === ft2) {
                    lt2.push([ct2[ht2].seqIndex, ut2]), ct2.length = ht2;
                    break;
                  }
                }
              }
              lt2.sort(function(e4, t5) {
                return e4[0] - t5[0];
              });
              for (var pt2 = 0; pt2 < lt2.length; pt2++) {
                for (var gt2 = lt2[pt2], bt = gt2[0], yt = gt2[1], mt = false, xt = 0, kt = bt + 1; kt < yt; kt++) {
                  var wt = Ce2[kt];
                  if (r4[wt] & st2) {
                    mt = true;
                    var St = r4[wt] & it2 ? w2 : k2;
                    if (St === Me2) {
                      xt = St;
                      break;
                    }
                  }
                }
                if (mt && !xt) {
                  xt = De2;
                  for (var Ut = bt - 1; Ut >= 0; Ut--) {
                    var Tt = Ce2[Ut];
                    if (r4[Tt] & st2) {
                      var _t = r4[Tt] & it2 ? w2 : k2;
                      xt = _t !== Me2 ? _t : Me2;
                      break;
                    }
                  }
                }
                if (xt) {
                  if (r4[Ce2[bt]] = r4[Ce2[yt]] = xt, xt !== Me2) {
                    for (var Et = bt + 1; Et < Ce2.length; Et++) if (!(r4[Ce2[Et]] & s2)) {
                      u2(e3[Ce2[Et]]) & M2 && (r4[Ce2[Et]] = xt);
                      break;
                    }
                  }
                  if (xt !== Me2) {
                    for (var Ft = yt + 1; Ft < Ce2.length; Ft++) if (!(r4[Ce2[Ft]] & s2)) {
                      u2(e3[Ce2[Ft]]) & M2 && (r4[Ce2[Ft]] = xt);
                      break;
                    }
                  }
                }
              }
              for (var Ct = 0; Ct < Ce2.length; Ct++) if (r4[Ce2[Ct]] & i3) {
                for (var Dt = Ct, At = Ct, Mt = De2, Pt = Ct - 1; Pt >= 0; Pt--) {
                  if (!(r4[Ce2[Pt]] & s2)) {
                    Mt = r4[Ce2[Pt]] & it2 ? w2 : k2;
                    break;
                  }
                  Dt = Pt;
                }
                for (var It = Ae2, Lt = Ct + 1; Lt < Ce2.length; Lt++) {
                  if (!(r4[Ce2[Lt]] & (i3 | s2))) {
                    It = r4[Ce2[Lt]] & it2 ? w2 : k2;
                    break;
                  }
                  At = Lt;
                }
                for (var Ot = Dt; Ot <= At; Ot++) r4[Ce2[Ot]] = Mt === It ? Mt : Me2;
                Ct = At;
              }
            }
          }
          for (var Rt = p3.start; Rt <= p3.end; Rt++) {
            var Bt = d3[Rt], Gt = r4[Rt];
            if (1 & Bt ? Gt & (k2 | S2 | _2) && d3[Rt]++ : Gt & w2 ? d3[Rt]++ : Gt & (_2 | S2) && (d3[Rt] += 2), Gt & s2 && (d3[Rt] = 0 === Rt ? p3.level : d3[Rt - 1]), Rt === p3.end || u2(e3[Rt]) & (C2 | F2)) for (var Nt = Rt; Nt >= 0 && u2(e3[Nt]) & l2; Nt--) d3[Nt] = p3.level;
          }
        }
        return { levels: d3, paragraphs: v3 };
        function zt(t5, n4) {
          for (var o4 = t5; o4 < e3.length; o4++) {
            var i4 = r4[o4];
            if (i4 & (w2 | P2)) return 1;
            if (i4 & (F2 | k2) || n4 && i4 === V2) return 0;
            if (i4 & a2) {
              var s3 = Vt(o4);
              o4 = -1 === s3 ? e3.length : s3;
            }
          }
          return 0;
        }
        function Vt(t5) {
          for (var n4 = 1, o4 = t5 + 1; o4 < e3.length; o4++) {
            var i4 = r4[o4];
            if (i4 & F2) break;
            if (i4 & V2) {
              if (0 == --n4) return o4;
            } else i4 & a2 && n4++;
          }
          return -1;
        }
      }, e2.getMirroredCharacter = j2, e2.getMirroredCharactersMap = function(e3, t4, r4, n3) {
        var a3 = e3.length;
        r4 = Math.max(0, null == r4 ? 0 : +r4), n3 = Math.min(a3 - 1, null == n3 ? a3 - 1 : +n3);
        for (var o4 = /* @__PURE__ */ new Map(), i4 = r4; i4 <= n3; i4++) if (1 & t4[i4]) {
          var s3 = j2(e3[i4]);
          null !== s3 && o4.set(i4, s3);
        }
        return o4;
      }, e2.getReorderSegments = W2, e2.getReorderedIndices = H2, e2.getReorderedString = function(e3, t4, r4, n3) {
        var a3 = H2(e3, t4, r4, n3), o4 = [].concat(e3);
        return a3.forEach(function(r5, n4) {
          o4[n4] = (1 & t4.levels[r5] ? j2(e3[r5]) : null) || e3[r5];
        }), o4.join("");
      }, e2.openingToClosingBracket = b2, Object.defineProperty(e2, "__esModule", { value: true }), e2;
    }({});
  }], init: (e2, t3, r3) => e2(t3, r3()) }), J = f({ name: "Typesetter", dependencies: [Q], init: (e2) => function(t3) {
    return new Promise((r3) => {
      e2.typeset(t3, r3);
    });
  }, getTransferables(e2) {
    const t3 = [];
    for (let r3 in e2) e2[r3] && e2[r3].buffer && t3.push(e2[r3].buffer);
    return t3;
  } }), ee = {}, te = "aTroikaGlyphIndex";
  class re extends e.InstancedBufferGeometry {
    constructor() {
      super(), this.detail = 1, this.curveRadius = 0, this.groups = [{ start: 0, count: 1 / 0, materialIndex: 0 }, { start: 0, count: 1 / 0, materialIndex: 1 }], this.boundingSphere = new e.Sphere(), this.boundingBox = new e.Box3();
    }
    computeBoundingSphere() {
    }
    computeBoundingBox() {
    }
    setSide(t3) {
      const r3 = this.getIndex().count;
      this.setDrawRange(t3 === e.BackSide ? r3 / 2 : 0, t3 === e.DoubleSide ? r3 : r3 / 2);
    }
    set detail(t3) {
      if (t3 !== this._detail) {
        this._detail = t3, ("number" != typeof t3 || t3 < 1) && (t3 = 1);
        let r3 = function(t4) {
          let r4 = ee[t4];
          if (!r4) {
            const n2 = new e.PlaneGeometry(1, 1, t4, t4), a2 = n2.clone(), o3 = n2.attributes, i3 = a2.attributes, s2 = new e.BufferGeometry(), l2 = o3.uv.count;
            for (let e2 = 0; e2 < l2; e2++) i3.position.array[3 * e2] *= -1, i3.normal.array[3 * e2 + 2] *= -1;
            ["position", "normal", "uv"].forEach((t5) => {
              s2.setAttribute(t5, new e.Float32BufferAttribute([...o3[t5].array, ...i3[t5].array], o3[t5].itemSize));
            }), s2.setIndex([...n2.index.array, ...a2.index.array.map((e2) => e2 + l2)]), s2.translate(0.5, 0.5, 0), r4 = ee[t4] = s2;
          }
          return r4;
        }(t3);
        ["position", "normal", "uv"].forEach((e2) => {
          this.attributes[e2] = r3.attributes[e2].clone();
        }), this.setIndex(r3.getIndex().clone());
      }
    }
    get detail() {
      return this._detail;
    }
    set curveRadius(e2) {
      e2 !== this._curveRadius && (this._curveRadius = e2, this._updateBounds());
    }
    get curveRadius() {
      return this._curveRadius;
    }
    updateGlyphs(e2, t3, r3, n2, a2) {
      ne(this, "aTroikaGlyphBounds", e2, 4), ne(this, te, t3, 1), ne(this, "aTroikaGlyphColor", a2, 3), this._blockBounds = r3, this._chunkedBounds = n2, this.instanceCount = t3.length, this._updateBounds();
    }
    _updateBounds() {
      const e2 = this._blockBounds;
      if (e2) {
        const { curveRadius: t3, boundingBox: r3 } = this;
        if (t3) {
          const { PI: n2, floor: a2, min: o3, max: i3, sin: s2, cos: l2 } = Math, c2 = n2 / 2, u2 = 2 * n2, f2 = Math.abs(t3), d2 = e2[0] / f2, h2 = e2[2] / f2, v2 = a2((d2 + c2) / u2) !== a2((h2 + c2) / u2) ? -f2 : o3(s2(d2) * f2, s2(h2) * f2), p2 = a2((d2 - c2) / u2) !== a2((h2 - c2) / u2) ? f2 : i3(s2(d2) * f2, s2(h2) * f2), g2 = a2((d2 + n2) / u2) !== a2((h2 + n2) / u2) ? 2 * f2 : i3(f2 - l2(d2) * f2, f2 - l2(h2) * f2);
          r3.min.set(v2, e2[1], t3 < 0 ? -g2 : 0), r3.max.set(p2, e2[3], t3 < 0 ? 0 : g2);
        } else r3.min.set(e2[0], e2[1], 0), r3.max.set(e2[2], e2[3], 0);
        r3.getBoundingSphere(this.boundingSphere);
      }
    }
    applyClipRect(e2) {
      let t3 = this.getAttribute(te).count, r3 = this._chunkedBounds;
      if (r3) for (let n2 = r3.length; n2--; ) {
        t3 = r3[n2].end;
        let a2 = r3[n2].rect;
        if (a2[1] < e2.w && a2[3] > e2.y && a2[0] < e2.z && a2[2] > e2.x) break;
      }
      this.instanceCount = t3;
    }
  }
  function ne(t3, r3, n2, a2) {
    const o3 = t3.getAttribute(r3);
    n2 ? o3 && o3.array.length === n2.length ? (o3.array.set(n2), o3.needsUpdate = true) : (t3.setAttribute(r3, new e.InstancedBufferAttribute(n2, a2)), delete t3._maxInstanceCount, t3.dispose()) : o3 && t3.deleteAttribute(r3);
  }
  const ae = new e.MeshBasicMaterial({ color: 16777215, side: e.DoubleSide, transparent: true }), oe = 8421504, ie = new e.Matrix4(), se = new e.Vector3(), le = new e.Vector3(), ce = [], ue = new e.Vector3(), fe = "+x+y";
  function de(e2) {
    return Array.isArray(e2) ? e2[0] : e2;
  }
  let he = () => {
    const t3 = new e.Mesh(new e.PlaneGeometry(1, 1), ae);
    return he = () => t3, t3;
  }, ve = () => {
    const t3 = new e.Mesh(new e.PlaneGeometry(1, 1, 32, 1), ae);
    return ve = () => t3, t3;
  };
  const pe = { type: "syncstart" }, ge = { type: "synccomplete" }, be = ["font", "fontSize", "fontStyle", "fontWeight", "lang", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"], ye = be.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
  class me extends e.Mesh {
    constructor() {
      super(new re(), null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = oe, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = fe, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = true, this.debugSDF = false;
    }
    sync(t3) {
      this._needsSync && (this._needsSync = false, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(t3) : (this._isSyncing = true, this.dispatchEvent(pe), function(t4, r3) {
        H = true, t4 = function(e2, t5) {
          for (let r4 in t5) t5.hasOwnProperty(r4) && (e2[r4] = t5[r4]);
          return e2;
        }({}, t4);
        const n2 = X(), { defaultFontURL: a2 } = j, o3 = [];
        if (a2 && o3.push({ label: "default", src: Z(a2) }), t4.font && o3.push({ label: "user", src: Z(t4.font) }), t4.font = o3, t4.text = "" + t4.text, t4.sdfGlyphSize = t4.sdfGlyphSize || j.sdfGlyphSize, t4.unicodeFontsURL = t4.unicodeFontsURL || j.unicodeFontsURL, null != t4.colorRanges) {
          let e2 = {};
          for (let r4 in t4.colorRanges) if (t4.colorRanges.hasOwnProperty(r4)) {
            let n3 = t4.colorRanges[r4];
            "number" != typeof n3 && (n3 = W.set(n3).getHex()), e2[r4] = n3;
          }
          t4.colorRanges = e2;
        }
        Object.freeze(t4);
        const { textureWidth: i3, sdfExponent: s2 } = j, { sdfGlyphSize: l2 } = t4, c2 = i3 / l2 * 4;
        let u2 = q[l2];
        if (!u2) {
          const t5 = document.createElement("canvas");
          t5.width = i3, t5.height = 256 * l2 / c2, u2 = q[l2] = { glyphCount: 0, sdfGlyphSize: l2, sdfCanvas: t5, sdfTexture: new e.Texture(t5, void 0, void 0, void 0, e.LinearFilter, e.LinearFilter), contextLost: false, glyphsByFont: /* @__PURE__ */ new Map() }, u2.sdfTexture.generateMipmaps = false, function(e2) {
            const t6 = e2.sdfCanvas;
            t6.addEventListener("webglcontextlost", (t7) => {
              console.log("Context Lost", t7), t7.preventDefault(), e2.contextLost = true;
            }), t6.addEventListener("webglcontextrestored", (t7) => {
              console.log("Context Restored", t7), e2.contextLost = false;
              const r4 = [];
              e2.glyphsByFont.forEach((t8) => {
                t8.forEach((t9) => {
                  r4.push(Y(t9, e2, true));
                });
              }), Promise.all(r4).then(() => {
                K(e2), e2.sdfTexture.needsUpdate = true;
              });
            });
          }(u2);
        }
        const { sdfTexture: f2, sdfCanvas: d2 } = u2;
        J(t4).then((e2) => {
          const { glyphIds: a3, glyphFontIndices: o4, fontData: h2, glyphPositions: v2, fontSize: p2, timings: g2 } = e2, b2 = [], y2 = new Float32Array(4 * a3.length);
          let m2 = 0, x2 = 0;
          const k2 = X(), w2 = h2.map((e3) => {
            let t5 = u2.glyphsByFont.get(e3.src);
            return t5 || u2.glyphsByFont.set(e3.src, t5 = /* @__PURE__ */ new Map()), t5;
          });
          a3.forEach((t5, r4) => {
            const n3 = o4[r4], { src: i4, unitsPerEm: s3 } = h2[n3];
            let c3 = w2[n3].get(t5);
            if (!c3) {
              const { path: r5, pathBounds: a4 } = e2.glyphData[i4][t5], o5 = Math.max(a4[2] - a4[0], a4[3] - a4[1]) / l2 * (j.sdfMargin * l2 + 0.5), s4 = u2.glyphCount++, f4 = [a4[0] - o5, a4[1] - o5, a4[2] + o5, a4[3] + o5];
              w2[n3].set(t5, c3 = { path: r5, atlasIndex: s4, sdfViewBox: f4 }), b2.push(c3);
            }
            const { sdfViewBox: f3 } = c3, d3 = v2[x2++], g3 = v2[x2++], k3 = p2 / s3;
            y2[m2++] = d3 + f3[0] * k3, y2[m2++] = g3 + f3[1] * k3, y2[m2++] = d3 + f3[2] * k3, y2[m2++] = g3 + f3[3] * k3, a3[r4] = c3.atlasIndex;
          }), g2.quads = (g2.quads || 0) + (X() - k2);
          const S2 = X();
          g2.sdf = {};
          const U2 = d2.height, T2 = Math.ceil(u2.glyphCount / c2), _2 = Math.pow(2, Math.ceil(Math.log2(T2 * l2)));
          _2 > U2 && (console.info(`Increasing SDF texture size ${U2}->${_2}`), V(d2, i3, _2), f2.dispose()), Promise.all(b2.map((e3) => Y(e3, u2, t4.gpuAccelerateSDF).then(({ timing: t5 }) => {
            g2.sdf[e3.atlasIndex] = t5;
          }))).then(() => {
            b2.length && !u2.contextLost && (K(u2), f2.needsUpdate = true), g2.sdfTotal = X() - S2, g2.total = X() - n2, r3(Object.freeze({ parameters: t4, sdfTexture: f2, sdfGlyphSize: l2, sdfExponent: s2, glyphBounds: y2, glyphAtlasIndices: a3, glyphColors: e2.glyphColors, caretPositions: e2.caretPositions, chunkedBounds: e2.chunkedBounds, ascender: e2.ascender, descender: e2.descender, lineHeight: e2.lineHeight, capHeight: e2.capHeight, xHeight: e2.xHeight, topBaseline: e2.topBaseline, blockBounds: e2.blockBounds, visibleBounds: e2.visibleBounds, timings: e2.timings }));
          });
        }), Promise.resolve().then(() => {
          var e2;
          u2.contextLost || (e2 = d2)._warm || (A.webgl.isSupported(e2), e2._warm = true);
        });
      }({ text: this.text, font: this.font, lang: this.lang, fontSize: this.fontSize || 0.1, fontWeight: this.fontWeight || "normal", fontStyle: this.fontStyle || "normal", letterSpacing: this.letterSpacing || 0, lineHeight: this.lineHeight || "normal", maxWidth: this.maxWidth, direction: this.direction || "auto", textAlign: this.textAlign, textIndent: this.textIndent, whiteSpace: this.whiteSpace, overflowWrap: this.overflowWrap, anchorX: this.anchorX, anchorY: this.anchorY, colorRanges: this.colorRanges, includeCaretPositions: true, sdfGlyphSize: this.sdfGlyphSize, gpuAccelerateSDF: this.gpuAccelerateSDF, unicodeFontsURL: this.unicodeFontsURL }, (e2) => {
        this._isSyncing = false, this._textRenderInfo = e2, this.geometry.updateGlyphs(e2.glyphBounds, e2.glyphAtlasIndices, e2.blockBounds, e2.chunkedBounds, e2.glyphColors);
        const r3 = this._queuedSyncs;
        r3 && (this._queuedSyncs = null, this._needsSync = true, this.sync(() => {
          r3.forEach((e3) => e3 && e3());
        })), this.dispatchEvent(ge), t3 && t3();
      })));
    }
    onBeforeRender(t3, r3, n2, a2, o3, i3) {
      this.sync(), o3.isTroikaTextMaterial && this._prepareForRender(o3), o3._hadOwnSide = o3.hasOwnProperty("side"), this.geometry.setSide(o3._actualSide = o3.side), o3.side = e.FrontSide;
    }
    onAfterRender(e2, t3, r3, n2, a2, o3) {
      a2._hadOwnSide ? a2.side = a2._actualSide : delete a2.side;
    }
    dispose() {
      this.geometry.dispose();
    }
    get textRenderInfo() {
      return this._textRenderInfo || null;
    }
    get material() {
      let t3 = this._derivedMaterial;
      const r3 = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = ae.clone());
      if (t3 && t3.baseMaterial === r3 || (t3 = this._derivedMaterial = function(t4) {
        const r4 = S(t4, { chained: true, extensions: { derivatives: true }, uniforms: { uTroikaSDFTexture: { value: null }, uTroikaSDFTextureSize: { value: new e.Vector2() }, uTroikaSDFGlyphSize: { value: 0 }, uTroikaSDFExponent: { value: 0 }, uTroikaTotalBounds: { value: new e.Vector4(0, 0, 0, 0) }, uTroikaClipRect: { value: new e.Vector4(0, 0, 0, 0) }, uTroikaDistanceOffset: { value: 0 }, uTroikaOutlineOpacity: { value: 0 }, uTroikaFillOpacity: { value: 1 }, uTroikaPositionOffset: { value: new e.Vector2() }, uTroikaCurveRadius: { value: 0 }, uTroikaBlurRadius: { value: 0 }, uTroikaStrokeWidth: { value: 0 }, uTroikaStrokeColor: { value: new e.Color() }, uTroikaStrokeOpacity: { value: 1 }, uTroikaOrient: { value: new e.Matrix3() }, uTroikaUseGlyphColors: { value: true }, uTroikaSDFDebug: { value: false } }, vertexDefs: "\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n", vertexTransform: "\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n", fragmentDefs: "\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  \n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  \n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  \n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n", fragmentColorTransform: "\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n", customRewriter({ vertexShader: e2, fragmentShader: t5 }) {
          let r5 = /\buniform\s+vec3\s+diffuse\b/;
          return r5.test(t5) && (t5 = t5.replace(r5, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), r5.test(e2) || (e2 = e2.replace(p, "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"))), { vertexShader: e2, fragmentShader: t5 };
        } });
        return r4.transparent = true, Object.defineProperties(r4, { isTroikaTextMaterial: { value: true }, shadowSide: { get() {
          return this.side;
        }, set() {
        } } }), r4;
      }(r3), r3.addEventListener("dispose", function e2() {
        r3.removeEventListener("dispose", e2), t3.dispose();
      })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
        let e2 = t3._outlineMtl;
        return e2 || (e2 = t3._outlineMtl = Object.create(t3, { id: { value: t3.id + 0.1 } }), e2.isTextOutlineMaterial = true, e2.depthWrite = false, e2.map = null, t3.addEventListener("dispose", function r4() {
          t3.removeEventListener("dispose", r4), e2.dispose();
        })), [e2, t3];
      }
      return t3;
    }
    set material(e2) {
      e2 && e2.isTroikaTextMaterial ? (this._derivedMaterial = e2, this._baseMaterial = e2.baseMaterial) : this._baseMaterial = e2;
    }
    get glyphGeometryDetail() {
      return this.geometry.detail;
    }
    set glyphGeometryDetail(e2) {
      this.geometry.detail = e2;
    }
    get curveRadius() {
      return this.geometry.curveRadius;
    }
    set curveRadius(e2) {
      this.geometry.curveRadius = e2;
    }
    get customDepthMaterial() {
      return de(this.material).getDepthMaterial();
    }
    get customDistanceMaterial() {
      return de(this.material).getDistanceMaterial();
    }
    _prepareForRender(t3) {
      const r3 = t3.isTextOutlineMaterial, n2 = t3.uniforms, a2 = this.textRenderInfo;
      if (a2) {
        const { sdfTexture: e2, blockBounds: t4 } = a2;
        n2.uTroikaSDFTexture.value = e2, n2.uTroikaSDFTextureSize.value.set(e2.image.width, e2.image.height), n2.uTroikaSDFGlyphSize.value = a2.sdfGlyphSize, n2.uTroikaSDFExponent.value = a2.sdfExponent, n2.uTroikaTotalBounds.value.fromArray(t4), n2.uTroikaUseGlyphColors.value = !r3 && !!a2.glyphColors;
        let o4, i4, s2, l2 = 0, c2 = 0, u2 = 0, f2 = 0, d2 = 0;
        if (r3) {
          let { outlineWidth: e3, outlineOffsetX: t5, outlineOffsetY: r4, outlineBlur: n3, outlineOpacity: a3 } = this;
          l2 = this._parsePercent(e3) || 0, c2 = Math.max(0, this._parsePercent(n3) || 0), o4 = a3, f2 = this._parsePercent(t5) || 0, d2 = this._parsePercent(r4) || 0;
        } else u2 = Math.max(0, this._parsePercent(this.strokeWidth) || 0), u2 && (s2 = this.strokeColor, n2.uTroikaStrokeColor.value.set(null == s2 ? oe : s2), i4 = this.strokeOpacity, null == i4 && (i4 = 1)), o4 = this.fillOpacity;
        n2.uTroikaDistanceOffset.value = l2, n2.uTroikaPositionOffset.value.set(f2, d2), n2.uTroikaBlurRadius.value = c2, n2.uTroikaStrokeWidth.value = u2, n2.uTroikaStrokeOpacity.value = i4, n2.uTroikaFillOpacity.value = null == o4 ? 1 : o4, n2.uTroikaCurveRadius.value = this.curveRadius || 0;
        let h2 = this.clipRect;
        if (h2 && Array.isArray(h2) && 4 === h2.length) n2.uTroikaClipRect.value.fromArray(h2);
        else {
          const e3 = 100 * (this.fontSize || 0.1);
          n2.uTroikaClipRect.value.set(t4[0] - e3, t4[1] - e3, t4[2] + e3, t4[3] + e3);
        }
        this.geometry.applyClipRect(n2.uTroikaClipRect.value);
      }
      n2.uTroikaSDFDebug.value = !!this.debugSDF, t3.polygonOffset = !!this.depthOffset, t3.polygonOffsetFactor = t3.polygonOffsetUnits = this.depthOffset || 0;
      const o3 = r3 ? this.outlineColor || 0 : this.color;
      if (null == o3) delete t3.color;
      else {
        const r4 = t3.hasOwnProperty("color") ? t3.color : t3.color = new e.Color();
        o3 === r4._input && "object" != typeof o3 || r4.set(r4._input = o3);
      }
      let i3 = this.orientation || fe;
      if (i3 !== t3._orientation) {
        let e2 = n2.uTroikaOrient.value;
        i3 = i3.replace(/[^-+xyz]/g, "");
        let r4 = i3 !== fe && i3.match(/^([-+])([xyz])([-+])([xyz])$/);
        if (r4) {
          let [, t4, n3, a3, o4] = r4;
          se.set(0, 0, 0)[n3] = "-" === t4 ? 1 : -1, le.set(0, 0, 0)[o4] = "-" === a3 ? -1 : 1, ie.lookAt(ue, se.cross(le), le), e2.setFromMatrix4(ie);
        } else e2.identity();
        t3._orientation = i3;
      }
    }
    _parsePercent(e2) {
      if ("string" == typeof e2) {
        let t3 = e2.match(/^(-?[\d.]+)%$/), r3 = t3 ? parseFloat(t3[1]) : NaN;
        e2 = (isNaN(r3) ? 0 : r3 / 100) * this.fontSize;
      }
      return e2;
    }
    localPositionToTextCoords(t3, r3 = new e.Vector2()) {
      r3.copy(t3);
      const n2 = this.curveRadius;
      return n2 && (r3.x = Math.atan2(t3.x, Math.abs(n2) - Math.abs(t3.z)) * Math.abs(n2)), r3;
    }
    worldPositionToTextCoords(t3, r3 = new e.Vector2()) {
      return se.copy(t3), this.localPositionToTextCoords(this.worldToLocal(se), r3);
    }
    raycast(e2, t3) {
      const { textRenderInfo: r3, curveRadius: n2 } = this;
      if (r3) {
        const a2 = r3.blockBounds, o3 = n2 ? ve() : he(), i3 = o3.geometry, { position: s2, uv: l2 } = i3.attributes;
        for (let e3 = 0; e3 < l2.count; e3++) {
          let t4 = a2[0] + l2.getX(e3) * (a2[2] - a2[0]);
          const r4 = a2[1] + l2.getY(e3) * (a2[3] - a2[1]);
          let o4 = 0;
          n2 && (o4 = n2 - Math.cos(t4 / n2) * n2, t4 = Math.sin(t4 / n2) * n2), s2.setXYZ(e3, t4, r4, o4);
        }
        i3.boundingSphere = this.geometry.boundingSphere, i3.boundingBox = this.geometry.boundingBox, o3.matrixWorld = this.matrixWorld, o3.material.side = this.material.side, ce.length = 0, o3.raycast(e2, ce);
        for (let e3 = 0; e3 < ce.length; e3++) ce[e3].object = this, t3.push(ce[e3]);
      }
    }
    copy(e2) {
      const t3 = this.geometry;
      return super.copy(e2), this.geometry = t3, ye.forEach((t4) => {
        this[t4] = e2[t4];
      }), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  be.forEach((e2) => {
    const t3 = "_private_" + e2;
    Object.defineProperty(me.prototype, e2, { get() {
      return this[t3];
    }, set(e3) {
      e3 !== this[t3] && (this[t3] = e3, this._needsSync = true);
    } });
  }), /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap();
  const xe = { d: "", c: "", p: "" }, ke = (e2, t3) => {
    e2 = e2.replace(/%%(.)/g, (e3, t4) => xe[t4] || t4);
    const r3 = t3 == null ? void 0 : t3.encoding;
    let n2, a2 = r3 instanceof TextDecoder ? r3 : void 0, o3 = "";
    const i3 = [], s2 = (e3) => {
      o3 && (i3.push(o3), o3 = ""), i3.push(e3);
    };
    for (let t4 = 0; t4 < e2.length; t4++) switch (n2 = e2[t4]) {
      default:
        o3 += n2;
        break;
      case "\\":
        switch (n2 = e2[++t4]) {
          default:
            o3 += n2;
            break;
          case "P":
            o3 += "\n";
            break;
          case "f":
          case "F": {
            let r4 = "";
            for (; n2 = e2[++t4]; ) {
              if (";" === n2) {
                s2({ f: r4 });
                break;
              }
              if ("|" === n2) {
                const n3 = { f: r4 }, a3 = e2.indexOf(";", ++t4);
                for (const r5 of e2.slice(t4, a3).split("|")) n3[r5[0]] = +r5.slice(1);
                t4 = a3, s2(n3);
                break;
              }
              r4 += "\\" === n2 ? e2[++t4] : n2;
            }
            break;
          }
          case "S": {
            let r4, a3 = "", o4 = "";
            for (; n2 = e2[++t4]; ) {
              if (";" === n2) {
                r4 && s2({ S: [a3, r4, o4] });
                break;
              }
              "\\" === n2 ? r4 ? o4 += e2[++t4] : a3 += e2[++t4] : r4 ? o4 += n2 : "^" === n2 || "/" === n2 || "#" === n2 ? r4 = n2 : a3 += n2;
            }
            break;
          }
          case "H":
          case "W":
            const i4 = ++t4, [, l2, c2] = e2.slice(i4, t4 = e2.indexOf(";", t4)).match(/^(\d*(?:\.\d+)?)(\D*)$/);
            s2({ [n2]: [+l2, c2] });
            break;
          case "Q":
          case "A":
          case "C":
          case "T": {
            const r4 = ++t4;
            s2({ [n2]: +e2.slice(r4, t4 = e2.indexOf(";", t4)) });
            break;
          }
          case "L":
          case "O":
          case "K":
            s2({ [n2]: 1 });
            break;
          case "l":
          case "o":
          case "k":
            s2({ [n2.toUpperCase()]: 0 });
            break;
          case "U":
          case "u":
            "+" === e2[t4 + 1] ? (o3 += String.fromCodePoint(parseInt(e2.substr(t4 + 2, 4), 16)), t4 += 5) : o3 += n2;
            break;
          case "M":
          case "m":
            r3 ? "+" === e2[t4 + 1] && "1" === e2[t4 + 2] ? (o3 += (a2 = a2 || new TextDecoder(r3)).decode(new Uint8Array([parseInt(e2.substr(t4 + 3, 2), 16), parseInt(e2.substr(t4 + 5, 2), 16)])), t4 += 6) : o3 += n2 : o3 += "\\" + n2;
        }
        break;
      case "{": {
        let r4 = 1;
        const a3 = t4;
        for (; n2 = e2[++t4]; ) if ("{" === n2) r4++;
        else if ("}" === n2) {
          if (0 == --r4) {
            s2(ke(e2.slice(a3 + 1, t4)));
            break;
          }
        } else "\\" === n2 && t4++;
        break;
      }
    }
    return o3 && i3.push(o3), i3;
  }, we = "function" == typeof atob, Se = "function" == typeof Buffer, Ue = "function" == typeof TextDecoder ? new TextDecoder() : void 0, Te = ((e2) => {
    let t3 = {};
    return e2.forEach((e3, r3) => t3[e3] = r3), t3;
  })(("function" == typeof TextEncoder && new TextEncoder(), Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="))), _e = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, Ee = String.fromCharCode.bind(String), Fe = "function" == typeof Uint8Array.from ? Uint8Array.from.bind(Uint8Array) : (e2) => new Uint8Array(Array.prototype.slice.call(e2, 0)), Ce = (e2) => e2.replace(/[^A-Za-z0-9\+\/]/g, ""), De = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, Ae = (e2) => {
    switch (e2.length) {
      case 4:
        var t3 = ((7 & e2.charCodeAt(0)) << 18 | (63 & e2.charCodeAt(1)) << 12 | (63 & e2.charCodeAt(2)) << 6 | 63 & e2.charCodeAt(3)) - 65536;
        return Ee(55296 + (t3 >>> 10)) + Ee(56320 + (1023 & t3));
      case 3:
        return Ee((15 & e2.charCodeAt(0)) << 12 | (63 & e2.charCodeAt(1)) << 6 | 63 & e2.charCodeAt(2));
      default:
        return Ee((31 & e2.charCodeAt(0)) << 6 | 63 & e2.charCodeAt(1));
    }
  }, Me = we ? (e2) => atob(Ce(e2)) : Se ? (e2) => Buffer.from(e2, "base64").toString("binary") : (e2) => {
    if (e2 = e2.replace(/\s+/g, ""), !_e.test(e2)) throw new TypeError("malformed base64.");
    e2 += "==".slice(2 - (3 & e2.length));
    let t3, r3, n2, a2 = "";
    for (let o3 = 0; o3 < e2.length; ) t3 = Te[e2.charAt(o3++)] << 18 | Te[e2.charAt(o3++)] << 12 | (r3 = Te[e2.charAt(o3++)]) << 6 | (n2 = Te[e2.charAt(o3++)]), a2 += 64 === r3 ? Ee(t3 >> 16 & 255) : 64 === n2 ? Ee(t3 >> 16 & 255, t3 >> 8 & 255) : Ee(t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
    return a2;
  }, Pe = Se ? (e2) => Fe(Buffer.from(e2, "base64")) : (e2) => Fe(Me(e2).split("").map((e3) => e3.charCodeAt(0))), Ie = Se ? (e2) => Buffer.from(e2, "base64").toString("utf8") : Ue ? (e2) => Ue.decode(Pe(e2)) : (e2) => Me(e2).replace(De, Ae), Le = (e2) => Ie(Ce(e2.replace(/[-_]/g, (e3) => "-" == e3 ? "+" : "/")));
  class Oe {
    constructor(e2) {
      this._pointer = 0, this._eof = false, this._data = e2;
    }
    next() {
      if (!this.hasNext()) throw this._eof ? new Error("Cannot call 'next' after EOF group has been read") : new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
      const e2 = { code: parseInt(this._data[this._pointer]) };
      return this._pointer++, e2.value = Re(e2.code, this._data[this._pointer].trim()), this._pointer++, 0 === e2.code && "EOF" === e2.value && (this._eof = true), this.lastReadGroup = e2, e2;
    }
    peek() {
      if (!this.hasNext()) throw this._eof ? new Error("Cannot call 'next' after EOF group has been read") : new Error("Unexpected end of input: EOF group not read before end of file. Ended on code " + this._data[this._pointer]);
      const e2 = { code: parseInt(this._data[this._pointer]) };
      return e2.value = Re(e2.code, this._data[this._pointer + 1].trim()), e2;
    }
    rewind(e2 = 1) {
      this._pointer = this._pointer - 2 * e2;
    }
    hasNext() {
      return !(this._eof || this._pointer > this._data.length - 2);
    }
    isEOF() {
      return this._eof;
    }
  }
  function Re(e2, t3) {
    return e2 <= 9 ? t3 : e2 >= 10 && e2 <= 59 ? parseFloat(t3) : e2 >= 60 && e2 <= 99 ? parseInt(t3) : e2 >= 100 && e2 <= 109 ? t3 : e2 >= 110 && e2 <= 149 ? parseFloat(t3) : e2 >= 160 && e2 <= 179 ? parseInt(t3) : e2 >= 210 && e2 <= 239 ? parseFloat(t3) : e2 >= 270 && e2 <= 289 ? parseInt(t3) : e2 >= 290 && e2 <= 299 ? function(e3) {
      if ("0" === e3) return false;
      if ("1" === e3) return true;
      throw TypeError("String '" + e3 + "' cannot be cast to Boolean type");
    }(t3) : e2 >= 300 && e2 <= 369 ? t3 : e2 >= 370 && e2 <= 389 ? parseInt(t3) : e2 >= 390 && e2 <= 399 ? t3 : e2 >= 400 && e2 <= 409 ? parseInt(t3) : e2 >= 410 && e2 <= 419 ? t3 : e2 >= 420 && e2 <= 429 ? parseInt(t3) : e2 >= 430 && e2 <= 439 ? t3 : e2 >= 440 && e2 <= 459 ? parseInt(t3) : e2 >= 460 && e2 <= 469 ? parseFloat(t3) : e2 >= 470 && e2 <= 481 || 999 === e2 || e2 >= 1e3 && e2 <= 1009 ? t3 : e2 >= 1010 && e2 <= 1059 ? parseFloat(t3) : e2 >= 1060 && e2 <= 1071 ? parseInt(t3) : (console.log("WARNING: Group code does not have a defined type: %j", { code: e2, value: t3 }), t3);
  }
  const Be = [0, 16711680, 16776960, 65280, 65535, 255, 16711935, 16777215, 8421504, 12632256, 16711680, 16744319, 13369344, 13395558, 10027008, 10046540, 8323072, 8339263, 4980736, 4990502, 16727808, 16752511, 13382400, 13401958, 10036736, 10051404, 8331008, 8343359, 4985600, 4992806, 16744192, 16760703, 13395456, 13408614, 10046464, 10056268, 8339200, 8347455, 4990464, 4995366, 16760576, 16768895, 13408512, 13415014, 10056192, 10061132, 8347392, 8351551, 4995328, 4997670, 16776960, 16777087, 13421568, 13421670, 10000384, 10000460, 8355584, 8355647, 5000192, 5000230, 12582656, 14679935, 10079232, 11717734, 7510016, 8755276, 6258432, 7307071, 3755008, 4344870, 8388352, 12582783, 6736896, 10079334, 5019648, 7510092, 4161280, 6258495, 2509824, 3755046, 4194048, 10485631, 3394560, 8375398, 2529280, 6264908, 2064128, 5209919, 1264640, 3099686, 65280, 8388479, 52224, 6736998, 38912, 5019724, 32512, 4161343, 19456, 2509862, 65343, 8388511, 52275, 6737023, 38950, 5019743, 32543, 4161359, 19475, 2509871, 65407, 8388543, 52326, 6737049, 38988, 5019762, 32575, 4161375, 19494, 2509881, 65471, 8388575, 52377, 6737074, 39026, 5019781, 32607, 4161391, 19513, 2509890, 65535, 8388607, 52428, 6737100, 39064, 5019800, 32639, 4161407, 19532, 2509900, 49151, 8380415, 39372, 6730444, 29336, 5014936, 24447, 4157311, 14668, 2507340, 32767, 8372223, 26316, 6724044, 19608, 5010072, 16255, 4153215, 9804, 2505036, 16383, 8364031, 13260, 6717388, 9880, 5005208, 8063, 4149119, 4940, 2502476, 255, 8355839, 204, 6710988, 152, 5000344, 127, 4145023, 76, 2500172, 4129023, 10452991, 3342540, 8349388, 2490520, 6245528, 2031743, 5193599, 1245260, 3089996, 8323327, 12550143, 6684876, 10053324, 4980888, 7490712, 4128895, 6242175, 2490444, 3745356, 12517631, 14647295, 10027212, 11691724, 7471256, 8735896, 6226047, 7290751, 3735628, 4335180, 16711935, 16744447, 13369548, 13395660, 9961624, 9981080, 8323199, 8339327, 4980812, 4990540, 16711871, 16744415, 13369497, 13395634, 9961586, 9981061, 8323167, 8339311, 4980793, 4990530, 16711807, 16744383, 13369446, 13395609, 9961548, 9981042, 8323135, 8339295, 4980774, 4990521, 16711743, 16744351, 13369395, 13395583, 9961510, 9981023, 8323103, 8339279, 4980755, 4990511, 3355443, 5987163, 8684676, 11382189, 14079702, 16777215];
  function Ge(e2) {
    const t3 = {};
    e2.rewind();
    let r3 = e2.next(), n2 = r3.code;
    if (t3.x = r3.value, n2 += 10, r3 = e2.next(), r3.code != n2) throw new Error("Expected code for point value to be " + n2 + " but got " + r3.code + ".");
    return t3.y = r3.value, n2 += 10, r3 = e2.next(), r3.code != n2 ? (e2.rewind(), t3) : (t3.z = r3.value, t3);
  }
  function Ne(e2, t3, r3) {
    switch (t3.code) {
      case 0:
        e2.type = t3.value;
        break;
      case 5:
        e2.handle = t3.value;
        break;
      case 6:
        e2.lineType = t3.value;
        break;
      case 8:
        e2.layer = t3.value;
        break;
      case 48:
        e2.lineTypeScale = t3.value;
        break;
      case 60:
        e2.visible = 0 === t3.value;
        break;
      case 62:
        e2.colorIndex = t3.value, e2.color = (n2 = Math.abs(t3.value), Be[n2]);
        break;
      case 67:
        e2.inPaperSpace = 0 !== t3.value;
        break;
      case 100:
        break;
      case 101:
        for (; 0 != t3.code; ) t3 = r3.next();
        r3.rewind();
        break;
      case 330:
        e2.ownerHandle = t3.value;
        break;
      case 347:
        e2.materialObjectHandle = t3.value;
        break;
      case 370:
        e2.lineweight = t3.value;
        break;
      case 420:
        e2.color = t3.value;
        break;
      case 1e3:
        e2.extendedData = e2.extendedData || {}, e2.extendedData.customStrings = e2.extendedData.customStrings || [], e2.extendedData.customStrings.push(t3.value);
        break;
      case 1001:
        e2.extendedData = e2.extendedData || {}, e2.extendedData.applicationName = t3.value;
        break;
      default:
        return false;
    }
    var n2;
    return true;
  }
  class ze {
    constructor() {
      this.ForEntityName = "3DFACE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value, vertices: [] };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 70:
            r3.shape = 1 == (1 & t3.value), r3.hasContinuousLinetypePattern = 128 == (128 & t3.value);
            break;
          case 10:
            r3.vertices = Ve(e2, t3), t3 = e2.lastReadGroup;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  function Ve(e2, t3) {
    var r3 = [], n2 = false, a2 = false;
    for (let i3 = 0; i3 <= 4; i3++) {
      for (var o3 = {}; !e2.isEOF() && 0 !== t3.code && !a2; ) {
        switch (t3.code) {
          case 10:
          case 11:
          case 12:
          case 13:
            if (n2) {
              a2 = true;
              continue;
            }
            o3.x = t3.value, n2 = true;
            break;
          case 20:
          case 21:
          case 22:
          case 23:
            o3.y = t3.value;
            break;
          case 30:
          case 31:
          case 32:
          case 33:
            o3.z = t3.value;
            break;
          default:
            return r3;
        }
        t3 = e2.next();
      }
      r3.push(o3), n2 = false, a2 = false;
    }
    return e2.rewind(), r3;
  }
  class je {
    constructor() {
      this.ForEntityName = "ARC";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.center = Ge(e2);
            break;
          case 40:
            r3.radius = t3.value;
            break;
          case 50:
            r3.startAngle = Math.PI / 180 * t3.value;
            break;
          case 51:
            r3.endAngle = Math.PI / 180 * t3.value, r3.angleLength = r3.endAngle - r3.startAngle;
            break;
          case 210:
            r3.extrusionDirectionX = t3.value;
            break;
          case 220:
            r3.extrusionDirectionY = t3.value;
            break;
          case 230:
            r3.extrusionDirectionZ = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class We {
    constructor() {
      this.ForEntityName = "ATTDEF";
    }
    parseEntity(e2, t3) {
      var r3 = { type: t3.value, scale: 1, textStyle: "STANDARD" };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 1:
            r3.text = t3.value;
            break;
          case 2:
            r3.tag = t3.value;
            break;
          case 3:
            r3.prompt = t3.value;
            break;
          case 7:
            r3.textStyle = t3.value;
            break;
          case 10:
            r3.startPoint = Ge(e2);
            break;
          case 11:
            r3.endPoint = Ge(e2);
            break;
          case 39:
            r3.thickness = t3.value;
            break;
          case 40:
            r3.textHeight = t3.value;
            break;
          case 41:
            r3.scale = t3.value;
            break;
          case 50:
            r3.rotation = t3.value;
            break;
          case 51:
            r3.obliqueAngle = t3.value;
            break;
          case 70:
            r3.invisible = !!(1 & t3.value), r3.constant = !!(2 & t3.value), r3.verificationRequired = !!(4 & t3.value), r3.preset = !!(8 & t3.value);
            break;
          case 71:
            r3.backwards = !!(2 & t3.value), r3.mirrored = !!(4 & t3.value);
            break;
          case 72:
            r3.horizontalJustification = t3.value;
            break;
          case 73:
            r3.fieldLength = t3.value;
            break;
          case 74:
            r3.verticalJustification = t3.value;
            break;
          case 100:
            break;
          case 210:
            r3.extrusionDirectionX = t3.value;
            break;
          case 220:
            r3.extrusionDirectionY = t3.value;
            break;
          case 230:
            r3.extrusionDirectionZ = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class He {
    constructor() {
      this.ForEntityName = "CIRCLE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.center = Ge(e2);
            break;
          case 40:
            r3.radius = t3.value;
            break;
          case 50:
            r3.startAngle = Math.PI / 180 * t3.value;
            break;
          case 51:
            const n2 = Math.PI / 180 * t3.value;
            n2 < r3.startAngle ? r3.angleLength = n2 + 2 * Math.PI - r3.startAngle : r3.angleLength = n2 - r3.startAngle, r3.endAngle = n2;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class Xe {
    constructor() {
      this.ForEntityName = "DIMENSION";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 2:
            r3.block = t3.value;
            break;
          case 10:
            r3.anchorPoint = Ge(e2);
            break;
          case 11:
            r3.middleOfText = Ge(e2);
            break;
          case 12:
            r3.insertionPoint = Ge(e2);
            break;
          case 13:
            r3.linearOrAngularPoint1 = Ge(e2);
            break;
          case 14:
            r3.linearOrAngularPoint2 = Ge(e2);
            break;
          case 15:
            r3.diameterOrRadiusPoint = Ge(e2);
            break;
          case 16:
            r3.arcPoint = Ge(e2);
            break;
          case 70:
            r3.dimensionType = t3.value;
            break;
          case 71:
            r3.attachmentPoint = t3.value;
            break;
          case 42:
            r3.actualMeasurement = t3.value;
            break;
          case 1:
            r3.text = t3.value;
            break;
          case 50:
            r3.angle = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class qe {
    constructor() {
      this.ForEntityName = "ELLIPSE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.center = Ge(e2);
            break;
          case 11:
            r3.majorAxisEndPoint = Ge(e2);
            break;
          case 40:
            r3.axisRatio = t3.value;
            break;
          case 41:
            r3.startAngle = t3.value;
            break;
          case 42:
            r3.endAngle = t3.value;
            break;
          case 2:
            r3.name = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class Ye {
    constructor() {
      this.ForEntityName = "INSERT";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 2:
            r3.name = t3.value;
            break;
          case 41:
            r3.xScale = t3.value;
            break;
          case 42:
            r3.yScale = t3.value;
            break;
          case 43:
            r3.zScale = t3.value;
            break;
          case 10:
            r3.position = Ge(e2);
            break;
          case 50:
            r3.rotation = t3.value;
            break;
          case 70:
            r3.columnCount = t3.value;
            break;
          case 71:
            r3.rowCount = t3.value;
            break;
          case 44:
            r3.columnSpacing = t3.value;
            break;
          case 45:
            r3.rowSpacing = t3.value;
            break;
          case 210:
            r3.extrusionDirection = Ge(e2);
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class $e {
    constructor() {
      this.ForEntityName = "LINE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value, vertices: [] };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.vertices.unshift(Ge(e2));
            break;
          case 11:
            r3.vertices.push(Ge(e2));
            break;
          case 210:
            r3.extrusionDirection = Ge(e2);
            break;
          case 100:
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class Ze {
    constructor() {
      this.ForEntityName = "LWPOLYLINE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value, vertices: [] };
      let n2 = 0;
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 38:
            r3.elevation = t3.value;
            break;
          case 39:
            r3.depth = t3.value;
            break;
          case 70:
            r3.shape = 1 == (1 & t3.value), r3.hasContinuousLinetypePattern = 128 == (128 & t3.value);
            break;
          case 90:
            n2 = t3.value;
            break;
          case 10:
            r3.vertices = Ke(n2, e2);
            break;
          case 43:
            0 !== t3.value && (r3.width = t3.value);
            break;
          case 210:
            r3.extrusionDirectionX = t3.value;
            break;
          case 220:
            r3.extrusionDirectionY = t3.value;
            break;
          case 230:
            r3.extrusionDirectionZ = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  function Ke(e2, t3) {
    if (!e2 || e2 <= 0) throw Error("n must be greater than 0 verticies");
    const r3 = [];
    let n2 = false, a2 = false, o3 = t3.lastReadGroup;
    for (let i3 = 0; i3 < e2; i3++) {
      const e3 = {};
      for (; !t3.isEOF() && 0 !== o3.code && !a2; ) {
        switch (o3.code) {
          case 10:
            if (n2) {
              a2 = true;
              continue;
            }
            e3.x = o3.value, n2 = true;
            break;
          case 20:
            e3.y = o3.value;
            break;
          case 30:
            e3.z = o3.value;
            break;
          case 40:
            e3.startWidth = o3.value;
            break;
          case 41:
            e3.endWidth = o3.value;
            break;
          case 42:
            0 != o3.value && (e3.bulge = o3.value);
            break;
          default:
            return t3.rewind(), n2 && r3.push(e3), t3.rewind(), r3;
        }
        o3 = t3.next();
      }
      r3.push(e3), n2 = false, a2 = false;
    }
    return t3.rewind(), r3;
  }
  class Qe {
    constructor() {
      this.ForEntityName = "MTEXT";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 3:
          case 1:
            r3.text ? r3.text += t3.value : r3.text = t3.value;
            break;
          case 10:
            r3.position = Ge(e2);
            break;
          case 11:
            r3.directionVector = Ge(e2);
            break;
          case 40:
            r3.height = t3.value;
            break;
          case 41:
            r3.width = t3.value;
            break;
          case 50:
            r3.rotation = t3.value;
            break;
          case 71:
            r3.attachmentPoint = t3.value;
            break;
          case 72:
            r3.drawingDirection = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class Je {
    constructor() {
      this.ForEntityName = "POINT";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.position = Ge(e2);
            break;
          case 39:
            r3.thickness = t3.value;
            break;
          case 210:
            r3.extrusionDirection = Ge(e2);
            break;
          case 100:
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class et {
    constructor() {
      this.ForEntityName = "VERTEX";
    }
    parseEntity(e2, t3) {
      var r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.x = t3.value;
            break;
          case 20:
            r3.y = t3.value;
            break;
          case 30:
            r3.z = t3.value;
            break;
          case 40:
          case 41:
          case 50:
            break;
          case 42:
            0 != t3.value && (r3.bulge = t3.value);
            break;
          case 70:
            r3.curveFittingVertex = 0 != (1 & t3.value), r3.curveFitTangent = 0 != (2 & t3.value), r3.splineVertex = 0 != (8 & t3.value), r3.splineControlPoint = 0 != (16 & t3.value), r3.threeDPolylineVertex = 0 != (32 & t3.value), r3.threeDPolylineMesh = 0 != (64 & t3.value), r3.polyfaceMeshVertex = 0 != (128 & t3.value);
            break;
          case 71:
            r3.faceA = t3.value;
            break;
          case 72:
            r3.faceB = t3.value;
            break;
          case 73:
            r3.faceC = t3.value;
            break;
          case 74:
            r3.faceD = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class tt {
    constructor() {
      this.ForEntityName = "POLYLINE";
    }
    parseEntity(e2, t3) {
      var r3 = { type: t3.value, vertices: [] };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
          case 20:
          case 30:
          case 40:
          case 41:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
            break;
          case 39:
            r3.thickness = t3.value;
            break;
          case 70:
            r3.shape = 0 != (1 & t3.value), r3.includesCurveFitVertices = 0 != (2 & t3.value), r3.includesSplineFitVertices = 0 != (4 & t3.value), r3.is3dPolyline = 0 != (8 & t3.value), r3.is3dPolygonMesh = 0 != (16 & t3.value), r3.is3dPolygonMeshClosed = 0 != (32 & t3.value), r3.isPolyfaceMesh = 0 != (64 & t3.value), r3.hasContinuousLinetypePattern = 0 != (128 & t3.value);
            break;
          case 210:
            r3.extrusionDirection = Ge(e2);
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3.vertices = function(e3, t4) {
        const r4 = new et(), n2 = [];
        for (; !e3.isEOF(); ) if (0 === t4.code) {
          if ("VERTEX" === t4.value) n2.push(r4.parseEntity(e3, t4)), t4 = e3.lastReadGroup;
          else if ("SEQEND" === t4.value) {
            rt(e3, t4);
            break;
          }
        }
        return n2;
      }(e2, t3), r3;
    }
  }
  function rt(e2, t3) {
    const r3 = { type: t3.value };
    for (t3 = e2.next(); !e2.isEOF() && 0 != t3.code; ) Ne(r3, t3, e2), t3 = e2.next();
    return r3;
  }
  class nt {
    constructor() {
      this.ForEntityName = "SOLID";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value, points: [] };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.points[0] = Ge(e2);
            break;
          case 11:
            r3.points[1] = Ge(e2);
            break;
          case 12:
            r3.points[2] = Ge(e2);
            break;
          case 13:
            r3.points[3] = Ge(e2);
            break;
          case 210:
            r3.extrusionDirection = Ge(e2);
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class at {
    constructor() {
      this.ForEntityName = "SPLINE";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.controlPoints || (r3.controlPoints = []), r3.controlPoints.push(Ge(e2));
            break;
          case 11:
            r3.fitPoints || (r3.fitPoints = []), r3.fitPoints.push(Ge(e2));
            break;
          case 12:
            r3.startTangent = Ge(e2);
            break;
          case 13:
            r3.endTangent = Ge(e2);
            break;
          case 40:
            r3.knotValues || (r3.knotValues = []), r3.knotValues.push(t3.value);
            break;
          case 70:
            0 != (1 & t3.value) && (r3.closed = true), 0 != (2 & t3.value) && (r3.periodic = true), 0 != (4 & t3.value) && (r3.rational = true), 0 != (8 & t3.value) && (r3.planar = true), 0 != (16 & t3.value) && (r3.planar = true, r3.linear = true);
            break;
          case 71:
            r3.degreeOfSplineCurve = t3.value;
            break;
          case 72:
            r3.numberOfKnots = t3.value;
            break;
          case 73:
            r3.numberOfControlPoints = t3.value;
            break;
          case 74:
            r3.numberOfFitPoints = t3.value;
            break;
          case 210:
            r3.normalVector = Ge(e2);
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  class ot {
    constructor() {
      this.ForEntityName = "TEXT";
    }
    parseEntity(e2, t3) {
      const r3 = { type: t3.value };
      for (t3 = e2.next(); !e2.isEOF() && 0 !== t3.code; ) {
        switch (t3.code) {
          case 10:
            r3.startPoint = Ge(e2);
            break;
          case 11:
            r3.endPoint = Ge(e2);
            break;
          case 40:
            r3.textHeight = t3.value;
            break;
          case 41:
            r3.xScale = t3.value;
            break;
          case 50:
            r3.rotation = t3.value;
            break;
          case 1:
            r3.text = t3.value;
            break;
          case 72:
            r3.halign = t3.value;
            break;
          case 73:
            r3.valign = t3.value;
            break;
          default:
            Ne(r3, t3, e2);
        }
        t3 = e2.next();
      }
      return r3;
    }
  }
  var it = n(43), st = n.n(it);
  function lt(e2, t3, r3) {
    return e2.code === t3 && e2.value === r3;
  }
  function ct(e2) {
    st().debug("unhandled group " + ut(e2));
  }
  function ut(e2) {
    return e2.code + ":" + e2.value;
  }
  st().setLevel("error");
  const ft = class {
    constructor() {
      var e2;
      this._entityHandlers = {}, (e2 = this).registerEntityHandler(ze), e2.registerEntityHandler(je), e2.registerEntityHandler(We), e2.registerEntityHandler(He), e2.registerEntityHandler(Xe), e2.registerEntityHandler(qe), e2.registerEntityHandler(Ye), e2.registerEntityHandler($e), e2.registerEntityHandler(Ze), e2.registerEntityHandler(Qe), e2.registerEntityHandler(Je), e2.registerEntityHandler(tt), e2.registerEntityHandler(nt), e2.registerEntityHandler(at), e2.registerEntityHandler(ot);
    }
    parse(e2) {
      return "string" == typeof e2 ? this._parse(e2) : (console.error("Cannot read dxf source of type `" + typeof e2), null);
    }
    registerEntityHandler(e2) {
      const t3 = new e2();
      this._entityHandlers[t3.ForEntityName] = t3;
    }
    parseSync(e2) {
      return this.parse(e2);
    }
    parseStream(e2) {
      let t3 = "";
      const r3 = this;
      return new Promise((n2, a2) => {
        e2.on("data", (e3) => {
          t3 += e3;
        }), e2.on("end", () => {
          try {
            n2(r3._parse(t3));
          } catch (e3) {
            a2(e3);
          }
        }), e2.on("error", (e3) => {
          a2(e3);
        });
      });
    }
    _parse(e2) {
      const t3 = {};
      let r3 = 0;
      const n2 = e2.split(/\r\n|\r|\n/g), a2 = new Oe(n2);
      if (!a2.hasNext()) throw Error("Empty file");
      const o3 = this;
      let i3;
      function s2() {
        let e3 = null, t4 = null;
        const r4 = {};
        for (i3 = a2.next(); ; ) {
          if (lt(i3, 0, "ENDSEC")) {
            e3 && (r4[e3] = t4);
            break;
          }
          9 === i3.code ? (e3 && (r4[e3] = t4), e3 = i3.value) : 10 === i3.code ? t4 = { x: i3.value } : 20 === i3.code ? t4.y = i3.value : 30 === i3.code ? t4.z = i3.value : t4 = i3.value, i3 = a2.next();
        }
        return i3 = a2.next(), r4;
      }
      function l2() {
        const e3 = {};
        for (i3 = a2.next(); "EOF" !== i3.value && !lt(i3, 0, "ENDSEC"); ) if (lt(i3, 0, "BLOCK")) {
          st().debug("block {");
          const t4 = c2();
          st().debug("}"), g2(t4), t4.name ? e3[t4.name] = t4 : st().error('block with handle "' + t4.handle + '" is missing a name.');
        } else ct(i3), i3 = a2.next();
        return e3;
      }
      function c2() {
        const e3 = {};
        for (i3 = a2.next(); "EOF" !== i3.value; ) {
          switch (i3.code) {
            case 1:
              e3.xrefPath = i3.value, i3 = a2.next();
              break;
            case 2:
              e3.name = i3.value, i3 = a2.next();
              break;
            case 3:
              e3.name2 = i3.value, i3 = a2.next();
              break;
            case 5:
              e3.handle = i3.value, i3 = a2.next();
              break;
            case 8:
              e3.layer = i3.value, i3 = a2.next();
              break;
            case 10:
              e3.position = p2(i3), i3 = a2.next();
              break;
            case 67:
              e3.paperSpace = !(!i3.value || 1 != i3.value), i3 = a2.next();
              break;
            case 70:
              0 != i3.value && (e3.type = i3.value), i3 = a2.next();
              break;
            case 100:
              i3 = a2.next();
              break;
            case 330:
              e3.ownerHandle = i3.value, i3 = a2.next();
              break;
            case 0:
              if ("ENDBLK" == i3.value) break;
              e3.entities = v2(true);
              break;
            default:
              ct(i3), i3 = a2.next();
          }
          if (lt(i3, 0, "ENDBLK")) {
            i3 = a2.next();
            break;
          }
        }
        return e3;
      }
      function u2() {
        const e3 = {};
        for (i3 = a2.next(); "EOF" !== i3.value && !lt(i3, 0, "ENDSEC"); ) lt(i3, 0, "TABLE") ? (i3 = a2.next(), h2[i3.value] ? (st().debug(i3.value + " Table {"), e3[h2[i3.value].tableName] = d2(i3), st().debug("}")) : st().debug("Unhandled Table " + i3.value)) : i3 = a2.next();
        return i3 = a2.next(), e3;
      }
      const f2 = "ENDTAB";
      function d2(e3) {
        const t4 = h2[e3.value], r4 = {};
        let n3 = 0;
        for (i3 = a2.next(); !lt(i3, 0, f2); ) switch (i3.code) {
          case 5:
            r4.handle = i3.value, i3 = a2.next();
            break;
          case 330:
            r4.ownerHandle = i3.value, i3 = a2.next();
            break;
          case 100:
            "AcDbSymbolTable" === i3.value || ct(i3), i3 = a2.next();
            break;
          case 70:
            n3 = i3.value, i3 = a2.next();
            break;
          case 0:
            i3.value === t4.dxfSymbolName ? r4[t4.tableRecordsProperty] = t4.parseTableRecords() : (ct(i3), i3 = a2.next());
            break;
          default:
            ct(i3), i3 = a2.next();
        }
        const o4 = r4[t4.tableRecordsProperty];
        if (o4) {
          let e4 = o4.constructor === Array ? o4.length : "object" == typeof o4 ? Object.keys(o4).length : void 0;
          n3 !== e4 && st().warn("Parsed " + e4 + " " + t4.dxfSymbolName + "'s but expected " + n3);
        }
        return i3 = a2.next(), r4;
      }
      const h2 = { VPORT: { tableRecordsProperty: "viewPorts", tableName: "viewPort", dxfSymbolName: "VPORT", parseTableRecords: function() {
        const e3 = [];
        let t4 = {};
        for (st().debug("ViewPort {"), i3 = a2.next(); !lt(i3, 0, f2); ) switch (i3.code) {
          case 2:
            t4.name = i3.value, i3 = a2.next();
            break;
          case 10:
            t4.lowerLeftCorner = p2(i3), i3 = a2.next();
            break;
          case 11:
            t4.upperRightCorner = p2(i3), i3 = a2.next();
            break;
          case 12:
            t4.center = p2(i3), i3 = a2.next();
            break;
          case 13:
            t4.snapBasePoint = p2(i3), i3 = a2.next();
            break;
          case 14:
            t4.snapSpacing = p2(i3), i3 = a2.next();
            break;
          case 15:
            t4.gridSpacing = p2(i3), i3 = a2.next();
            break;
          case 16:
            t4.viewDirectionFromTarget = p2(i3), i3 = a2.next();
            break;
          case 17:
            t4.viewTarget = p2(i3), i3 = a2.next();
            break;
          case 42:
            t4.lensLength = i3.value, i3 = a2.next();
            break;
          case 43:
            t4.frontClippingPlane = i3.value, i3 = a2.next();
            break;
          case 44:
            t4.backClippingPlane = i3.value, i3 = a2.next();
            break;
          case 45:
            t4.viewHeight = i3.value, i3 = a2.next();
            break;
          case 50:
            t4.snapRotationAngle = i3.value, i3 = a2.next();
            break;
          case 51:
            t4.viewTwistAngle = i3.value, i3 = a2.next();
            break;
          case 79:
            t4.orthographicType = i3.value, i3 = a2.next();
            break;
          case 110:
          case 110:
            t4.ucsOrigin = p2(i3), i3 = a2.next();
            break;
          case 111:
            t4.ucsXAxis = p2(i3), i3 = a2.next();
            break;
          case 112:
            t4.ucsYAxis = p2(i3), i3 = a2.next();
            break;
          case 281:
            t4.renderMode = i3.value, i3 = a2.next();
            break;
          case 281:
            t4.defaultLightingType = i3.value, i3 = a2.next();
            break;
          case 292:
            t4.defaultLightingOn = i3.value, i3 = a2.next();
            break;
          case 330:
            t4.ownerHandle = i3.value, i3 = a2.next();
            break;
          case 63:
          case 421:
          case 431:
            t4.ambientColor = i3.value, i3 = a2.next();
            break;
          case 0:
            "VPORT" === i3.value && (st().debug("}"), e3.push(t4), st().debug("ViewPort {"), t4 = {}, i3 = a2.next());
            break;
          default:
            ct(i3), i3 = a2.next();
        }
        return st().debug("}"), e3.push(t4), e3;
      } }, LTYPE: { tableRecordsProperty: "lineTypes", tableName: "lineType", dxfSymbolName: "LTYPE", parseTableRecords: function() {
        const e3 = {};
        let t4, r4 = {}, n3 = 0;
        for (st().debug("LType {"), i3 = a2.next(); !lt(i3, 0, "ENDTAB"); ) switch (i3.code) {
          case 2:
            r4.name = i3.value, t4 = i3.value, i3 = a2.next();
            break;
          case 3:
            r4.description = i3.value, i3 = a2.next();
            break;
          case 73:
            n3 = i3.value, n3 > 0 && (r4.pattern = []), i3 = a2.next();
            break;
          case 40:
            r4.patternLength = i3.value, i3 = a2.next();
            break;
          case 49:
            r4.pattern.push(i3.value), i3 = a2.next();
            break;
          case 0:
            st().debug("}"), n3 > 0 && n3 !== r4.pattern.length && st().warn("lengths do not match on LTYPE pattern"), e3[t4] = r4, r4 = {}, st().debug("LType {"), i3 = a2.next();
            break;
          default:
            i3 = a2.next();
        }
        return st().debug("}"), e3[t4] = r4, e3;
      } }, LAYER: { tableRecordsProperty: "layers", tableName: "layer", dxfSymbolName: "LAYER", parseTableRecords: function() {
        const e3 = {};
        let t4, r4 = {};
        for (st().debug("Layer {"), i3 = a2.next(); !lt(i3, 0, "ENDTAB"); ) switch (i3.code) {
          case 2:
            r4.name = i3.value, t4 = i3.value, i3 = a2.next();
            break;
          case 62:
            r4.visible = i3.value >= 0, r4.colorIndex = Math.abs(i3.value), r4.color = (n3 = r4.colorIndex, Be[n3]), i3 = a2.next();
            break;
          case 70:
            r4.frozen = 0 != (1 & i3.value) || 0 != (2 & i3.value), i3 = a2.next();
            break;
          case 0:
            "LAYER" === i3.value && (st().debug("}"), e3[t4] = r4, st().debug("Layer {"), r4 = {}, t4 = void 0, i3 = a2.next());
            break;
          default:
            ct(i3), i3 = a2.next();
        }
        var n3;
        return st().debug("}"), e3[t4] = r4, e3;
      } } };
      function v2(e3) {
        const t4 = [], r4 = e3 ? "ENDBLK" : "ENDSEC";
        for (e3 || (i3 = a2.next()); ; ) if (0 === i3.code) {
          if (i3.value === r4) break;
          const e4 = o3._entityHandlers[i3.value];
          if (null == e4) {
            st().warn("Unhandled entity " + i3.value), i3 = a2.next();
            continue;
          }
          {
            st().debug(i3.value + " {");
            const r5 = e4.parseEntity(a2, i3);
            i3 = a2.lastReadGroup, st().debug("}"), g2(r5), t4.push(r5);
          }
        } else i3 = a2.next();
        return "ENDSEC" == r4 && (i3 = a2.next()), t4;
      }
      function p2(e3) {
        const t4 = {};
        let r4 = e3.code;
        if (t4.x = e3.value, r4 += 10, (e3 = a2.next()).code != r4) throw new Error("Expected code for point value to be " + r4 + " but got " + e3.code + ".");
        return t4.y = e3.value, r4 += 10, (e3 = a2.next()).code != r4 ? (a2.rewind(), t4) : (t4.z = e3.value, t4);
      }
      function g2(e3) {
        if (!e3) throw new TypeError("entity cannot be undefined or null");
        e3.handle || (e3.handle = r3++);
      }
      return function() {
        for (i3 = a2.next(); !a2.isEOF(); ) if (0 === i3.code && "SECTION" === i3.value) {
          if (i3 = a2.next(), 2 !== i3.code) {
            console.error("Unexpected code %s after 0:SECTION", ut(i3)), i3 = a2.next();
            continue;
          }
          "HEADER" === i3.value ? (st().debug("> HEADER"), t3.header = s2(), st().debug("<")) : "BLOCKS" === i3.value ? (st().debug("> BLOCKS"), t3.blocks = l2(), st().debug("<")) : "ENTITIES" === i3.value ? (st().debug("> ENTITIES"), t3.entities = v2(false), st().debug("<")) : "TABLES" === i3.value ? (st().debug("> TABLES"), t3.tables = u2(), st().debug("<")) : "EOF" === i3.value ? st().debug("EOF") : st().warn("Skipping section '%s'", i3.value);
        } else i3 = a2.next();
      }(), t3;
    }
  }, dt = (e2, t3, r3, n2, a2) => {
    const o3 = r3.length, i3 = r3[0].length;
    if (e2 < 0 || e2 > 1) throw new Error("t out of bounds [0,1]: " + e2);
    if (t3 < 1) throw new Error("degree must be at least 1 (linear)");
    if (t3 > o3 - 1) throw new Error("degree must be less than or equal to point count - 1");
    if (!a2) {
      a2 = [];
      for (let e3 = 0; e3 < o3; e3++) a2[e3] = 1;
    }
    if (n2) {
      if (n2.length !== o3 + t3 + 1) throw new Error("bad knot vector length");
    } else {
      n2 = [];
      for (let e3 = 0; e3 < o3 + t3 + 1; e3++) n2[e3] = e3;
    }
    const s2 = [t3, n2.length - 1 - t3], l2 = n2[s2[0]], c2 = n2[s2[1]];
    let u2;
    for (e2 = e2 * (c2 - l2) + l2, e2 = Math.max(e2, l2), e2 = Math.min(e2, c2), u2 = s2[0]; u2 < s2[1] && !(e2 >= n2[u2] && e2 <= n2[u2 + 1]); u2++) ;
    const f2 = [];
    for (let e3 = 0; e3 < o3; e3++) {
      f2[e3] = [];
      for (let t4 = 0; t4 < i3; t4++) f2[e3][t4] = r3[e3][t4] * a2[e3];
      f2[e3][i3] = a2[e3];
    }
    let d2;
    for (let r4 = 1; r4 <= t3 + 1; r4++) for (let a3 = u2; a3 > u2 - t3 - 1 + r4; a3--) {
      d2 = (e2 - n2[a3]) / (n2[a3 + t3 + 1 - r4] - n2[a3]);
      for (let e3 = 0; e3 < i3 + 1; e3++) f2[a3][e3] = (1 - d2) * f2[a3 - 1][e3] + d2 * f2[a3][e3];
    }
    const h2 = [];
    for (let e3 = 0; e3 < i3; e3++) h2[e3] = (v2 = f2[u2][e3] / f2[u2][i3], void 0 === (p2 = -9) || 0 == +p2 ? Math.round(v2) : (v2 = +v2, p2 = +p2, isNaN(v2) || "number" != typeof p2 || p2 % 1 != 0 ? NaN : (v2 = v2.toString().split("e"), +((v2 = (v2 = Math.round(+(v2[0] + "e" + (v2[1] ? +v2[1] - p2 : -p2)))).toString().split("e"))[0] + "e" + (v2[1] ? +v2[1] + p2 : p2)))));
    var v2, p2;
    return h2;
  };
  var ht = n(939);
  const vt = { Math: {} };
  function pt(t3, r3, n2, a2) {
    var o3, i3, s2, l2, c2, u2, f2, d2, h2, v2 = {};
    v2.startPoint = l2 = t3 ? new e.Vector2(t3.x, t3.y) : new e.Vector2(0, 0), v2.endPoint = c2 = r3 ? new e.Vector2(r3.x, r3.y) : new e.Vector2(1, 0), v2.bulge = n2 = n2 || 1, u2 = 4 * Math.atan(n2), f2 = l2.distanceTo(c2) / 2 / Math.sin(u2 / 2), s2 = vt.Math.polar(t3, f2, vt.Math.angle2(l2, c2) + (Math.PI / 2 - u2 / 2)), v2.segments = a2 = a2 || Math.max(Math.abs(Math.ceil(u2 / (Math.PI / 18))), 6), d2 = vt.Math.angle2(s2, l2), h2 = u2 / a2;
    var p2 = [];
    for (p2.push(new e.Vector3(l2.x, l2.y, 0)), i3 = 1; i3 <= a2 - 1; i3++) o3 = vt.Math.polar(s2, Math.abs(f2), d2 + h2 * i3), p2.push(new e.Vector3(o3.x, o3.y, 0));
    return p2;
  }
  vt.Math.angle2 = function(t3, r3) {
    var n2 = new e.Vector2(t3.x, t3.y), a2 = new e.Vector2(r3.x, r3.y);
    return a2.sub(n2), a2.normalize(), a2.y < 0 ? -Math.acos(a2.x) : Math.acos(a2.x);
  }, vt.Math.polar = function(e2, t3, r3) {
    var n2 = {};
    return n2.x = e2.x + t3 * Math.cos(r3), n2.y = e2.y + t3 * Math.sin(r3), n2;
  };
  class gt extends e.Loader {
    constructor(e2) {
      super(e2), this.font = null, this.enableLayer = false, this.defaultColor = 0, this.enableUnitConversion = false;
    }
    setFont(e2) {
      return this.font = e2, this;
    }
    setEnableLayer(e2) {
      return this.enableLayer = e2, this;
    }
    setDefaultColor(e2) {
      return this.defaultColor = e2, this;
    }
    setConsumeUnits(e2) {
      this.enableUnitConversion = !!e2;
    }
    load(t3, r3, n2, a2) {
      var o3, i3 = this;
      try {
        o3 = new e.XHRLoader(i3.manager);
      } catch {
        o3 = new e.FileLoader(i3.manager);
      }
      o3.setPath(i3.path);
      const s2 = function(e2) {
        if (e2) {
          const t4 = e2.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
          if (t4 && t4.length > 0) {
            const r4 = t4[1], n3 = e2.replace("data:" + r4 + ";", "").split(",");
            if (n3 && 2 === n3.length && "base64" === n3[0]) {
              const e3 = n3[1];
              return Le(e3);
            }
          }
        }
        return null;
      }(t3);
      s2 ? i3.loadString(s2, r3, a2) : o3.load(t3, (e2) => {
        i3.loadString(e2, r3, a2);
      }, n2, a2);
    }
    loadString(e2, t3, r3) {
      try {
        t3(this.parse(e2));
      } catch (e3) {
        r3 ? r3(e3) : console.error(e3), this.manager.itemError(e3);
      }
    }
    parse(e2) {
      var t3 = new ft().parseSync(e2);
      return this.loadEntities(t3, this);
    }
    loadEntities(t3, r3 = this) {
      var _a, _b;
      const { font: n2, enableLayer: a2, defaultColor: o3, enableUnitConversion: i3 } = r3 || {};
      function s2(t4, r4) {
        var a3;
        if ("CIRCLE" === t4.type || "ARC" === t4.type) a3 = function(t5, r5) {
          var n3, a4;
          "CIRCLE" === t5.type ? a4 = (n3 = t5.startAngle || 0) + 2 * Math.PI : (n3 = t5.startAngle, a4 = t5.endAngle);
          var o5 = new e.ArcCurve(0, 0, t5.radius, n3, a4).getPoints(32), i4 = new e.BufferGeometry().setFromPoints(o5), s3 = new e.LineBasicMaterial({ color: u2(t5, r5) }), l3 = new e.Line(i4, s3);
          return l3.position.x = t5.center.x, l3.position.y = t5.center.y, l3.position.z = t5.center.z, l3;
        }(t4, r4);
        else if ("LWPOLYLINE" === t4.type || "LINE" === t4.type || "POLYLINE" === t4.type) a3 = function(t5, r5) {
          let n3 = [], a4 = u2(t5, r5);
          var o5, i4, s3, l3, c3;
          if (!t5.vertices) return console.warn("entity missing vertices.");
          if (t5.isPolyfaceMesh) n3 = function(t6, r6, n4 = true) {
            const a5 = [], o6 = [], i5 = [];
            for (const r7 of t6.vertices) if (r7.faceA || r7.faceB || r7.faceC || r7.faceD) {
              const e2 = [r7.faceA, r7.faceB, r7.faceC, r7.faceD], t7 = { indices: [], hiddenEdges: [] };
              for (const r8 of e2) {
                if (0 == r8) break;
                t7.indices.push(r8 < 0 ? -r8 - 1 : r8 - 1), t7.hiddenEdges.push(r8 < 0);
              }
              3 != t7.indices.length && 4 != t7.indices.length || o6.push(t7);
            } else a5.push(new e.Vector3(r7.x, r7.y, 0));
            const s4 = [], l4 = (e2, t7) => {
              if (s4.length > 0) {
                const r7 = s4[s4.length - 1];
                if (r7.indices[r7.indices.length - 1] == e2) return void r7.indices.push(t7);
                r7.indices[0] == r7.indices[r7.indices.length - 1] && (r7.isClosed = true);
              }
              s4.push({ indices: [e2, t7], isClosed: false });
            };
            for (const e2 of o6) if (n4) for (let t7 = 0; t7 < e2.indices.length; t7++) {
              if (e2.hiddenEdges[t7]) continue;
              const r7 = t7 < e2.indices.length - 1 ? t7 + 1 : 0;
              l4(e2.indices[t7], e2.indices[r7]);
            }
            if (n4) for (const e2 of s4) for (const t7 of e2.indices) i5.push(a5[t7]);
            return i5;
          }(t5);
          else {
            for (c3 = 0; c3 < t5.vertices.length; c3++) if (t5.vertices[c3].bulge) {
              l3 = t5.vertices[c3].bulge;
              let e2 = pt(t5.vertices[c3], c3 + 1 < t5.vertices.length ? t5.vertices[c3 + 1] : n3[0], l3);
              n3.push.apply(n3, e2);
            } else s3 = t5.vertices[c3], n3.push(new e.Vector3(s3.x, s3.y, 0));
            t5.shape && n3.push(n3[0]);
          }
          t5.lineType && (i4 = r5.tables.lineType.lineTypes[t5.lineType]), o5 = i4 && i4.pattern && 0 !== i4.pattern.length ? new e.LineDashedMaterial({ color: a4, gapSize: 4, dashSize: 4 }) : new e.LineBasicMaterial({ linewidth: 1, color: a4 });
          var f3 = new e.BufferGeometry().setFromPoints(n3);
          return new e.Line(f3, o5);
        }(t4, r4);
        else if ("TEXT" === t4.type) a3 = function(t5, r5) {
          var a4, o5, i4;
          if (!n2) return console.warn("Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.");
          if (!ht.Z.TextGeometry) return console.warn("Text is not supported without TextGeometry");
          if (a4 = new ht.Z.TextGeometry(t5.text, { font: n2, height: 0, size: t5.textHeight || 12 }), t5.rotation) {
            var s3 = t5.rotation * Math.PI / 180;
            a4.rotateZ(s3);
          }
          const l3 = u2(t5, r5);
          return o5 = new e.MeshBasicMaterial({ color: l3 }), (i4 = new e.Mesh(a4, o5)).position.x = t5.startPoint.x, i4.position.y = t5.startPoint.y, i4.position.z = t5.startPoint.z, i4.text = t5.text, i4.isText = true, i4.fontSize = t5.textHeight, i4.orientationZ = t5.rotation, i4.color = l3, i4;
        }(t4, r4);
        else if ("MTEXT" === t4.type) a3 = function(t5, r5) {
          var a4 = u2(t5, r5);
          if (!n2) return console.warn("font parameter not set. Ignoring text entity.");
          var o5 = l2(ke(t5.text), t5, a4), i4 = function(t6, r6, a5, o6) {
            if (!t6) return null;
            let i5 = new me();
            if (i5.text = t6.replaceAll("\\P", "\n").replaceAll("\\X", "\n"), i5.isMText = true, i5.isText = true, i5.font = n2.fontUrl, i5.fontSize = r6.textHeight, i5.maxWidth = a5.width, i5.position.x = a5.position.x, i5.position.y = a5.position.y, i5.position.z = a5.position.z, i5.textAlign = r6.horizontalAlignment, i5.color = o6, a5.rotation && (i5.rotation.z = a5.rotation * Math.PI / 180), a5.directionVector) {
              var s4 = a5.directionVector;
              i5.rotation.z = new e.Vector3(1, 0, 0).angleTo(new e.Vector3(s4.x, s4.y, s4.z));
            }
            switch (i5.orientationZ = 180 * i5.rotation.z / Math.PI, a5.attachmentPoint) {
              case 1:
                i5.anchorX = "left", i5.anchorY = "top";
                break;
              case 2:
                i5.anchorX = "center", i5.anchorY = "top";
                break;
              case 3:
                i5.anchorX = "right", i5.anchorY = "top";
                break;
              case 4:
                i5.anchorX = "left", i5.anchorY = "middle";
                break;
              case 5:
                i5.anchorX = "center", i5.anchorY = "middle";
                break;
              case 6:
                i5.anchorX = "right", i5.anchorY = "middle";
                break;
              case 7:
                i5.anchorX = "left", i5.anchorY = "bottom";
                break;
              case 8:
                i5.anchorX = "center", i5.anchorY = "bottom";
                break;
              case 9:
                i5.anchorX = "right", i5.anchorY = "bottom";
                break;
              default:
                return;
            }
            return i5.sync(() => {
              if ("left" !== i5.textAlign) {
                i5.geometry.computeBoundingBox();
                var e2 = i5.geometry.boundingBox.max.x - i5.geometry.boundingBox.min.x;
                "center" === i5.textAlign && (i5.position.x += (a5.width - e2) / 2), "right" === i5.textAlign && (i5.position.x += a5.width - e2);
              }
            }), i5;
          }(o5.text, o5.style, t5, a4);
          if (!i4) return null;
          var s3 = new e.Object3D();
          return s3.add(i4), s3;
        }(t4, r4);
        else if ("SOLID" === t4.type) a3 = function(t5, r5) {
          var n3, a4, o5 = new e.BufferGeometry(), i4 = t5.points;
          return c2(a4 = [], i4[0], i4[1], i4[2]), c2(a4, i4[1], i4[2], i4[3]), n3 = new e.MeshBasicMaterial({ color: u2(t5, r5) }), o5.setFromPoints(a4), new e.Mesh(o5, n3);
        }(t4, r4);
        else if ("POINT" === t4.type) a3 = function(t5, r5) {
          var n3, a4;
          (n3 = new e.BufferGeometry()).setAttribute("position", new e.Float32BufferAttribute([t5.position.x, t5.position.y, t5.position.z], 3));
          var o5 = u2(t5, r5);
          return a4 = new e.PointsMaterial({ size: 0.1, color: new e.Color(o5) }), new e.Points(n3, a4);
        }(t4, r4);
        else if ("INSERT" === t4.type) a3 = function(t5, r5) {
          var n3 = r5.blocks[t5.name];
          if (!n3.entities) return null;
          var a4 = new e.Object3D();
          t5.xScale && (a4.scale.x = t5.xScale), t5.yScale && (a4.scale.y = t5.yScale), t5.rotation && (a4.rotation.z = t5.rotation * Math.PI / 180), t5.position && (a4.position.x = t5.position.x, a4.position.y = t5.position.y, a4.position.z = t5.position.z);
          for (var o5 = 0; o5 < n3.entities.length; o5++) {
            var i4 = s2(n3.entities[o5], r5);
            i4 && a4.add(i4);
          }
          return a4;
        }(t4, r4);
        else if ("SPLINE" === t4.type) a3 = function(t5, r5) {
          var n3 = u2(t5, r5), a4 = function(t6, r6, n4, a5, o6) {
            const i5 = [], s3 = t6.map(function(e2) {
              return [e2.x, e2.y];
            }), l3 = [n4[r6]], c3 = [n4[r6], n4[n4.length - 1 - r6]];
            for (let e2 = r6 + 1; e2 < n4.length - r6; ++e2) l3[l3.length - 1] !== n4[e2] && l3.push(n4[e2]);
            a5 = a5 || 25;
            for (let t7 = 1; t7 < l3.length; ++t7) {
              const o7 = l3[t7 - 1], u3 = l3[t7];
              for (let t8 = 0; t8 <= a5; ++t8) {
                let l4 = (t8 / a5 * (u3 - o7) + o7 - c3[0]) / (c3[1] - c3[0]);
                l4 = Math.max(l4, 0), l4 = Math.min(l4, 1);
                const f3 = dt(l4, r6, s3, n4, void 0);
                i5.push(new e.Vector2(f3[0], f3[1]));
              }
            }
            return i5;
          }(t5.controlPoints, t5.degreeOfSplineCurve, t5.knotValues, 100), o5 = new e.BufferGeometry().setFromPoints(a4), i4 = new e.LineBasicMaterial({ linewidth: 1, color: n3 });
          return new e.Line(o5, i4);
        }(t4, r4);
        else if ("ELLIPSE" === t4.type) a3 = function(t5, r5) {
          var n3 = u2(t5, r5), a4 = Math.sqrt(Math.pow(t5.majorAxisEndPoint.x, 2) + Math.pow(t5.majorAxisEndPoint.y, 2)), o5 = a4 * t5.axisRatio, i4 = Math.atan2(t5.majorAxisEndPoint.y, t5.majorAxisEndPoint.x), s3 = new e.EllipseCurve(t5.center.x, t5.center.y, a4, o5, t5.startAngle, t5.endAngle, false, i4).getPoints(50), l3 = new e.BufferGeometry().setFromPoints(s3), c3 = new e.LineBasicMaterial({ linewidth: 1, color: n3 });
          return new e.Line(l3, c3);
        }(t4, r4);
        else if ("DIMENSION" === t4.type) {
          var o4 = 7 & t4.dimensionType;
          0 === o4 ? a3 = function(t5, r5) {
            var n3 = r5.blocks[t5.block];
            if (!n3 || !n3.entities) return null;
            for (var a4 = new e.Object3D(), o5 = 0; o5 < n3.entities.length; o5++) {
              var i4 = s2(n3.entities[o5], r5);
              i4 && a4.add(i4);
            }
            return a4;
          }(t4, r4) : console.warn("Unsupported Dimension type: " + o4);
        } else "3DFACE" === t4.type ? a3 = function(t5, r5) {
          let n3 = u2(t5, r5), a4 = 0 === n3 ? new e.Color() : new e.Color(`#${n3.toString(16)}`);
          const o5 = t5.layer || "default";
          -1 === Object.keys(r5.faceVertices).indexOf(o5) && (r5.faceVertices[o5] = [], r5.faceColors[o5] = []);
          for (let e2 = 0; e2 < 3; e2++) r5.faceVertices[o5].push(t5.vertices[e2].x, t5.vertices[e2].y, t5.vertices[e2].z), r5.faceColors[o5].push(a4.r, a4.g, a4.b);
          if (t5.vertices[3] && (t5.vertices[3].x !== t5.vertices[2].x || t5.vertices[3].y !== t5.vertices[2].y || t5.vertices[3].z !== t5.vertices[2].z)) for (let e2 = 0; e2 < 4; e2++) 1 !== e2 && (r5.faceVertices[o5].push(t5.vertices[e2].x, t5.vertices[e2].y, t5.vertices[e2].z), r5.faceColors[o5].push(a4.r, a4.g, a4.b));
          return null;
        }(t4, r4) : console.warn("Unsupported Entity Type: " + t4.type);
        return a3;
      }
      function l2(e2, t4, r4) {
        let n3 = { horizontalAlignment: "left", textHeight: t4.height };
        var a3 = [];
        for (let i4 of e2) if ("string" == typeof i4) i4.startsWith("pxq") && i4.endsWith(";") ? -1 !== i4.indexOf("c") ? n3.horizontalAlignment = "center" : -1 !== i4.indexOf("l") ? n3.horizontalAlignment = "left" : -1 !== i4.indexOf("r") ? n3.horizontalAlignment = "right" : -1 !== i4.indexOf("j") && (n3.horizontalAlignment = "justify") : a3.push(i4);
        else if (Array.isArray(i4)) {
          var o4 = l2(i4, t4, r4);
          a3.push(o4.text);
        } else "object" == typeof i4 && i4.S && 3 === i4.S.length && a3.push(i4.S[0] + "/" + i4.S[2]);
        return { text: a3.join(), style: n3 };
      }
      function c2(t4, r4, n3, a3) {
        var o4 = new e.Vector3(), i4 = new e.Vector3();
        o4.subVectors(n3, r4), i4.subVectors(a3, r4), o4.cross(i4);
        var s3 = new e.Vector3(r4.x, r4.y, r4.z), l3 = new e.Vector3(n3.x, n3.y, n3.z), c3 = new e.Vector3(a3.x, a3.y, a3.z);
        o4.z < 0 ? t4.push(c3, l3, s3) : t4.push(s3, l3, c3);
      }
      function u2(e2, t4) {
        var r4 = null;
        return e2.color ? r4 = e2.color : t4.tables && t4.tables.layer && t4.tables.layer.layers[e2.layer] && (r4 = t4.tables.layer.layers[e2.layer].color), null != r4 && 16777215 !== r4 || (r4 = t4.defaultColor), r4;
      }
      function f2(t4) {
        var r4, n3 = {}, a3 = 0;
        for (r4 = 0; r4 < t4.length; r4++) a3 += Math.abs(t4[r4]);
        return n3.uniforms = e.UniformsUtils.merge([e.UniformsLib.common, e.UniformsLib.fog, { pattern: { type: "fv1", value: t4 }, patternLength: { type: "f", value: a3 } }]), n3.vertexShader = ["attribute float lineDistance;", "varying float vLineDistance;", e.ShaderChunk.color_pars_vertex, "void main() {", e.ShaderChunk.color_vertex, "vLineDistance = lineDistance;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), n3.fragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float pattern[" + t4.length + "];", "uniform float patternLength;", "varying float vLineDistance;", e.ShaderChunk.color_pars_fragment, e.ShaderChunk.fog_pars_fragment, "void main() {", "float pos = mod(vLineDistance, patternLength);", "for ( int i = 0; i < " + t4.length + "; i++ ) {", "pos = pos - abs(pattern[i]);", "if( pos < 0.0 ) {", "if( pattern[i] > 0.0 ) {", "gl_FragColor = vec4(1.0, 0.0, 0.0, opacity );", "break;", "}", "discard;", "}", "}", e.ShaderChunk.color_fragment, e.ShaderChunk.fog_fragment, "}"].join("\n"), n3;
      }
      !function(e2) {
        var t4, r4;
        if (e2.tables && e2.tables.lineType) {
          var n3 = e2.tables.lineType.lineTypes;
          for (r4 in n3) (t4 = n3[r4]).pattern && (t4.material = f2(t4.pattern));
        }
      }(t3);
      var d2, h2, v2, p2 = [], g2 = {};
      for (t3.faceVertices = {}, t3.faceColors = {}, t3.defaultColor = o3, d2 = 0; d2 < t3.entities.length; d2++) {
        if ((v2 = s2(h2 = t3.entities[d2], t3)) && (p2.push(v2), a2 && h2.layer)) {
          let t4 = g2[h2.layer];
          t4 || (t4 = new e.Group(), t4.name = h2.layer, g2[h2.layer] = t4), t4.add(v2);
        }
        v2 = null;
      }
      const b2 = Object.keys(t3.faceVertices);
      for (const r4 of b2) {
        const n3 = t3.faceVertices[r4], o4 = t3.faceColors[r4], i4 = new e.BufferGeometry();
        i4.setAttribute("position", new e.Float32BufferAttribute(n3, 3)), i4.setAttribute("color", new e.Float32BufferAttribute(o4, 3)), i4.computeVertexNormals();
        const s3 = new e.MeshLambertMaterial({ side: e.DoubleSide, vertexColors: true, transparent: false }), l3 = new e.Mesh(i4, s3);
        if (p2.push(l3), a2) {
          let t4 = g2[r4];
          t4 ? g2[r4].add(l3) : (t4 = new e.Group(), t4.name = r4, t4.add(l3), g2[r4] = t4);
        }
      }
      delete t3.faceVertices, delete t3.faceColors, delete t3.defaultColor;
      const y2 = new e.Group();
      if (a2 ? Object.values(g2).forEach((e2) => y2.add(e2)) : p2.forEach((e2) => y2.add(e2)), i3) {
        const e2 = (((_a = t3.header) == null ? void 0 : _a.$DIMLFAC) || 1) * function(e3) {
          switch (e3) {
            case 0:
            case 6:
              return 1;
            case 1:
              return 0.0254;
            case 2:
              return 0.3048;
            case 3:
              return 1609.344;
            case 4:
              return 1e-3;
            case 5:
              return 0.01;
            case 7:
              return 1e3;
            case 8:
              return 254e-10;
            case 9:
              return 254e-7;
            case 10:
              return 0.9144;
            case 11:
              return 1e-10;
            case 12:
              return 1e-9;
            case 13:
              return 1e-6;
            case 14:
              return 0.1;
            case 15:
              return 10;
            case 16:
              return 100;
            case 17:
              return 1e9;
            case 18:
              return 149597870700;
            case 19:
              return 946073047808e4;
            case 20:
              return 308567758128e5;
          }
          return 1;
        }((_b = t3.header) == null ? void 0 : _b.$INSUNITS);
        y2.scale.set(e2, e2, e2);
      }
      return { entity: y2, dxf: t3 };
    }
  }
})();
var o = a.H;
var i = a.K;
export {
  o as DXFLoader,
  i as THREEx
};
/*! Bundled license information:

three-dxf-loader/dist/three-dxf-loader.js:
  (*! For license information please see three-dxf-loader.js.LICENSE.txt *)
*/
//# sourceMappingURL=three-dxf-loader.js.map
