{
  "version": 3,
  "sources": ["../../loglevel/lib/loglevel.js", "../../dxf-parser/dist/DxfArrayScanner.js", "../../dxf-parser/dist/AutoCadColorIndex.js", "../../dxf-parser/dist/ParseHelpers.js", "../../dxf-parser/dist/entities/3dface.js", "../../dxf-parser/dist/entities/arc.js", "../../dxf-parser/dist/entities/attdef.js", "../../dxf-parser/dist/entities/circle.js", "../../dxf-parser/dist/entities/dimension.js", "../../dxf-parser/dist/entities/ellipse.js", "../../dxf-parser/dist/entities/insert.js", "../../dxf-parser/dist/entities/line.js", "../../dxf-parser/dist/entities/lwpolyline.js", "../../dxf-parser/dist/entities/mtext.js", "../../dxf-parser/dist/entities/point.js", "../../dxf-parser/dist/entities/vertex.js", "../../dxf-parser/dist/entities/polyline.js", "../../dxf-parser/dist/entities/solid.js", "../../dxf-parser/dist/entities/spline.js", "../../dxf-parser/dist/entities/text.js", "../../dxf-parser/dist/DxfParser.js", "../../dxf-parser/dist/index.js"],
  "sourcesContent": ["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n", "/**\n * DxfArrayScanner\n *\n * Based off the AutoCad 2012 DXF Reference\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\n *\n * Reads through an array representing lines of a dxf file. Takes an array and\n * provides an easy interface to extract group code and value pairs.\n * @param data - an array where each element represents a line in the dxf file\n * @constructor\n */\nexport default class DxfArrayScanner {\n    constructor(data) {\n        this._pointer = 0;\n        this._eof = false;\n        this._data = data;\n    }\n    /**\n     * Gets the next group (code, value) from the array. A group is two consecutive elements\n     * in the array. The first is the code, the second is the value.\n     * @returns {{code: Number}|*}\n     */\n    next() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        this._pointer++;\n        group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\n        this._pointer++;\n        if (group.code === 0 && group.value === 'EOF')\n            this._eof = true;\n        this.lastReadGroup = group;\n        return group;\n    }\n    peek() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\n        return group;\n    }\n    rewind(numberOfGroups = 1) {\n        this._pointer = this._pointer - numberOfGroups * 2;\n    }\n    /**\n     * Returns true if there is another code/value pair (2 elements in the array).\n     * @returns {boolean}\n     */\n    hasNext() {\n        // Check if we have read EOF group code\n        if (this._eof) {\n            return false;\n        }\n        // We need to be sure there are two lines available\n        if (this._pointer > this._data.length - 2) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns true if the scanner is at the end of the array\n     * @returns {boolean}\n     */\n    isEOF() {\n        return this._eof;\n    }\n}\n/**\n * Parse a value to its proper type.\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\n *\n * @param code\n * @param value\n * @returns {*}\n */\nfunction parseGroupValue(code, value) {\n    if (code <= 9)\n        return value;\n    if (code >= 10 && code <= 59)\n        return parseFloat(value);\n    if (code >= 60 && code <= 99)\n        return parseInt(value);\n    if (code >= 100 && code <= 109)\n        return value;\n    if (code >= 110 && code <= 149)\n        return parseFloat(value);\n    if (code >= 160 && code <= 179)\n        return parseInt(value);\n    if (code >= 210 && code <= 239)\n        return parseFloat(value);\n    if (code >= 270 && code <= 289)\n        return parseInt(value);\n    if (code >= 290 && code <= 299)\n        return parseBoolean(value);\n    if (code >= 300 && code <= 369)\n        return value;\n    if (code >= 370 && code <= 389)\n        return parseInt(value);\n    if (code >= 390 && code <= 399)\n        return value;\n    if (code >= 400 && code <= 409)\n        return parseInt(value);\n    if (code >= 410 && code <= 419)\n        return value;\n    if (code >= 420 && code <= 429)\n        return parseInt(value);\n    if (code >= 430 && code <= 439)\n        return value;\n    if (code >= 440 && code <= 459)\n        return parseInt(value);\n    if (code >= 460 && code <= 469)\n        return parseFloat(value);\n    if (code >= 470 && code <= 481)\n        return value;\n    if (code === 999)\n        return value;\n    if (code >= 1000 && code <= 1009)\n        return value;\n    if (code >= 1010 && code <= 1059)\n        return parseFloat(value);\n    if (code >= 1060 && code <= 1071)\n        return parseInt(value);\n    console.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\n    return value;\n}\n/**\n * Parse a boolean according to a 1 or 0 value\n * @param str\n * @returns {boolean}\n */\nfunction parseBoolean(str) {\n    if (str === '0')\n        return false;\n    if (str === '1')\n        return true;\n    throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\n}\n", "/**\n * AutoCad files sometimes use an indexed color value between 1 and 255 inclusive.\n * Each value corresponds to a color. index 1 is red, that is 16711680 or 0xFF0000.\n * index 0 and 256, while included in this array, are actually reserved for inheritance\n * values in AutoCad so they should not be used for index color lookups.\n */\nexport default [\n    0,\n    16711680,\n    16776960,\n    65280,\n    65535,\n    255,\n    16711935,\n    16777215,\n    8421504,\n    12632256,\n    16711680,\n    16744319,\n    13369344,\n    13395558,\n    10027008,\n    10046540,\n    8323072,\n    8339263,\n    4980736,\n    4990502,\n    16727808,\n    16752511,\n    13382400,\n    13401958,\n    10036736,\n    10051404,\n    8331008,\n    8343359,\n    4985600,\n    4992806,\n    16744192,\n    16760703,\n    13395456,\n    13408614,\n    10046464,\n    10056268,\n    8339200,\n    8347455,\n    4990464,\n    4995366,\n    16760576,\n    16768895,\n    13408512,\n    13415014,\n    10056192,\n    10061132,\n    8347392,\n    8351551,\n    4995328,\n    4997670,\n    16776960,\n    16777087,\n    13421568,\n    13421670,\n    10000384,\n    10000460,\n    8355584,\n    8355647,\n    5000192,\n    5000230,\n    12582656,\n    14679935,\n    10079232,\n    11717734,\n    7510016,\n    8755276,\n    6258432,\n    7307071,\n    3755008,\n    4344870,\n    8388352,\n    12582783,\n    6736896,\n    10079334,\n    5019648,\n    7510092,\n    4161280,\n    6258495,\n    2509824,\n    3755046,\n    4194048,\n    10485631,\n    3394560,\n    8375398,\n    2529280,\n    6264908,\n    2064128,\n    5209919,\n    1264640,\n    3099686,\n    65280,\n    8388479,\n    52224,\n    6736998,\n    38912,\n    5019724,\n    32512,\n    4161343,\n    19456,\n    2509862,\n    65343,\n    8388511,\n    52275,\n    6737023,\n    38950,\n    5019743,\n    32543,\n    4161359,\n    19475,\n    2509871,\n    65407,\n    8388543,\n    52326,\n    6737049,\n    38988,\n    5019762,\n    32575,\n    4161375,\n    19494,\n    2509881,\n    65471,\n    8388575,\n    52377,\n    6737074,\n    39026,\n    5019781,\n    32607,\n    4161391,\n    19513,\n    2509890,\n    65535,\n    8388607,\n    52428,\n    6737100,\n    39064,\n    5019800,\n    32639,\n    4161407,\n    19532,\n    2509900,\n    49151,\n    8380415,\n    39372,\n    6730444,\n    29336,\n    5014936,\n    24447,\n    4157311,\n    14668,\n    2507340,\n    32767,\n    8372223,\n    26316,\n    6724044,\n    19608,\n    5010072,\n    16255,\n    4153215,\n    9804,\n    2505036,\n    16383,\n    8364031,\n    13260,\n    6717388,\n    9880,\n    5005208,\n    8063,\n    4149119,\n    4940,\n    2502476,\n    255,\n    8355839,\n    204,\n    6710988,\n    152,\n    5000344,\n    127,\n    4145023,\n    76,\n    2500172,\n    4129023,\n    10452991,\n    3342540,\n    8349388,\n    2490520,\n    6245528,\n    2031743,\n    5193599,\n    1245260,\n    3089996,\n    8323327,\n    12550143,\n    6684876,\n    10053324,\n    4980888,\n    7490712,\n    4128895,\n    6242175,\n    2490444,\n    3745356,\n    12517631,\n    14647295,\n    10027212,\n    11691724,\n    7471256,\n    8735896,\n    6226047,\n    7290751,\n    3735628,\n    4335180,\n    16711935,\n    16744447,\n    13369548,\n    13395660,\n    9961624,\n    9981080,\n    8323199,\n    8339327,\n    4980812,\n    4990540,\n    16711871,\n    16744415,\n    13369497,\n    13395634,\n    9961586,\n    9981061,\n    8323167,\n    8339311,\n    4980793,\n    4990530,\n    16711807,\n    16744383,\n    13369446,\n    13395609,\n    9961548,\n    9981042,\n    8323135,\n    8339295,\n    4980774,\n    4990521,\n    16711743,\n    16744351,\n    13369395,\n    13395583,\n    9961510,\n    9981023,\n    8323103,\n    8339279,\n    4980755,\n    4990511,\n    3355443,\n    5987163,\n    8684676,\n    11382189,\n    14079702,\n    16777215\n];\n", "import AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nexport function getAcadColor(index) {\n    return AUTO_CAD_COLOR_INDEX[index];\n}\n/**\n * Parses the 2D or 3D coordinate, vector, or point. When complete,\n * the scanner remains on the last group of the coordinate.\n * @param {*} scanner\n */\nexport function parsePoint(scanner) {\n    const point = {};\n    // Reread group for the first coordinate\n    scanner.rewind();\n    let curr = scanner.next();\n    let code = curr.code;\n    point.x = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code)\n        throw new Error('Expected code for point value to be ' + code +\n            ' but got ' + curr.code + '.');\n    point.y = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code) {\n        // Only the x and y are specified. Don't read z.\n        scanner.rewind(); // Let the calling code advance off the point\n        return point;\n    }\n    point.z = curr.value;\n    return point;\n}\n/**\n * Attempts to parse codes common to all entities. Returns true if the group\n * was handled by this function.\n * @param {*} entity - the entity currently being parsed\n * @param {*} curr - the current group being parsed\n */\nexport function checkCommonEntityProperties(entity, curr, scanner) {\n    switch (curr.code) {\n        case 0:\n            entity.type = curr.value;\n            break;\n        case 5:\n            entity.handle = curr.value;\n            break;\n        case 6:\n            entity.lineType = curr.value;\n            break;\n        case 8: // Layer name\n            entity.layer = curr.value;\n            break;\n        case 48:\n            entity.lineTypeScale = curr.value;\n            break;\n        case 60:\n            entity.visible = curr.value === 0;\n            break;\n        case 62: // Acad Index Color. 0 inherits ByBlock. 256 inherits ByLayer. Default is bylayer\n            entity.colorIndex = curr.value;\n            entity.color = getAcadColor(Math.abs(curr.value));\n            break;\n        case 67:\n            entity.inPaperSpace = curr.value !== 0;\n            break;\n        case 100:\n            //ignore\n            break;\n        case 101: // Embedded Object in ACAD 2018.\n            // See https://ezdxf.readthedocs.io/en/master/dxfinternals/dxftags.html#embedded-objects\n            while (curr.code != 0) {\n                curr = scanner.next();\n            }\n            scanner.rewind();\n            break;\n        case 330:\n            entity.ownerHandle = curr.value;\n            break;\n        case 347:\n            entity.materialObjectHandle = curr.value;\n            break;\n        case 370:\n            //From https://www.woutware.com/Forum/Topic/955/lineweight?returnUrl=%2FForum%2FUserPosts%3FuserId%3D478262319\n            // An integer representing 100th of mm, must be one of the following values:\n            // 0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.\n            // -3 = STANDARD, -2 = BYLAYER, -1 = BYBLOCK\n            entity.lineweight = curr.value;\n            break;\n        case 420: // TrueColor Color\n            entity.color = curr.value;\n            break;\n        case 1000:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.customStrings = entity.extendedData.customStrings || [];\n            entity.extendedData.customStrings.push(curr.value);\n            break;\n        case 1001:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.applicationName = curr.value;\n            break;\n        default:\n            return false;\n    }\n    return true;\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class ThreeDface {\n    constructor() {\n        this.ForEntityName = '3DFACE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parse3dFaceVertices(scanner, curr);\n                    curr = scanner.lastReadGroup;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parse3dFaceVertices(scanner, curr) {\n    var vertices = [];\n    var vertexIsStarted = false;\n    var vertexIsFinished = false;\n    var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\n    for (let i = 0; i <= verticesPer3dFace; i++) {\n        var vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X0\n                case 11: // X1\n                case 12: // X2\n                case 13: // X3\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                case 21:\n                case 22:\n                case 23:\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                case 31:\n                case 32:\n                case 33:\n                    vertex.z = curr.value;\n                    break;\n                default:\n                    // it is possible to have entity codes after the vertices.  \n                    // So if code is not accounted for return to entity parser where it might be accounted for\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n;\n", "import * as helpers from '../ParseHelpers';\nexport default class Arc {\n    constructor() {\n        this.ForEntityName = 'ARC';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    entity.endAngle = Math.PI / 180 * curr.value;\n                    entity.angleLength = entity.endAngle - entity.startAngle; // angleLength is deprecated\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default: // ignored attribute\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Attdef {\n    constructor() {\n        this.ForEntityName = 'ATTDEF';\n    }\n    parseEntity(scanner, curr) {\n        var entity = {\n            type: curr.value,\n            scale: 1,\n            textStyle: 'STANDARD'\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0) {\n                break;\n            }\n            switch (curr.code) {\n                case 1:\n                    entity.text = curr.value;\n                    break;\n                case 2:\n                    entity.tag = curr.value;\n                    break;\n                case 3:\n                    entity.prompt = curr.value;\n                    break;\n                case 7:\n                    entity.textStyle = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = helpers.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 40:\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.scale = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 51:\n                    entity.obliqueAngle = curr.value;\n                    break;\n                case 70:\n                    entity.invisible = !!(curr.value & 0x01);\n                    entity.constant = !!(curr.value & 0x02);\n                    entity.verificationRequired = !!(curr.value & 0x04);\n                    entity.preset = !!(curr.value & 0x08);\n                    break;\n                case 71:\n                    entity.backwards = !!(curr.value & 0x02);\n                    entity.mirrored = !!(curr.value & 0x04);\n                    break;\n                case 72:\n                    // TODO: enum values?\n                    entity.horizontalJustification = curr.value;\n                    break;\n                case 73:\n                    entity.fieldLength = curr.value;\n                    break;\n                case 74:\n                    // TODO: enum values?\n                    entity.verticalJustification = curr.value;\n                    break;\n                case 100:\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Circle {\n    constructor() {\n        this.ForEntityName = 'CIRCLE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    const endAngle = Math.PI / 180 * curr.value;\n                    if (endAngle < entity.startAngle)\n                        entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;\n                    else\n                        entity.angleLength = endAngle - entity.startAngle;\n                    entity.endAngle = endAngle;\n                    break;\n                default: // ignored attribute\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Dimension {\n    constructor() {\n        this.ForEntityName = 'DIMENSION';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2: // Referenced block name\n                    entity.block = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.anchorPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.middleOfText = helpers.parsePoint(scanner);\n                    break;\n                case 12: // Insertion point for clones of a dimension\n                    entity.insertionPoint = helpers.parsePoint(scanner);\n                    break;\n                case 13: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint1 = helpers.parsePoint(scanner);\n                    break;\n                case 14: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint2 = helpers.parsePoint(scanner);\n                    break;\n                case 15: // Definition point for diameter, radius, and angular dimensions\n                    entity.diameterOrRadiusPoint = helpers.parsePoint(scanner);\n                    break;\n                case 16: // Point defining dimension arc for angular dimensions\n                    entity.arcPoint = helpers.parsePoint(scanner);\n                    break;\n                case 70: // Dimension type\n                    entity.dimensionType = curr.value;\n                    break;\n                case 71: // 5 = Middle center\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 42: // Actual measurement\n                    entity.actualMeasurement = curr.value;\n                    break;\n                case 1: // Text entered by user explicitly\n                    entity.text = curr.value;\n                    break;\n                case 50: // Angle of rotated, horizontal, or vertical dimensions\n                    entity.angle = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Ellipse {\n    constructor() {\n        this.ForEntityName = 'ELLIPSE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.center = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.majorAxisEndPoint = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    entity.axisRatio = curr.value;\n                    break;\n                case 41:\n                    entity.startAngle = curr.value;\n                    break;\n                case 42:\n                    entity.endAngle = curr.value;\n                    break;\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Insert {\n    constructor() {\n        this.ForEntityName = 'INSERT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 42:\n                    entity.yScale = curr.value;\n                    break;\n                case 43:\n                    entity.zScale = curr.value;\n                    break;\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 70:\n                    entity.columnCount = curr.value;\n                    break;\n                case 71:\n                    entity.rowCount = curr.value;\n                    break;\n                case 44:\n                    entity.columnSpacing = curr.value;\n                    break;\n                case 45:\n                    entity.rowSpacing = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Line {\n    constructor() {\n        this.ForEntityName = 'LINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.vertices.unshift(helpers.parsePoint(scanner));\n                    break;\n                case 11:\n                    entity.vertices.push(helpers.parsePoint(scanner));\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Lwpolyline {\n    constructor() {\n        this.ForEntityName = 'LWPOLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        let numberOfVertices = 0;\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 38:\n                    entity.elevation = curr.value;\n                    break;\n                case 39:\n                    entity.depth = curr.value;\n                    break;\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 90:\n                    numberOfVertices = curr.value;\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\n                    break;\n                case 43:\n                    if (curr.value !== 0)\n                        entity.width = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parseLWPolylineVertices(n, scanner) {\n    if (!n || n <= 0)\n        throw Error('n must be greater than 0 verticies');\n    const vertices = [];\n    let vertexIsStarted = false;\n    let vertexIsFinished = false;\n    let curr = scanner.lastReadGroup;\n    for (let i = 0; i < n; i++) {\n        const vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                    vertex.z = curr.value;\n                    break;\n                case 40: // start width\n                    vertex.startWidth = curr.value;\n                    break;\n                case 41: // end width\n                    vertex.endWidth = curr.value;\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        vertex.bulge = curr.value;\n                    break;\n                default:\n                    // if we do not hit known code return vertices.  Code might belong to entity\n                    scanner.rewind();\n                    if (vertexIsStarted) {\n                        vertices.push(vertex);\n                    }\n                    scanner.rewind();\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Mtext {\n    constructor() {\n        this.ForEntityName = 'MTEXT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 3:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 1:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.directionVector = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    //Note: this is the text height\n                    entity.height = curr.value;\n                    break;\n                case 41:\n                    entity.width = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 71:\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 72:\n                    entity.drawingDirection = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Point {\n    constructor() {\n        this.ForEntityName = 'POINT';\n    }\n    parseEntity(scanner, curr) {\n        const type = curr.value;\n        const entity = { type };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.position = helpers.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Vertex {\n    constructor() {\n        this.ForEntityName = 'VERTEX';\n    }\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    entity.x = curr.value;\n                    break;\n                case 20: // Y\n                    entity.y = curr.value;\n                    break;\n                case 30: // Z\n                    entity.z = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        entity.bulge = curr.value;\n                    break;\n                case 70: // flags\n                    entity.curveFittingVertex = (curr.value & 1) !== 0;\n                    entity.curveFitTangent = (curr.value & 2) !== 0;\n                    entity.splineVertex = (curr.value & 8) !== 0;\n                    entity.splineControlPoint = (curr.value & 16) !== 0;\n                    entity.threeDPolylineVertex = (curr.value & 32) !== 0;\n                    entity.threeDPolylineMesh = (curr.value & 64) !== 0;\n                    entity.polyfaceMeshVertex = (curr.value & 128) !== 0;\n                    break;\n                case 50: // curve fit tangent direction\n                    break;\n                case 71: // polyface mesh vertex index\n                    entity.faceA = curr.value;\n                    break;\n                case 72: // polyface mesh vertex index\n                    entity.faceB = curr.value;\n                    break;\n                case 73: // polyface mesh vertex index\n                    entity.faceC = curr.value;\n                    break;\n                case 74: // polyface mesh vertex index\n                    entity.faceD = curr.value;\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nimport VertexParser from './vertex';\nexport default class Polyline {\n    constructor() {\n        this.ForEntityName = 'POLYLINE';\n    }\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // always 0\n                    break;\n                case 20: // always 0\n                    break;\n                case 30: // elevation\n                    break;\n                case 39: // thickness\n                    entity.thickness = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 70:\n                    entity.shape = (curr.value & 1) !== 0;\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\n                    break;\n                case 71: // Polygon mesh M vertex count\n                    break;\n                case 72: // Polygon mesh N vertex count\n                    break;\n                case 73: // Smooth surface M density\n                    break;\n                case 74: // Smooth surface N density\n                    break;\n                case 75: // Curves and smooth surface type\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        entity.vertices = parsePolylineVertices(scanner, curr);\n        return entity;\n    }\n}\nfunction parsePolylineVertices(scanner, curr) {\n    const vertexParser = new VertexParser();\n    const vertices = [];\n    while (!scanner.isEOF()) {\n        if (curr.code === 0) {\n            if (curr.value === 'VERTEX') {\n                vertices.push(vertexParser.parseEntity(scanner, curr));\n                curr = scanner.lastReadGroup;\n            }\n            else if (curr.value === 'SEQEND') {\n                parseSeqEnd(scanner, curr);\n                break;\n            }\n        }\n    }\n    return vertices;\n}\nfunction parseSeqEnd(scanner, curr) {\n    const entity = { type: curr.value };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n        if (curr.code == 0)\n            break;\n        helpers.checkCommonEntityProperties(entity, curr, scanner);\n        curr = scanner.next();\n    }\n    return entity;\n}\n;\n", "import * as helpers from '../ParseHelpers';\nexport default class Solid {\n    constructor() {\n        this.ForEntityName = 'SOLID';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, points: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.points[0] = helpers.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.points[1] = helpers.parsePoint(scanner);\n                    break;\n                case 12:\n                    entity.points[2] = helpers.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.points[3] = helpers.parsePoint(scanner);\n                    break;\n                case 210:\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Spline {\n    constructor() {\n        this.ForEntityName = 'SPLINE';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    if (!entity.controlPoints)\n                        entity.controlPoints = [];\n                    entity.controlPoints.push(helpers.parsePoint(scanner));\n                    break;\n                case 11:\n                    if (!entity.fitPoints)\n                        entity.fitPoints = [];\n                    entity.fitPoints.push(helpers.parsePoint(scanner));\n                    break;\n                case 12:\n                    entity.startTangent = helpers.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.endTangent = helpers.parsePoint(scanner);\n                    break;\n                case 40:\n                    if (!entity.knotValues)\n                        entity.knotValues = [];\n                    entity.knotValues.push(curr.value);\n                    break;\n                case 70:\n                    if ((curr.value & 1) != 0)\n                        entity.closed = true;\n                    if ((curr.value & 2) != 0)\n                        entity.periodic = true;\n                    if ((curr.value & 4) != 0)\n                        entity.rational = true;\n                    if ((curr.value & 8) != 0)\n                        entity.planar = true;\n                    if ((curr.value & 16) != 0) {\n                        entity.planar = true;\n                        entity.linear = true;\n                    }\n                    break;\n                case 71:\n                    entity.degreeOfSplineCurve = curr.value;\n                    break;\n                case 72:\n                    entity.numberOfKnots = curr.value;\n                    break;\n                case 73:\n                    entity.numberOfControlPoints = curr.value;\n                    break;\n                case 74:\n                    entity.numberOfFitPoints = curr.value;\n                    break;\n                case 210:\n                    entity.normalVector = helpers.parsePoint(scanner);\n                    break;\n                default:\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import * as helpers from '../ParseHelpers';\nexport default class Text {\n    constructor() {\n        this.ForEntityName = 'TEXT';\n    }\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = helpers.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = helpers.parsePoint(scanner);\n                    break;\n                case 40: // Text height\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 50: // Rotation in degrees\n                    entity.rotation = curr.value;\n                    break;\n                case 1: // Text\n                    entity.text = curr.value;\n                    break;\n                // NOTE: 72 and 73 are meaningless without 11 (second alignment point)\n                case 72: // Horizontal alignment\n                    entity.halign = curr.value;\n                    break;\n                case 73: // Vertical alignment\n                    entity.valign = curr.value;\n                    break;\n                default: // check common entity attributes\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n", "import DxfArrayScanner from './DxfArrayScanner';\nimport AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\nimport Face from './entities/3dface';\nimport Arc from './entities/arc';\nimport AttDef from './entities/attdef';\nimport Circle from './entities/circle';\nimport Dimension from './entities/dimension';\nimport Ellipse from './entities/ellipse';\nimport Insert from './entities/insert';\nimport Line from './entities/line';\nimport LWPolyline from './entities/lwpolyline';\nimport MText from './entities/mtext';\nimport Point from './entities/point';\nimport Polyline from './entities/polyline';\nimport Solid from './entities/solid';\nimport Spline from './entities/spline';\nimport Text from './entities/text';\n//import Vertex from './entities/';\nimport log from 'loglevel';\n//log.setLevel('trace');\n//log.setLevel('debug');\n//log.setLevel('info');\n//log.setLevel('warn');\nlog.setLevel('error');\nfunction registerDefaultEntityHandlers(dxfParser) {\n    // Supported entities here (some entity code is still being refactored into this flow)\n    dxfParser.registerEntityHandler(Face);\n    dxfParser.registerEntityHandler(Arc);\n    dxfParser.registerEntityHandler(AttDef);\n    dxfParser.registerEntityHandler(Circle);\n    dxfParser.registerEntityHandler(Dimension);\n    dxfParser.registerEntityHandler(Ellipse);\n    dxfParser.registerEntityHandler(Insert);\n    dxfParser.registerEntityHandler(Line);\n    dxfParser.registerEntityHandler(LWPolyline);\n    dxfParser.registerEntityHandler(MText);\n    dxfParser.registerEntityHandler(Point);\n    dxfParser.registerEntityHandler(Polyline);\n    dxfParser.registerEntityHandler(Solid);\n    dxfParser.registerEntityHandler(Spline);\n    dxfParser.registerEntityHandler(Text);\n    //dxfParser.registerEntityHandler(require('./entities/vertex'));\n}\nexport default class DxfParser {\n    constructor() {\n        this._entityHandlers = {};\n        registerDefaultEntityHandlers(this);\n    }\n    parse(source) {\n        if (typeof source === 'string') {\n            return this._parse(source);\n        }\n        else {\n            console.error('Cannot read dxf source of type `' + typeof (source));\n            return null;\n        }\n    }\n    registerEntityHandler(handlerType) {\n        const instance = new handlerType();\n        this._entityHandlers[instance.ForEntityName] = instance;\n    }\n    parseSync(source) {\n        return this.parse(source);\n    }\n    parseStream(stream) {\n        let dxfString = \"\";\n        const self = this;\n        return new Promise((res, rej) => {\n            stream.on('data', (chunk) => {\n                dxfString += chunk;\n            });\n            stream.on('end', () => {\n                try {\n                    res(self._parse(dxfString));\n                }\n                catch (err) {\n                    rej(err);\n                }\n            });\n            stream.on('error', (err) => {\n                rej(err);\n            });\n        });\n    }\n    _parse(dxfString) {\n        const dxf = {};\n        let lastHandle = 0;\n        const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\n        const scanner = new DxfArrayScanner(dxfLinesArray);\n        if (!scanner.hasNext())\n            throw Error('Empty file');\n        const self = this;\n        let curr;\n        function parseAll() {\n            curr = scanner.next();\n            while (!scanner.isEOF()) {\n                if (curr.code === 0 && curr.value === 'SECTION') {\n                    curr = scanner.next();\n                    // Be sure we are reading a section code\n                    if (curr.code !== 2) {\n                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\n                        curr = scanner.next();\n                        continue;\n                    }\n                    if (curr.value === 'HEADER') {\n                        log.debug('> HEADER');\n                        dxf.header = parseHeader();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'BLOCKS') {\n                        log.debug('> BLOCKS');\n                        dxf.blocks = parseBlocks();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'ENTITIES') {\n                        log.debug('> ENTITIES');\n                        dxf.entities = parseEntities(false);\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'TABLES') {\n                        log.debug('> TABLES');\n                        dxf.tables = parseTables();\n                        log.debug('<');\n                    }\n                    else if (curr.value === 'EOF') {\n                        log.debug('EOF');\n                    }\n                    else {\n                        log.warn('Skipping section \\'%s\\'', curr.value);\n                    }\n                }\n                else {\n                    curr = scanner.next();\n                }\n                // If is a new section\n            }\n        }\n        /**\n         *\n         * @return {object} header\n         */\n        function parseHeader() {\n            // interesting variables:\n            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\n            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\n            // Also see VPORT table entries\n            let currVarName = null;\n            let currVarValue = null;\n            const header = {};\n            // loop through header variables\n            curr = scanner.next();\n            while (true) {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    break;\n                }\n                else if (curr.code === 9) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    currVarName = curr.value;\n                    // Filter here for particular variables we are interested in\n                }\n                else {\n                    if (curr.code === 10) {\n                        currVarValue = { x: curr.value };\n                    }\n                    else if (curr.code === 20) {\n                        currVarValue.y = curr.value;\n                    }\n                    else if (curr.code === 30) {\n                        currVarValue.z = curr.value;\n                    }\n                    else {\n                        currVarValue = curr.value;\n                    }\n                }\n                curr = scanner.next();\n            }\n            // console.log(util.inspect(header, { colors: true, depth: null }));\n            curr = scanner.next(); // swallow up ENDSEC\n            return header;\n        }\n        /**\n         *\n         */\n        function parseBlocks() {\n            const blocks = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    break;\n                }\n                if (groupIs(curr, 0, 'BLOCK')) {\n                    log.debug('block {');\n                    const block = parseBlock();\n                    log.debug('}');\n                    ensureHandle(block);\n                    if (!block.name)\n                        log.error('block with handle \"' + block.handle + '\" is missing a name.');\n                    else\n                        blocks[block.name] = block;\n                }\n                else {\n                    logUnhandledGroup(curr);\n                    curr = scanner.next();\n                }\n            }\n            return blocks;\n        }\n        function parseBlock() {\n            const block = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                switch (curr.code) {\n                    case 1:\n                        block.xrefPath = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 2:\n                        block.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        block.name2 = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 5:\n                        block.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 8:\n                        block.layer = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        block.position = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 67:\n                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;\n                        curr = scanner.next();\n                        break;\n                    case 70:\n                        if (curr.value != 0) {\n                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\n                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\n                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\n                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\n                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\n                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\n                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\n                            block.type = curr.value;\n                        }\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        // ignore class markers\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        block.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value == 'ENDBLK')\n                            break;\n                        block.entities = parseEntities(true);\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n                if (groupIs(curr, 0, 'ENDBLK')) {\n                    curr = scanner.next();\n                    break;\n                }\n            }\n            return block;\n        }\n        /**\n         * parseTables\n         * @return {Object} Object representing tables\n         */\n        function parseTables() {\n            const tables = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC'))\n                    break;\n                if (groupIs(curr, 0, 'TABLE')) {\n                    curr = scanner.next();\n                    const tableDefinition = tableDefinitions[curr.value];\n                    if (tableDefinition) {\n                        log.debug(curr.value + ' Table {');\n                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\n                        log.debug('}');\n                    }\n                    else {\n                        log.debug('Unhandled Table ' + curr.value);\n                    }\n                }\n                else {\n                    // else ignored\n                    curr = scanner.next();\n                }\n            }\n            curr = scanner.next();\n            return tables;\n        }\n        const END_OF_TABLE_VALUE = 'ENDTAB';\n        function parseTable(group) {\n            const tableDefinition = tableDefinitions[group.value];\n            const table = {};\n            let expectedCount = 0;\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 5:\n                        table.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        table.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        if (curr.value === 'AcDbSymbolTable') {\n                            // ignore\n                            curr = scanner.next();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    case 70:\n                        expectedCount = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value === tableDefinition.dxfSymbolName) {\n                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n            }\n            const tableRecords = table[tableDefinition.tableRecordsProperty];\n            if (tableRecords) {\n                let actualCount = (() => {\n                    if (tableRecords.constructor === Array) {\n                        return tableRecords.length;\n                    }\n                    else if (typeof (tableRecords) === 'object') {\n                        return Object.keys(tableRecords).length;\n                    }\n                    return undefined;\n                })();\n                if (expectedCount !== actualCount)\n                    log.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\n            }\n            curr = scanner.next();\n            return table;\n        }\n        function parseViewPortRecords() {\n            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\n            let viewPort = {};\n            log.debug('ViewPort {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        viewPort.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        viewPort.lowerLeftCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 11:\n                        viewPort.upperRightCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 12:\n                        viewPort.center = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 13:\n                        viewPort.snapBasePoint = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 14:\n                        viewPort.snapSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 15:\n                        viewPort.gridSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 16:\n                        viewPort.viewDirectionFromTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 17:\n                        viewPort.viewTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 42:\n                        viewPort.lensLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 43:\n                        viewPort.frontClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 44:\n                        viewPort.backClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 45:\n                        viewPort.viewHeight = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 50:\n                        viewPort.snapRotationAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 51:\n                        viewPort.viewTwistAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 79:\n                        viewPort.orthographicType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 111:\n                        viewPort.ucsXAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 112:\n                        viewPort.ucsYAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        viewPort.renderMode = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        // 0 is one distant light, 1 is two distant lights\n                        viewPort.defaultLightingType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 292:\n                        viewPort.defaultLightingOn = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        viewPort.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\n                    case 421:\n                    case 431:\n                        viewPort.ambientColor = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New ViewPort\n                        if (curr.value === 'VPORT') {\n                            log.debug('}');\n                            viewPorts.push(viewPort);\n                            log.debug('ViewPort {');\n                            viewPort = {};\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseTable() needs the current group\n            log.debug('}');\n            viewPorts.push(viewPort);\n            return viewPorts;\n        }\n        function parseLineTypes() {\n            const ltypes = {};\n            let ltype = {};\n            let length = 0;\n            let ltypeName;\n            log.debug('LType {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2:\n                        ltype.name = curr.value;\n                        ltypeName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        ltype.description = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 73: // Number of elements for this line type (dots, dashes, spaces);\n                        length = curr.value;\n                        if (length > 0)\n                            ltype.pattern = [];\n                        curr = scanner.next();\n                        break;\n                    case 40: // total pattern length\n                        ltype.patternLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 49:\n                        ltype.pattern.push(curr.value);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        log.debug('}');\n                        if (length > 0 && length !== ltype.pattern.length)\n                            log.warn('lengths do not match on LTYPE pattern');\n                        ltypes[ltypeName] = ltype;\n                        ltype = {};\n                        log.debug('LType {');\n                        curr = scanner.next();\n                        break;\n                    default:\n                        curr = scanner.next();\n                }\n            }\n            log.debug('}');\n            ltypes[ltypeName] = ltype;\n            return ltypes;\n        }\n        function parseLayers() {\n            const layers = {};\n            let layer = {};\n            let layerName;\n            log.debug('Layer {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        layer.name = curr.value;\n                        layerName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 62: // color, visibility\n                        layer.visible = curr.value >= 0;\n                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\n                        layer.colorIndex = Math.abs(curr.value);\n                        layer.color = getAcadColor(layer.colorIndex);\n                        curr = scanner.next();\n                        break;\n                    case 70: // frozen layer\n                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New Layer\n                        if (curr.value === 'LAYER') {\n                            log.debug('}');\n                            layers[layerName] = layer;\n                            log.debug('Layer {');\n                            layer = {};\n                            layerName = undefined;\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseLayerTable() needs the current group\n            log.debug('}');\n            layers[layerName] = layer;\n            return layers;\n        }\n        const tableDefinitions = {\n            VPORT: {\n                tableRecordsProperty: 'viewPorts',\n                tableName: 'viewPort',\n                dxfSymbolName: 'VPORT',\n                parseTableRecords: parseViewPortRecords\n            },\n            LTYPE: {\n                tableRecordsProperty: 'lineTypes',\n                tableName: 'lineType',\n                dxfSymbolName: 'LTYPE',\n                parseTableRecords: parseLineTypes\n            },\n            LAYER: {\n                tableRecordsProperty: 'layers',\n                tableName: 'layer',\n                dxfSymbolName: 'LAYER',\n                parseTableRecords: parseLayers\n            }\n        };\n        /**\n         * Is called after the parser first reads the 0:ENTITIES group. The scanner\n         * should be on the start of the first entity already.\n         * @return {Array} the resulting entities\n         */\n        function parseEntities(forBlock) {\n            const entities = [];\n            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\n            if (!forBlock) {\n                curr = scanner.next();\n            }\n            while (true) {\n                if (curr.code === 0) {\n                    if (curr.value === endingOnValue) {\n                        break;\n                    }\n                    const handler = self._entityHandlers[curr.value];\n                    if (handler != null) {\n                        log.debug(curr.value + ' {');\n                        const entity = handler.parseEntity(scanner, curr);\n                        curr = scanner.lastReadGroup;\n                        log.debug('}');\n                        ensureHandle(entity);\n                        entities.push(entity);\n                    }\n                    else {\n                        log.warn('Unhandled entity ' + curr.value);\n                        curr = scanner.next();\n                        continue;\n                    }\n                }\n                else {\n                    // ignored lines from unsupported entity\n                    curr = scanner.next();\n                }\n            }\n            if (endingOnValue == 'ENDSEC')\n                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\n            return entities;\n        }\n        /**\n         * Parses a 2D or 3D point, returning it as an object with x, y, and\n         * (sometimes) z property if it is 3D. It is assumed the current group\n         * is x of the point being read in, and scanner.next() will return the\n         * y. The parser will determine if there is a z point automatically.\n         * @return {Object} The 2D or 3D point as an object with x, y[, z]\n         */\n        function parsePoint(curr) {\n            const point = {};\n            let code = curr.code;\n            point.x = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code)\n                throw new Error('Expected code for point value to be ' + code +\n                    ' but got ' + curr.code + '.');\n            point.y = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code) {\n                scanner.rewind();\n                return point;\n            }\n            point.z = curr.value;\n            return point;\n        }\n        function ensureHandle(entity) {\n            if (!entity)\n                throw new TypeError('entity cannot be undefined or null');\n            if (!entity.handle)\n                entity.handle = lastHandle++;\n        }\n        parseAll();\n        return dxf;\n    }\n}\nfunction groupIs(group, code, value) {\n    return group.code === code && group.value === value;\n}\nfunction logUnhandledGroup(curr) {\n    log.debug('unhandled group ' + debugCode(curr));\n}\nfunction debugCode(curr) {\n    return curr.code + ':' + curr.value;\n}\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n    return AUTO_CAD_COLOR_INDEX[index];\n}\n// const BLOCK_ANONYMOUS_FLAG = 1;\n// const BLOCK_NON_CONSTANT_FLAG = 2;\n// const BLOCK_XREF_FLAG = 4;\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\n// const BLOCK_REFERENCED_XREF = 64;\n/* Notes */\n// Code 6 of an entity indicates inheritance of properties (eg. color).\n//   BYBLOCK means inherits from block\n//   BYLAYER (default) mean inherits from layer\n", "import DxfParser from './DxfParser';\nexport { default as DxfParser } from './DxfParser';\nexport default DxfParser;\n"],
  "mappings": "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A;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAC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",
  "names": ["log", "parsePoint", "getAcadColor", "curr"]
}
