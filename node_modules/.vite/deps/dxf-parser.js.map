{
  "version": 3,
  "sources": ["../../loglevel/lib/loglevel.js", "../../dxf-parser/dist/DxfArrayScanner.js", "../../dxf-parser/dist/AutoCadColorIndex.js", "../../dxf-parser/dist/ParseHelpers.js", "../../dxf-parser/dist/entities/3dface.js", "../../dxf-parser/dist/entities/arc.js", "../../dxf-parser/dist/entities/attdef.js", "../../dxf-parser/dist/entities/circle.js", "../../dxf-parser/dist/entities/dimension.js", "../../dxf-parser/dist/entities/ellipse.js", "../../dxf-parser/dist/entities/insert.js", "../../dxf-parser/dist/entities/line.js", "../../dxf-parser/dist/entities/lwpolyline.js", "../../dxf-parser/dist/entities/mtext.js", "../../dxf-parser/dist/entities/point.js", "../../dxf-parser/dist/entities/vertex.js", "../../dxf-parser/dist/entities/polyline.js", "../../dxf-parser/dist/entities/solid.js", "../../dxf-parser/dist/entities/spline.js", "../../dxf-parser/dist/entities/text.js", "../../dxf-parser/dist/DxfParser.js", "../../dxf-parser/dist/index.js"],
  "sourcesContent": ["/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\n(function (root, definition) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(definition);\r\n    } else if (typeof module === 'object' && module.exports) {\r\n        module.exports = definition();\r\n    } else {\r\n        root.log = definition();\r\n    }\r\n}(this, function () {\r\n    \"use strict\";\r\n\r\n    // Slightly dubious tricks to cut down minimized file size\r\n    var noop = function() {};\r\n    var undefinedType = \"undefined\";\r\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\r\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\r\n    );\r\n\r\n    var logMethods = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n    ];\r\n\r\n    var _loggersByName = {};\r\n    var defaultLogger = null;\r\n\r\n    // Cross-browser bind equivalent that works at least back to IE6\r\n    function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n            return method.bind(obj);\r\n        } else {\r\n            try {\r\n                return Function.prototype.bind.call(method, obj);\r\n            } catch (e) {\r\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n                return function() {\r\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\r\n    function traceForIE() {\r\n        if (console.log) {\r\n            if (console.log.apply) {\r\n                console.log.apply(console, arguments);\r\n            } else {\r\n                // In old IE, native console methods themselves don't have apply().\r\n                Function.prototype.apply.apply(console.log, [console, arguments]);\r\n            }\r\n        }\r\n        if (console.trace) console.trace();\r\n    }\r\n\r\n    // Build the best logging method possible for this env\r\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\r\n    function realMethod(methodName) {\r\n        if (methodName === 'debug') {\r\n            methodName = 'log';\r\n        }\r\n\r\n        if (typeof console === undefinedType) {\r\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\r\n        } else if (methodName === 'trace' && isIE) {\r\n            return traceForIE;\r\n        } else if (console[methodName] !== undefined) {\r\n            return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n            return bindMethod(console, 'log');\r\n        } else {\r\n            return noop;\r\n        }\r\n    }\r\n\r\n    // These private functions always need `this` to be set properly\r\n\r\n    function replaceLoggingMethods() {\r\n        /*jshint validthis:true */\r\n        var level = this.getLevel();\r\n\r\n        // Replace the actual methods.\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n            var methodName = logMethods[i];\r\n            this[methodName] = (i < level) ?\r\n                noop :\r\n                this.methodFactory(methodName, level, this.name);\r\n        }\r\n\r\n        // Define log.log as an alias for log.debug\r\n        this.log = this.debug;\r\n\r\n        // Return any important warnings.\r\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\r\n            return \"No console available for logging\";\r\n        }\r\n    }\r\n\r\n    // In old IE versions, the console isn't present until you first open it.\r\n    // We build realMethod() replacements here that regenerate logging methods\r\n    function enableLoggingWhenConsoleArrives(methodName) {\r\n        return function () {\r\n            if (typeof console !== undefinedType) {\r\n                replaceLoggingMethods.call(this);\r\n                this[methodName].apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n\r\n    // By default, we use closely bound real methods wherever possible, and\r\n    // otherwise we wait for a console to appear, and then try again.\r\n    function defaultMethodFactory(methodName, _level, _loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) ||\r\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n    }\r\n\r\n    function Logger(name, factory) {\r\n      // Private instance variables.\r\n      var self = this;\r\n      /**\r\n       * The level inherited from a parent logger (or a global default). We\r\n       * cache this here rather than delegating to the parent so that it stays\r\n       * in sync with the actual logging methods that we have installed (the\r\n       * parent could change levels but we might not have rebuilt the loggers\r\n       * in this child yet).\r\n       * @type {number}\r\n       */\r\n      var inheritedLevel;\r\n      /**\r\n       * The default level for this logger, if any. If set, this overrides\r\n       * `inheritedLevel`.\r\n       * @type {number|null}\r\n       */\r\n      var defaultLevel;\r\n      /**\r\n       * A user-specific level for this logger. If set, this overrides\r\n       * `defaultLevel`.\r\n       * @type {number|null}\r\n       */\r\n      var userLevel;\r\n\r\n      var storageKey = \"loglevel\";\r\n      if (typeof name === \"string\") {\r\n        storageKey += \":\" + name;\r\n      } else if (typeof name === \"symbol\") {\r\n        storageKey = undefined;\r\n      }\r\n\r\n      function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage[storageKey] = levelName;\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function getPersistedLevel() {\r\n          var storedLevel;\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          try {\r\n              storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          // Fallback to cookies if local storage gives us nothing\r\n          if (typeof storedLevel === undefinedType) {\r\n              try {\r\n                  var cookie = window.document.cookie;\r\n                  var cookieName = encodeURIComponent(storageKey);\r\n                  var location = cookie.indexOf(cookieName + \"=\");\r\n                  if (location !== -1) {\r\n                      storedLevel = /^([^;]+)/.exec(\r\n                          cookie.slice(location + cookieName.length + 1)\r\n                      )[1];\r\n                  }\r\n              } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n              storedLevel = undefined;\r\n          }\r\n\r\n          return storedLevel;\r\n      }\r\n\r\n      function clearPersistedLevel() {\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage.removeItem(storageKey);\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function normalizeLevel(input) {\r\n          var level = input;\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n              level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n              return level;\r\n          } else {\r\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\r\n          }\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Public logger API - see https://github.com/pimterry/loglevel for details\r\n       *\r\n       */\r\n\r\n      self.name = name;\r\n\r\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n          \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n      self.methodFactory = factory || defaultMethodFactory;\r\n\r\n      self.getLevel = function () {\r\n          if (userLevel != null) {\r\n            return userLevel;\r\n          } else if (defaultLevel != null) {\r\n            return defaultLevel;\r\n          } else {\r\n            return inheritedLevel;\r\n          }\r\n      };\r\n\r\n      self.setLevel = function (level, persist) {\r\n          userLevel = normalizeLevel(level);\r\n          if (persist !== false) {  // defaults to true\r\n              persistLevelIfPossible(userLevel);\r\n          }\r\n\r\n          // NOTE: in v2, this should call rebuild(), which updates children.\r\n          return replaceLoggingMethods.call(self);\r\n      };\r\n\r\n      self.setDefaultLevel = function (level) {\r\n          defaultLevel = normalizeLevel(level);\r\n          if (!getPersistedLevel()) {\r\n              self.setLevel(level, false);\r\n          }\r\n      };\r\n\r\n      self.resetLevel = function () {\r\n          userLevel = null;\r\n          clearPersistedLevel();\r\n          replaceLoggingMethods.call(self);\r\n      };\r\n\r\n      self.enableAll = function(persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n      };\r\n\r\n      self.disableAll = function(persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n      };\r\n\r\n      self.rebuild = function () {\r\n          if (defaultLogger !== self) {\r\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\r\n          }\r\n          replaceLoggingMethods.call(self);\r\n\r\n          if (defaultLogger === self) {\r\n              for (var childName in _loggersByName) {\r\n                _loggersByName[childName].rebuild();\r\n              }\r\n          }\r\n      };\r\n\r\n      // Initialize all the internal levels.\r\n      inheritedLevel = normalizeLevel(\r\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\r\n      );\r\n      var initialLevel = getPersistedLevel();\r\n      if (initialLevel != null) {\r\n          userLevel = normalizeLevel(initialLevel);\r\n      }\r\n      replaceLoggingMethods.call(self);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * Top-level API\r\n     *\r\n     */\r\n\r\n    defaultLogger = new Logger();\r\n\r\n    defaultLogger.getLogger = function getLogger(name) {\r\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\r\n            throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n            logger = _loggersByName[name] = new Logger(\r\n                name,\r\n                defaultLogger.methodFactory\r\n            );\r\n        }\r\n        return logger;\r\n    };\r\n\r\n    // Grab the current global log variable in case of overwrite\r\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n    defaultLogger.noConflict = function() {\r\n        if (typeof window !== undefinedType &&\r\n               window.log === defaultLogger) {\r\n            window.log = _log;\r\n        }\r\n\r\n        return defaultLogger;\r\n    };\r\n\r\n    defaultLogger.getLoggers = function getLoggers() {\r\n        return _loggersByName;\r\n    };\r\n\r\n    // ES6 default export, for compatibility\r\n    defaultLogger['default'] = defaultLogger;\r\n\r\n    return defaultLogger;\r\n}));\r\n", "/**\r\n * DxfArrayScanner\r\n *\r\n * Based off the AutoCad 2012 DXF Reference\r\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\r\n *\r\n * Reads through an array representing lines of a dxf file. Takes an array and\r\n * provides an easy interface to extract group code and value pairs.\r\n * @param data - an array where each element represents a line in the dxf file\r\n * @constructor\r\n */\r\nexport default class DxfArrayScanner {\r\n    constructor(data) {\r\n        this._pointer = 0;\r\n        this._eof = false;\r\n        this._data = data;\r\n    }\r\n    /**\r\n     * Gets the next group (code, value) from the array. A group is two consecutive elements\r\n     * in the array. The first is the code, the second is the value.\r\n     * @returns {{code: Number}|*}\r\n     */\r\n    next() {\r\n        if (!this.hasNext()) {\r\n            if (!this._eof)\r\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\r\n            else\r\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\r\n        }\r\n        const group = {\r\n            code: parseInt(this._data[this._pointer])\r\n        };\r\n        this._pointer++;\r\n        group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\r\n        this._pointer++;\r\n        if (group.code === 0 && group.value === 'EOF')\r\n            this._eof = true;\r\n        this.lastReadGroup = group;\r\n        return group;\r\n    }\r\n    peek() {\r\n        if (!this.hasNext()) {\r\n            if (!this._eof)\r\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\r\n            else\r\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\r\n        }\r\n        const group = {\r\n            code: parseInt(this._data[this._pointer])\r\n        };\r\n        group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\r\n        return group;\r\n    }\r\n    rewind(numberOfGroups = 1) {\r\n        this._pointer = this._pointer - numberOfGroups * 2;\r\n    }\r\n    /**\r\n     * Returns true if there is another code/value pair (2 elements in the array).\r\n     * @returns {boolean}\r\n     */\r\n    hasNext() {\r\n        // Check if we have read EOF group code\r\n        if (this._eof) {\r\n            return false;\r\n        }\r\n        // We need to be sure there are two lines available\r\n        if (this._pointer > this._data.length - 2) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns true if the scanner is at the end of the array\r\n     * @returns {boolean}\r\n     */\r\n    isEOF() {\r\n        return this._eof;\r\n    }\r\n}\r\n/**\r\n * Parse a value to its proper type.\r\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\r\n *\r\n * @param code\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction parseGroupValue(code, value) {\r\n    if (code <= 9)\r\n        return value;\r\n    if (code >= 10 && code <= 59)\r\n        return parseFloat(value);\r\n    if (code >= 60 && code <= 99)\r\n        return parseInt(value);\r\n    if (code >= 100 && code <= 109)\r\n        return value;\r\n    if (code >= 110 && code <= 149)\r\n        return parseFloat(value);\r\n    if (code >= 160 && code <= 179)\r\n        return parseInt(value);\r\n    if (code >= 210 && code <= 239)\r\n        return parseFloat(value);\r\n    if (code >= 270 && code <= 289)\r\n        return parseInt(value);\r\n    if (code >= 290 && code <= 299)\r\n        return parseBoolean(value);\r\n    if (code >= 300 && code <= 369)\r\n        return value;\r\n    if (code >= 370 && code <= 389)\r\n        return parseInt(value);\r\n    if (code >= 390 && code <= 399)\r\n        return value;\r\n    if (code >= 400 && code <= 409)\r\n        return parseInt(value);\r\n    if (code >= 410 && code <= 419)\r\n        return value;\r\n    if (code >= 420 && code <= 429)\r\n        return parseInt(value);\r\n    if (code >= 430 && code <= 439)\r\n        return value;\r\n    if (code >= 440 && code <= 459)\r\n        return parseInt(value);\r\n    if (code >= 460 && code <= 469)\r\n        return parseFloat(value);\r\n    if (code >= 470 && code <= 481)\r\n        return value;\r\n    if (code === 999)\r\n        return value;\r\n    if (code >= 1000 && code <= 1009)\r\n        return value;\r\n    if (code >= 1010 && code <= 1059)\r\n        return parseFloat(value);\r\n    if (code >= 1060 && code <= 1071)\r\n        return parseInt(value);\r\n    console.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\r\n    return value;\r\n}\r\n/**\r\n * Parse a boolean according to a 1 or 0 value\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nfunction parseBoolean(str) {\r\n    if (str === '0')\r\n        return false;\r\n    if (str === '1')\r\n        return true;\r\n    throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\r\n}\r\n", "/**\r\n * AutoCad files sometimes use an indexed color value between 1 and 255 inclusive.\r\n * Each value corresponds to a color. index 1 is red, that is 16711680 or 0xFF0000.\r\n * index 0 and 256, while included in this array, are actually reserved for inheritance\r\n * values in AutoCad so they should not be used for index color lookups.\r\n */\r\nexport default [\r\n    0,\r\n    16711680,\r\n    16776960,\r\n    65280,\r\n    65535,\r\n    255,\r\n    16711935,\r\n    16777215,\r\n    8421504,\r\n    12632256,\r\n    16711680,\r\n    16744319,\r\n    13369344,\r\n    13395558,\r\n    10027008,\r\n    10046540,\r\n    8323072,\r\n    8339263,\r\n    4980736,\r\n    4990502,\r\n    16727808,\r\n    16752511,\r\n    13382400,\r\n    13401958,\r\n    10036736,\r\n    10051404,\r\n    8331008,\r\n    8343359,\r\n    4985600,\r\n    4992806,\r\n    16744192,\r\n    16760703,\r\n    13395456,\r\n    13408614,\r\n    10046464,\r\n    10056268,\r\n    8339200,\r\n    8347455,\r\n    4990464,\r\n    4995366,\r\n    16760576,\r\n    16768895,\r\n    13408512,\r\n    13415014,\r\n    10056192,\r\n    10061132,\r\n    8347392,\r\n    8351551,\r\n    4995328,\r\n    4997670,\r\n    16776960,\r\n    16777087,\r\n    13421568,\r\n    13421670,\r\n    10000384,\r\n    10000460,\r\n    8355584,\r\n    8355647,\r\n    5000192,\r\n    5000230,\r\n    12582656,\r\n    14679935,\r\n    10079232,\r\n    11717734,\r\n    7510016,\r\n    8755276,\r\n    6258432,\r\n    7307071,\r\n    3755008,\r\n    4344870,\r\n    8388352,\r\n    12582783,\r\n    6736896,\r\n    10079334,\r\n    5019648,\r\n    7510092,\r\n    4161280,\r\n    6258495,\r\n    2509824,\r\n    3755046,\r\n    4194048,\r\n    10485631,\r\n    3394560,\r\n    8375398,\r\n    2529280,\r\n    6264908,\r\n    2064128,\r\n    5209919,\r\n    1264640,\r\n    3099686,\r\n    65280,\r\n    8388479,\r\n    52224,\r\n    6736998,\r\n    38912,\r\n    5019724,\r\n    32512,\r\n    4161343,\r\n    19456,\r\n    2509862,\r\n    65343,\r\n    8388511,\r\n    52275,\r\n    6737023,\r\n    38950,\r\n    5019743,\r\n    32543,\r\n    4161359,\r\n    19475,\r\n    2509871,\r\n    65407,\r\n    8388543,\r\n    52326,\r\n    6737049,\r\n    38988,\r\n    5019762,\r\n    32575,\r\n    4161375,\r\n    19494,\r\n    2509881,\r\n    65471,\r\n    8388575,\r\n    52377,\r\n    6737074,\r\n    39026,\r\n    5019781,\r\n    32607,\r\n    4161391,\r\n    19513,\r\n    2509890,\r\n    65535,\r\n    8388607,\r\n    52428,\r\n    6737100,\r\n    39064,\r\n    5019800,\r\n    32639,\r\n    4161407,\r\n    19532,\r\n    2509900,\r\n    49151,\r\n    8380415,\r\n    39372,\r\n    6730444,\r\n    29336,\r\n    5014936,\r\n    24447,\r\n    4157311,\r\n    14668,\r\n    2507340,\r\n    32767,\r\n    8372223,\r\n    26316,\r\n    6724044,\r\n    19608,\r\n    5010072,\r\n    16255,\r\n    4153215,\r\n    9804,\r\n    2505036,\r\n    16383,\r\n    8364031,\r\n    13260,\r\n    6717388,\r\n    9880,\r\n    5005208,\r\n    8063,\r\n    4149119,\r\n    4940,\r\n    2502476,\r\n    255,\r\n    8355839,\r\n    204,\r\n    6710988,\r\n    152,\r\n    5000344,\r\n    127,\r\n    4145023,\r\n    76,\r\n    2500172,\r\n    4129023,\r\n    10452991,\r\n    3342540,\r\n    8349388,\r\n    2490520,\r\n    6245528,\r\n    2031743,\r\n    5193599,\r\n    1245260,\r\n    3089996,\r\n    8323327,\r\n    12550143,\r\n    6684876,\r\n    10053324,\r\n    4980888,\r\n    7490712,\r\n    4128895,\r\n    6242175,\r\n    2490444,\r\n    3745356,\r\n    12517631,\r\n    14647295,\r\n    10027212,\r\n    11691724,\r\n    7471256,\r\n    8735896,\r\n    6226047,\r\n    7290751,\r\n    3735628,\r\n    4335180,\r\n    16711935,\r\n    16744447,\r\n    13369548,\r\n    13395660,\r\n    9961624,\r\n    9981080,\r\n    8323199,\r\n    8339327,\r\n    4980812,\r\n    4990540,\r\n    16711871,\r\n    16744415,\r\n    13369497,\r\n    13395634,\r\n    9961586,\r\n    9981061,\r\n    8323167,\r\n    8339311,\r\n    4980793,\r\n    4990530,\r\n    16711807,\r\n    16744383,\r\n    13369446,\r\n    13395609,\r\n    9961548,\r\n    9981042,\r\n    8323135,\r\n    8339295,\r\n    4980774,\r\n    4990521,\r\n    16711743,\r\n    16744351,\r\n    13369395,\r\n    13395583,\r\n    9961510,\r\n    9981023,\r\n    8323103,\r\n    8339279,\r\n    4980755,\r\n    4990511,\r\n    3355443,\r\n    5987163,\r\n    8684676,\r\n    11382189,\r\n    14079702,\r\n    16777215\r\n];\r\n", "import AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\r\n/**\r\n * Returns the truecolor value of the given AutoCad color index value\r\n * @return {Number} truecolor value as a number\r\n */\r\nexport function getAcadColor(index) {\r\n    return AUTO_CAD_COLOR_INDEX[index];\r\n}\r\n/**\r\n * Parses the 2D or 3D coordinate, vector, or point. When complete,\r\n * the scanner remains on the last group of the coordinate.\r\n * @param {*} scanner\r\n */\r\nexport function parsePoint(scanner) {\r\n    const point = {};\r\n    // Reread group for the first coordinate\r\n    scanner.rewind();\r\n    let curr = scanner.next();\r\n    let code = curr.code;\r\n    point.x = curr.value;\r\n    code += 10;\r\n    curr = scanner.next();\r\n    if (curr.code != code)\r\n        throw new Error('Expected code for point value to be ' + code +\r\n            ' but got ' + curr.code + '.');\r\n    point.y = curr.value;\r\n    code += 10;\r\n    curr = scanner.next();\r\n    if (curr.code != code) {\r\n        // Only the x and y are specified. Don't read z.\r\n        scanner.rewind(); // Let the calling code advance off the point\r\n        return point;\r\n    }\r\n    point.z = curr.value;\r\n    return point;\r\n}\r\n/**\r\n * Attempts to parse codes common to all entities. Returns true if the group\r\n * was handled by this function.\r\n * @param {*} entity - the entity currently being parsed\r\n * @param {*} curr - the current group being parsed\r\n */\r\nexport function checkCommonEntityProperties(entity, curr, scanner) {\r\n    switch (curr.code) {\r\n        case 0:\r\n            entity.type = curr.value;\r\n            break;\r\n        case 5:\r\n            entity.handle = curr.value;\r\n            break;\r\n        case 6:\r\n            entity.lineType = curr.value;\r\n            break;\r\n        case 8: // Layer name\r\n            entity.layer = curr.value;\r\n            break;\r\n        case 48:\r\n            entity.lineTypeScale = curr.value;\r\n            break;\r\n        case 60:\r\n            entity.visible = curr.value === 0;\r\n            break;\r\n        case 62: // Acad Index Color. 0 inherits ByBlock. 256 inherits ByLayer. Default is bylayer\r\n            entity.colorIndex = curr.value;\r\n            entity.color = getAcadColor(Math.abs(curr.value));\r\n            break;\r\n        case 67:\r\n            entity.inPaperSpace = curr.value !== 0;\r\n            break;\r\n        case 100:\r\n            //ignore\r\n            break;\r\n        case 101: // Embedded Object in ACAD 2018.\r\n            // See https://ezdxf.readthedocs.io/en/master/dxfinternals/dxftags.html#embedded-objects\r\n            while (curr.code != 0) {\r\n                curr = scanner.next();\r\n            }\r\n            scanner.rewind();\r\n            break;\r\n        case 330:\r\n            entity.ownerHandle = curr.value;\r\n            break;\r\n        case 347:\r\n            entity.materialObjectHandle = curr.value;\r\n            break;\r\n        case 370:\r\n            //From https://www.woutware.com/Forum/Topic/955/lineweight?returnUrl=%2FForum%2FUserPosts%3FuserId%3D478262319\r\n            // An integer representing 100th of mm, must be one of the following values:\r\n            // 0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.\r\n            // -3 = STANDARD, -2 = BYLAYER, -1 = BYBLOCK\r\n            entity.lineweight = curr.value;\r\n            break;\r\n        case 420: // TrueColor Color\r\n            entity.color = curr.value;\r\n            break;\r\n        case 1000:\r\n            entity.extendedData = entity.extendedData || {};\r\n            entity.extendedData.customStrings = entity.extendedData.customStrings || [];\r\n            entity.extendedData.customStrings.push(curr.value);\r\n            break;\r\n        case 1001:\r\n            entity.extendedData = entity.extendedData || {};\r\n            entity.extendedData.applicationName = curr.value;\r\n            break;\r\n        default:\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class ThreeDface {\r\n    constructor() {\r\n        this.ForEntityName = '3DFACE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value, vertices: [] };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\r\n                    entity.shape = ((curr.value & 1) === 1);\r\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\r\n                    break;\r\n                case 10: // X coordinate of point\r\n                    entity.vertices = parse3dFaceVertices(scanner, curr);\r\n                    curr = scanner.lastReadGroup;\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\nfunction parse3dFaceVertices(scanner, curr) {\r\n    var vertices = [];\r\n    var vertexIsStarted = false;\r\n    var vertexIsFinished = false;\r\n    var verticesPer3dFace = 4; // there can be up to four vertices per face, although 3 is most used for TIN\r\n    for (let i = 0; i <= verticesPer3dFace; i++) {\r\n        var vertex = {};\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0 || vertexIsFinished)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X0\r\n                case 11: // X1\r\n                case 12: // X2\r\n                case 13: // X3\r\n                    if (vertexIsStarted) {\r\n                        vertexIsFinished = true;\r\n                        continue;\r\n                    }\r\n                    vertex.x = curr.value;\r\n                    vertexIsStarted = true;\r\n                    break;\r\n                case 20: // Y\r\n                case 21:\r\n                case 22:\r\n                case 23:\r\n                    vertex.y = curr.value;\r\n                    break;\r\n                case 30: // Z\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                    vertex.z = curr.value;\r\n                    break;\r\n                default:\r\n                    // it is possible to have entity codes after the vertices.  \r\n                    // So if code is not accounted for return to entity parser where it might be accounted for\r\n                    return vertices;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\r\n        vertices.push(vertex);\r\n        vertexIsStarted = false;\r\n        vertexIsFinished = false;\r\n    }\r\n    scanner.rewind();\r\n    return vertices;\r\n}\r\n;\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Arc {\r\n    constructor() {\r\n        this.ForEntityName = 'ARC';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X coordinate of point\r\n                    entity.center = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40: // radius\r\n                    entity.radius = curr.value;\r\n                    break;\r\n                case 50: // start angle\r\n                    entity.startAngle = Math.PI / 180 * curr.value;\r\n                    break;\r\n                case 51: // end angle\r\n                    entity.endAngle = Math.PI / 180 * curr.value;\r\n                    entity.angleLength = entity.endAngle - entity.startAngle; // angleLength is deprecated\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirectionX = curr.value;\r\n                    break;\r\n                case 220:\r\n                    entity.extrusionDirectionY = curr.value;\r\n                    break;\r\n                case 230:\r\n                    entity.extrusionDirectionZ = curr.value;\r\n                    break;\r\n                default: // ignored attribute\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Attdef {\r\n    constructor() {\r\n        this.ForEntityName = 'ATTDEF';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        var entity = {\r\n            type: curr.value,\r\n            scale: 1,\r\n            textStyle: 'STANDARD'\r\n        };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0) {\r\n                break;\r\n            }\r\n            switch (curr.code) {\r\n                case 1:\r\n                    entity.text = curr.value;\r\n                    break;\r\n                case 2:\r\n                    entity.tag = curr.value;\r\n                    break;\r\n                case 3:\r\n                    entity.prompt = curr.value;\r\n                    break;\r\n                case 7:\r\n                    entity.textStyle = curr.value;\r\n                    break;\r\n                case 10: // X coordinate of 'first alignment point'\r\n                    entity.startPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11: // X coordinate of 'second alignment point'\r\n                    entity.endPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 39:\r\n                    entity.thickness = curr.value;\r\n                    break;\r\n                case 40:\r\n                    entity.textHeight = curr.value;\r\n                    break;\r\n                case 41:\r\n                    entity.scale = curr.value;\r\n                    break;\r\n                case 50:\r\n                    entity.rotation = curr.value;\r\n                    break;\r\n                case 51:\r\n                    entity.obliqueAngle = curr.value;\r\n                    break;\r\n                case 70:\r\n                    entity.invisible = !!(curr.value & 0x01);\r\n                    entity.constant = !!(curr.value & 0x02);\r\n                    entity.verificationRequired = !!(curr.value & 0x04);\r\n                    entity.preset = !!(curr.value & 0x08);\r\n                    break;\r\n                case 71:\r\n                    entity.backwards = !!(curr.value & 0x02);\r\n                    entity.mirrored = !!(curr.value & 0x04);\r\n                    break;\r\n                case 72:\r\n                    // TODO: enum values?\r\n                    entity.horizontalJustification = curr.value;\r\n                    break;\r\n                case 73:\r\n                    entity.fieldLength = curr.value;\r\n                    break;\r\n                case 74:\r\n                    // TODO: enum values?\r\n                    entity.verticalJustification = curr.value;\r\n                    break;\r\n                case 100:\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirectionX = curr.value;\r\n                    break;\r\n                case 220:\r\n                    entity.extrusionDirectionY = curr.value;\r\n                    break;\r\n                case 230:\r\n                    entity.extrusionDirectionZ = curr.value;\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Circle {\r\n    constructor() {\r\n        this.ForEntityName = 'CIRCLE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X coordinate of point\r\n                    entity.center = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40: // radius\r\n                    entity.radius = curr.value;\r\n                    break;\r\n                case 50: // start angle\r\n                    entity.startAngle = Math.PI / 180 * curr.value;\r\n                    break;\r\n                case 51: // end angle\r\n                    const endAngle = Math.PI / 180 * curr.value;\r\n                    if (endAngle < entity.startAngle)\r\n                        entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;\r\n                    else\r\n                        entity.angleLength = endAngle - entity.startAngle;\r\n                    entity.endAngle = endAngle;\r\n                    break;\r\n                default: // ignored attribute\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Dimension {\r\n    constructor() {\r\n        this.ForEntityName = 'DIMENSION';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 2: // Referenced block name\r\n                    entity.block = curr.value;\r\n                    break;\r\n                case 10: // X coordinate of 'first alignment point'\r\n                    entity.anchorPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11:\r\n                    entity.middleOfText = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 12: // Insertion point for clones of a dimension\r\n                    entity.insertionPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 13: // Definition point for linear and angular dimensions \r\n                    entity.linearOrAngularPoint1 = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 14: // Definition point for linear and angular dimensions \r\n                    entity.linearOrAngularPoint2 = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 15: // Definition point for diameter, radius, and angular dimensions\r\n                    entity.diameterOrRadiusPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 16: // Point defining dimension arc for angular dimensions\r\n                    entity.arcPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 70: // Dimension type\r\n                    entity.dimensionType = curr.value;\r\n                    break;\r\n                case 71: // 5 = Middle center\r\n                    entity.attachmentPoint = curr.value;\r\n                    break;\r\n                case 42: // Actual measurement\r\n                    entity.actualMeasurement = curr.value;\r\n                    break;\r\n                case 1: // Text entered by user explicitly\r\n                    entity.text = curr.value;\r\n                    break;\r\n                case 50: // Angle of rotated, horizontal, or vertical dimensions\r\n                    entity.angle = curr.value;\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Ellipse {\r\n    constructor() {\r\n        this.ForEntityName = 'ELLIPSE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10:\r\n                    entity.center = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11:\r\n                    entity.majorAxisEndPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40:\r\n                    entity.axisRatio = curr.value;\r\n                    break;\r\n                case 41:\r\n                    entity.startAngle = curr.value;\r\n                    break;\r\n                case 42:\r\n                    entity.endAngle = curr.value;\r\n                    break;\r\n                case 2:\r\n                    entity.name = curr.value;\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Insert {\r\n    constructor() {\r\n        this.ForEntityName = 'INSERT';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 2:\r\n                    entity.name = curr.value;\r\n                    break;\r\n                case 41:\r\n                    entity.xScale = curr.value;\r\n                    break;\r\n                case 42:\r\n                    entity.yScale = curr.value;\r\n                    break;\r\n                case 43:\r\n                    entity.zScale = curr.value;\r\n                    break;\r\n                case 10:\r\n                    entity.position = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 50:\r\n                    entity.rotation = curr.value;\r\n                    break;\r\n                case 70:\r\n                    entity.columnCount = curr.value;\r\n                    break;\r\n                case 71:\r\n                    entity.rowCount = curr.value;\r\n                    break;\r\n                case 44:\r\n                    entity.columnSpacing = curr.value;\r\n                    break;\r\n                case 45:\r\n                    entity.rowSpacing = curr.value;\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Line {\r\n    constructor() {\r\n        this.ForEntityName = 'LINE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value, vertices: [] };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X coordinate of point\r\n                    entity.vertices.unshift(helpers.parsePoint(scanner));\r\n                    break;\r\n                case 11:\r\n                    entity.vertices.push(helpers.parsePoint(scanner));\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 100:\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Lwpolyline {\r\n    constructor() {\r\n        this.ForEntityName = 'LWPOLYLINE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value, vertices: [] };\r\n        let numberOfVertices = 0;\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 38:\r\n                    entity.elevation = curr.value;\r\n                    break;\r\n                case 39:\r\n                    entity.depth = curr.value;\r\n                    break;\r\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\r\n                    entity.shape = ((curr.value & 1) === 1);\r\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\r\n                    break;\r\n                case 90:\r\n                    numberOfVertices = curr.value;\r\n                    break;\r\n                case 10: // X coordinate of point\r\n                    entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\r\n                    break;\r\n                case 43:\r\n                    if (curr.value !== 0)\r\n                        entity.width = curr.value;\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirectionX = curr.value;\r\n                    break;\r\n                case 220:\r\n                    entity.extrusionDirectionY = curr.value;\r\n                    break;\r\n                case 230:\r\n                    entity.extrusionDirectionZ = curr.value;\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\nfunction parseLWPolylineVertices(n, scanner) {\r\n    if (!n || n <= 0)\r\n        throw Error('n must be greater than 0 verticies');\r\n    const vertices = [];\r\n    let vertexIsStarted = false;\r\n    let vertexIsFinished = false;\r\n    let curr = scanner.lastReadGroup;\r\n    for (let i = 0; i < n; i++) {\r\n        const vertex = {};\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0 || vertexIsFinished)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X\r\n                    if (vertexIsStarted) {\r\n                        vertexIsFinished = true;\r\n                        continue;\r\n                    }\r\n                    vertex.x = curr.value;\r\n                    vertexIsStarted = true;\r\n                    break;\r\n                case 20: // Y\r\n                    vertex.y = curr.value;\r\n                    break;\r\n                case 30: // Z\r\n                    vertex.z = curr.value;\r\n                    break;\r\n                case 40: // start width\r\n                    vertex.startWidth = curr.value;\r\n                    break;\r\n                case 41: // end width\r\n                    vertex.endWidth = curr.value;\r\n                    break;\r\n                case 42: // bulge\r\n                    if (curr.value != 0)\r\n                        vertex.bulge = curr.value;\r\n                    break;\r\n                default:\r\n                    // if we do not hit known code return vertices.  Code might belong to entity\r\n                    scanner.rewind();\r\n                    if (vertexIsStarted) {\r\n                        vertices.push(vertex);\r\n                    }\r\n                    scanner.rewind();\r\n                    return vertices;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\r\n        vertices.push(vertex);\r\n        vertexIsStarted = false;\r\n        vertexIsFinished = false;\r\n    }\r\n    scanner.rewind();\r\n    return vertices;\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Mtext {\r\n    constructor() {\r\n        this.ForEntityName = 'MTEXT';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 3:\r\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\r\n                    break;\r\n                case 1:\r\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\r\n                    break;\r\n                case 10:\r\n                    entity.position = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11:\r\n                    entity.directionVector = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40:\r\n                    //Note: this is the text height\r\n                    entity.height = curr.value;\r\n                    break;\r\n                case 41:\r\n                    entity.width = curr.value;\r\n                    break;\r\n                case 50:\r\n                    entity.rotation = curr.value;\r\n                    break;\r\n                case 71:\r\n                    entity.attachmentPoint = curr.value;\r\n                    break;\r\n                case 72:\r\n                    entity.drawingDirection = curr.value;\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Point {\r\n    constructor() {\r\n        this.ForEntityName = 'POINT';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const type = curr.value;\r\n        const entity = { type };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10:\r\n                    entity.position = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 39:\r\n                    entity.thickness = curr.value;\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 100:\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Vertex {\r\n    constructor() {\r\n        this.ForEntityName = 'VERTEX';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        var entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X\r\n                    entity.x = curr.value;\r\n                    break;\r\n                case 20: // Y\r\n                    entity.y = curr.value;\r\n                    break;\r\n                case 30: // Z\r\n                    entity.z = curr.value;\r\n                    break;\r\n                case 40: // start width\r\n                    break;\r\n                case 41: // end width\r\n                    break;\r\n                case 42: // bulge\r\n                    if (curr.value != 0)\r\n                        entity.bulge = curr.value;\r\n                    break;\r\n                case 70: // flags\r\n                    entity.curveFittingVertex = (curr.value & 1) !== 0;\r\n                    entity.curveFitTangent = (curr.value & 2) !== 0;\r\n                    entity.splineVertex = (curr.value & 8) !== 0;\r\n                    entity.splineControlPoint = (curr.value & 16) !== 0;\r\n                    entity.threeDPolylineVertex = (curr.value & 32) !== 0;\r\n                    entity.threeDPolylineMesh = (curr.value & 64) !== 0;\r\n                    entity.polyfaceMeshVertex = (curr.value & 128) !== 0;\r\n                    break;\r\n                case 50: // curve fit tangent direction\r\n                    break;\r\n                case 71: // polyface mesh vertex index\r\n                    entity.faceA = curr.value;\r\n                    break;\r\n                case 72: // polyface mesh vertex index\r\n                    entity.faceB = curr.value;\r\n                    break;\r\n                case 73: // polyface mesh vertex index\r\n                    entity.faceC = curr.value;\r\n                    break;\r\n                case 74: // polyface mesh vertex index\r\n                    entity.faceD = curr.value;\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nimport VertexParser from './vertex';\r\nexport default class Polyline {\r\n    constructor() {\r\n        this.ForEntityName = 'POLYLINE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        var entity = { type: curr.value, vertices: [] };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // always 0\r\n                    break;\r\n                case 20: // always 0\r\n                    break;\r\n                case 30: // elevation\r\n                    break;\r\n                case 39: // thickness\r\n                    entity.thickness = curr.value;\r\n                    break;\r\n                case 40: // start width\r\n                    break;\r\n                case 41: // end width\r\n                    break;\r\n                case 70:\r\n                    entity.shape = (curr.value & 1) !== 0;\r\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\r\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\r\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\r\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\r\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\r\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\r\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\r\n                    break;\r\n                case 71: // Polygon mesh M vertex count\r\n                    break;\r\n                case 72: // Polygon mesh N vertex count\r\n                    break;\r\n                case 73: // Smooth surface M density\r\n                    break;\r\n                case 74: // Smooth surface N density\r\n                    break;\r\n                case 75: // Curves and smooth surface type\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        entity.vertices = parsePolylineVertices(scanner, curr);\r\n        return entity;\r\n    }\r\n}\r\nfunction parsePolylineVertices(scanner, curr) {\r\n    const vertexParser = new VertexParser();\r\n    const vertices = [];\r\n    while (!scanner.isEOF()) {\r\n        if (curr.code === 0) {\r\n            if (curr.value === 'VERTEX') {\r\n                vertices.push(vertexParser.parseEntity(scanner, curr));\r\n                curr = scanner.lastReadGroup;\r\n            }\r\n            else if (curr.value === 'SEQEND') {\r\n                parseSeqEnd(scanner, curr);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return vertices;\r\n}\r\nfunction parseSeqEnd(scanner, curr) {\r\n    const entity = { type: curr.value };\r\n    curr = scanner.next();\r\n    while (!scanner.isEOF()) {\r\n        if (curr.code == 0)\r\n            break;\r\n        helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n        curr = scanner.next();\r\n    }\r\n    return entity;\r\n}\r\n;\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Solid {\r\n    constructor() {\r\n        this.ForEntityName = 'SOLID';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value, points: [] };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10:\r\n                    entity.points[0] = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11:\r\n                    entity.points[1] = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 12:\r\n                    entity.points[2] = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 13:\r\n                    entity.points[3] = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 210:\r\n                    entity.extrusionDirection = helpers.parsePoint(scanner);\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Spline {\r\n    constructor() {\r\n        this.ForEntityName = 'SPLINE';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10:\r\n                    if (!entity.controlPoints)\r\n                        entity.controlPoints = [];\r\n                    entity.controlPoints.push(helpers.parsePoint(scanner));\r\n                    break;\r\n                case 11:\r\n                    if (!entity.fitPoints)\r\n                        entity.fitPoints = [];\r\n                    entity.fitPoints.push(helpers.parsePoint(scanner));\r\n                    break;\r\n                case 12:\r\n                    entity.startTangent = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 13:\r\n                    entity.endTangent = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40:\r\n                    if (!entity.knotValues)\r\n                        entity.knotValues = [];\r\n                    entity.knotValues.push(curr.value);\r\n                    break;\r\n                case 70:\r\n                    if ((curr.value & 1) != 0)\r\n                        entity.closed = true;\r\n                    if ((curr.value & 2) != 0)\r\n                        entity.periodic = true;\r\n                    if ((curr.value & 4) != 0)\r\n                        entity.rational = true;\r\n                    if ((curr.value & 8) != 0)\r\n                        entity.planar = true;\r\n                    if ((curr.value & 16) != 0) {\r\n                        entity.planar = true;\r\n                        entity.linear = true;\r\n                    }\r\n                    break;\r\n                case 71:\r\n                    entity.degreeOfSplineCurve = curr.value;\r\n                    break;\r\n                case 72:\r\n                    entity.numberOfKnots = curr.value;\r\n                    break;\r\n                case 73:\r\n                    entity.numberOfControlPoints = curr.value;\r\n                    break;\r\n                case 74:\r\n                    entity.numberOfFitPoints = curr.value;\r\n                    break;\r\n                case 210:\r\n                    entity.normalVector = helpers.parsePoint(scanner);\r\n                    break;\r\n                default:\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import * as helpers from '../ParseHelpers';\r\nexport default class Text {\r\n    constructor() {\r\n        this.ForEntityName = 'TEXT';\r\n    }\r\n    parseEntity(scanner, curr) {\r\n        const entity = { type: curr.value };\r\n        curr = scanner.next();\r\n        while (!scanner.isEOF()) {\r\n            if (curr.code === 0)\r\n                break;\r\n            switch (curr.code) {\r\n                case 10: // X coordinate of 'first alignment point'\r\n                    entity.startPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 11: // X coordinate of 'second alignment point'\r\n                    entity.endPoint = helpers.parsePoint(scanner);\r\n                    break;\r\n                case 40: // Text height\r\n                    entity.textHeight = curr.value;\r\n                    break;\r\n                case 41:\r\n                    entity.xScale = curr.value;\r\n                    break;\r\n                case 50: // Rotation in degrees\r\n                    entity.rotation = curr.value;\r\n                    break;\r\n                case 1: // Text\r\n                    entity.text = curr.value;\r\n                    break;\r\n                // NOTE: 72 and 73 are meaningless without 11 (second alignment point)\r\n                case 72: // Horizontal alignment\r\n                    entity.halign = curr.value;\r\n                    break;\r\n                case 73: // Vertical alignment\r\n                    entity.valign = curr.value;\r\n                    break;\r\n                default: // check common entity attributes\r\n                    helpers.checkCommonEntityProperties(entity, curr, scanner);\r\n                    break;\r\n            }\r\n            curr = scanner.next();\r\n        }\r\n        return entity;\r\n    }\r\n}\r\n", "import DxfArrayScanner from './DxfArrayScanner';\r\nimport AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';\r\nimport Face from './entities/3dface';\r\nimport Arc from './entities/arc';\r\nimport AttDef from './entities/attdef';\r\nimport Circle from './entities/circle';\r\nimport Dimension from './entities/dimension';\r\nimport Ellipse from './entities/ellipse';\r\nimport Insert from './entities/insert';\r\nimport Line from './entities/line';\r\nimport LWPolyline from './entities/lwpolyline';\r\nimport MText from './entities/mtext';\r\nimport Point from './entities/point';\r\nimport Polyline from './entities/polyline';\r\nimport Solid from './entities/solid';\r\nimport Spline from './entities/spline';\r\nimport Text from './entities/text';\r\n//import Vertex from './entities/';\r\nimport log from 'loglevel';\r\n//log.setLevel('trace');\r\n//log.setLevel('debug');\r\n//log.setLevel('info');\r\n//log.setLevel('warn');\r\nlog.setLevel('error');\r\nfunction registerDefaultEntityHandlers(dxfParser) {\r\n    // Supported entities here (some entity code is still being refactored into this flow)\r\n    dxfParser.registerEntityHandler(Face);\r\n    dxfParser.registerEntityHandler(Arc);\r\n    dxfParser.registerEntityHandler(AttDef);\r\n    dxfParser.registerEntityHandler(Circle);\r\n    dxfParser.registerEntityHandler(Dimension);\r\n    dxfParser.registerEntityHandler(Ellipse);\r\n    dxfParser.registerEntityHandler(Insert);\r\n    dxfParser.registerEntityHandler(Line);\r\n    dxfParser.registerEntityHandler(LWPolyline);\r\n    dxfParser.registerEntityHandler(MText);\r\n    dxfParser.registerEntityHandler(Point);\r\n    dxfParser.registerEntityHandler(Polyline);\r\n    dxfParser.registerEntityHandler(Solid);\r\n    dxfParser.registerEntityHandler(Spline);\r\n    dxfParser.registerEntityHandler(Text);\r\n    //dxfParser.registerEntityHandler(require('./entities/vertex'));\r\n}\r\nexport default class DxfParser {\r\n    constructor() {\r\n        this._entityHandlers = {};\r\n        registerDefaultEntityHandlers(this);\r\n    }\r\n    parse(source) {\r\n        if (typeof source === 'string') {\r\n            return this._parse(source);\r\n        }\r\n        else {\r\n            console.error('Cannot read dxf source of type `' + typeof (source));\r\n            return null;\r\n        }\r\n    }\r\n    registerEntityHandler(handlerType) {\r\n        const instance = new handlerType();\r\n        this._entityHandlers[instance.ForEntityName] = instance;\r\n    }\r\n    parseSync(source) {\r\n        return this.parse(source);\r\n    }\r\n    parseStream(stream) {\r\n        let dxfString = \"\";\r\n        const self = this;\r\n        return new Promise((res, rej) => {\r\n            stream.on('data', (chunk) => {\r\n                dxfString += chunk;\r\n            });\r\n            stream.on('end', () => {\r\n                try {\r\n                    res(self._parse(dxfString));\r\n                }\r\n                catch (err) {\r\n                    rej(err);\r\n                }\r\n            });\r\n            stream.on('error', (err) => {\r\n                rej(err);\r\n            });\r\n        });\r\n    }\r\n    _parse(dxfString) {\r\n        const dxf = {};\r\n        let lastHandle = 0;\r\n        const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\r\n        const scanner = new DxfArrayScanner(dxfLinesArray);\r\n        if (!scanner.hasNext())\r\n            throw Error('Empty file');\r\n        const self = this;\r\n        let curr;\r\n        function parseAll() {\r\n            curr = scanner.next();\r\n            while (!scanner.isEOF()) {\r\n                if (curr.code === 0 && curr.value === 'SECTION') {\r\n                    curr = scanner.next();\r\n                    // Be sure we are reading a section code\r\n                    if (curr.code !== 2) {\r\n                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\r\n                        curr = scanner.next();\r\n                        continue;\r\n                    }\r\n                    if (curr.value === 'HEADER') {\r\n                        log.debug('> HEADER');\r\n                        dxf.header = parseHeader();\r\n                        log.debug('<');\r\n                    }\r\n                    else if (curr.value === 'BLOCKS') {\r\n                        log.debug('> BLOCKS');\r\n                        dxf.blocks = parseBlocks();\r\n                        log.debug('<');\r\n                    }\r\n                    else if (curr.value === 'ENTITIES') {\r\n                        log.debug('> ENTITIES');\r\n                        dxf.entities = parseEntities(false);\r\n                        log.debug('<');\r\n                    }\r\n                    else if (curr.value === 'TABLES') {\r\n                        log.debug('> TABLES');\r\n                        dxf.tables = parseTables();\r\n                        log.debug('<');\r\n                    }\r\n                    else if (curr.value === 'EOF') {\r\n                        log.debug('EOF');\r\n                    }\r\n                    else {\r\n                        log.warn('Skipping section \\'%s\\'', curr.value);\r\n                    }\r\n                }\r\n                else {\r\n                    curr = scanner.next();\r\n                }\r\n                // If is a new section\r\n            }\r\n        }\r\n        /**\r\n         *\r\n         * @return {object} header\r\n         */\r\n        function parseHeader() {\r\n            // interesting variables:\r\n            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\r\n            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\r\n            // Also see VPORT table entries\r\n            let currVarName = null;\r\n            let currVarValue = null;\r\n            const header = {};\r\n            // loop through header variables\r\n            curr = scanner.next();\r\n            while (true) {\r\n                if (groupIs(curr, 0, 'ENDSEC')) {\r\n                    if (currVarName)\r\n                        header[currVarName] = currVarValue;\r\n                    break;\r\n                }\r\n                else if (curr.code === 9) {\r\n                    if (currVarName)\r\n                        header[currVarName] = currVarValue;\r\n                    currVarName = curr.value;\r\n                    // Filter here for particular variables we are interested in\r\n                }\r\n                else {\r\n                    if (curr.code === 10) {\r\n                        currVarValue = { x: curr.value };\r\n                    }\r\n                    else if (curr.code === 20) {\r\n                        currVarValue.y = curr.value;\r\n                    }\r\n                    else if (curr.code === 30) {\r\n                        currVarValue.z = curr.value;\r\n                    }\r\n                    else {\r\n                        currVarValue = curr.value;\r\n                    }\r\n                }\r\n                curr = scanner.next();\r\n            }\r\n            // console.log(util.inspect(header, { colors: true, depth: null }));\r\n            curr = scanner.next(); // swallow up ENDSEC\r\n            return header;\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        function parseBlocks() {\r\n            const blocks = {};\r\n            curr = scanner.next();\r\n            while (curr.value !== 'EOF') {\r\n                if (groupIs(curr, 0, 'ENDSEC')) {\r\n                    break;\r\n                }\r\n                if (groupIs(curr, 0, 'BLOCK')) {\r\n                    log.debug('block {');\r\n                    const block = parseBlock();\r\n                    log.debug('}');\r\n                    ensureHandle(block);\r\n                    if (!block.name)\r\n                        log.error('block with handle \"' + block.handle + '\" is missing a name.');\r\n                    else\r\n                        blocks[block.name] = block;\r\n                }\r\n                else {\r\n                    logUnhandledGroup(curr);\r\n                    curr = scanner.next();\r\n                }\r\n            }\r\n            return blocks;\r\n        }\r\n        function parseBlock() {\r\n            const block = {};\r\n            curr = scanner.next();\r\n            while (curr.value !== 'EOF') {\r\n                switch (curr.code) {\r\n                    case 1:\r\n                        block.xrefPath = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 2:\r\n                        block.name = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 3:\r\n                        block.name2 = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 5:\r\n                        block.handle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 8:\r\n                        block.layer = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 10:\r\n                        block.position = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 67:\r\n                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 70:\r\n                        if (curr.value != 0) {\r\n                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\r\n                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\r\n                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\r\n                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\r\n                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\r\n                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\r\n                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\r\n                            block.type = curr.value;\r\n                        }\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 100:\r\n                        // ignore class markers\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 330:\r\n                        block.ownerHandle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 0:\r\n                        if (curr.value == 'ENDBLK')\r\n                            break;\r\n                        block.entities = parseEntities(true);\r\n                        break;\r\n                    default:\r\n                        logUnhandledGroup(curr);\r\n                        curr = scanner.next();\r\n                }\r\n                if (groupIs(curr, 0, 'ENDBLK')) {\r\n                    curr = scanner.next();\r\n                    break;\r\n                }\r\n            }\r\n            return block;\r\n        }\r\n        /**\r\n         * parseTables\r\n         * @return {Object} Object representing tables\r\n         */\r\n        function parseTables() {\r\n            const tables = {};\r\n            curr = scanner.next();\r\n            while (curr.value !== 'EOF') {\r\n                if (groupIs(curr, 0, 'ENDSEC'))\r\n                    break;\r\n                if (groupIs(curr, 0, 'TABLE')) {\r\n                    curr = scanner.next();\r\n                    const tableDefinition = tableDefinitions[curr.value];\r\n                    if (tableDefinition) {\r\n                        log.debug(curr.value + ' Table {');\r\n                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\r\n                        log.debug('}');\r\n                    }\r\n                    else {\r\n                        log.debug('Unhandled Table ' + curr.value);\r\n                    }\r\n                }\r\n                else {\r\n                    // else ignored\r\n                    curr = scanner.next();\r\n                }\r\n            }\r\n            curr = scanner.next();\r\n            return tables;\r\n        }\r\n        const END_OF_TABLE_VALUE = 'ENDTAB';\r\n        function parseTable(group) {\r\n            const tableDefinition = tableDefinitions[group.value];\r\n            const table = {};\r\n            let expectedCount = 0;\r\n            curr = scanner.next();\r\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\r\n                switch (curr.code) {\r\n                    case 5:\r\n                        table.handle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 330:\r\n                        table.ownerHandle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 100:\r\n                        if (curr.value === 'AcDbSymbolTable') {\r\n                            // ignore\r\n                            curr = scanner.next();\r\n                        }\r\n                        else {\r\n                            logUnhandledGroup(curr);\r\n                            curr = scanner.next();\r\n                        }\r\n                        break;\r\n                    case 70:\r\n                        expectedCount = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 0:\r\n                        if (curr.value === tableDefinition.dxfSymbolName) {\r\n                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\r\n                        }\r\n                        else {\r\n                            logUnhandledGroup(curr);\r\n                            curr = scanner.next();\r\n                        }\r\n                        break;\r\n                    default:\r\n                        logUnhandledGroup(curr);\r\n                        curr = scanner.next();\r\n                }\r\n            }\r\n            const tableRecords = table[tableDefinition.tableRecordsProperty];\r\n            if (tableRecords) {\r\n                let actualCount = (() => {\r\n                    if (tableRecords.constructor === Array) {\r\n                        return tableRecords.length;\r\n                    }\r\n                    else if (typeof (tableRecords) === 'object') {\r\n                        return Object.keys(tableRecords).length;\r\n                    }\r\n                    return undefined;\r\n                })();\r\n                if (expectedCount !== actualCount)\r\n                    log.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\r\n            }\r\n            curr = scanner.next();\r\n            return table;\r\n        }\r\n        function parseViewPortRecords() {\r\n            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\r\n            let viewPort = {};\r\n            log.debug('ViewPort {');\r\n            curr = scanner.next();\r\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\r\n                switch (curr.code) {\r\n                    case 2: // layer name\r\n                        viewPort.name = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 10:\r\n                        viewPort.lowerLeftCorner = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 11:\r\n                        viewPort.upperRightCorner = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 12:\r\n                        viewPort.center = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 13:\r\n                        viewPort.snapBasePoint = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 14:\r\n                        viewPort.snapSpacing = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 15:\r\n                        viewPort.gridSpacing = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 16:\r\n                        viewPort.viewDirectionFromTarget = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 17:\r\n                        viewPort.viewTarget = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 42:\r\n                        viewPort.lensLength = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 43:\r\n                        viewPort.frontClippingPlane = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 44:\r\n                        viewPort.backClippingPlane = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 45:\r\n                        viewPort.viewHeight = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 50:\r\n                        viewPort.snapRotationAngle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 51:\r\n                        viewPort.viewTwistAngle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 79:\r\n                        viewPort.orthographicType = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 110:\r\n                        viewPort.ucsOrigin = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 111:\r\n                        viewPort.ucsXAxis = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 112:\r\n                        viewPort.ucsYAxis = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 110:\r\n                        viewPort.ucsOrigin = parsePoint(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 281:\r\n                        viewPort.renderMode = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 281:\r\n                        // 0 is one distant light, 1 is two distant lights\r\n                        viewPort.defaultLightingType = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 292:\r\n                        viewPort.defaultLightingOn = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 330:\r\n                        viewPort.ownerHandle = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\r\n                    case 421:\r\n                    case 431:\r\n                        viewPort.ambientColor = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 0:\r\n                        // New ViewPort\r\n                        if (curr.value === 'VPORT') {\r\n                            log.debug('}');\r\n                            viewPorts.push(viewPort);\r\n                            log.debug('ViewPort {');\r\n                            viewPort = {};\r\n                            curr = scanner.next();\r\n                        }\r\n                        break;\r\n                    default:\r\n                        logUnhandledGroup(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                }\r\n            }\r\n            // Note: do not call scanner.next() here,\r\n            //  parseTable() needs the current group\r\n            log.debug('}');\r\n            viewPorts.push(viewPort);\r\n            return viewPorts;\r\n        }\r\n        function parseLineTypes() {\r\n            const ltypes = {};\r\n            let ltype = {};\r\n            let length = 0;\r\n            let ltypeName;\r\n            log.debug('LType {');\r\n            curr = scanner.next();\r\n            while (!groupIs(curr, 0, 'ENDTAB')) {\r\n                switch (curr.code) {\r\n                    case 2:\r\n                        ltype.name = curr.value;\r\n                        ltypeName = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 3:\r\n                        ltype.description = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 73: // Number of elements for this line type (dots, dashes, spaces);\r\n                        length = curr.value;\r\n                        if (length > 0)\r\n                            ltype.pattern = [];\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 40: // total pattern length\r\n                        ltype.patternLength = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 49:\r\n                        ltype.pattern.push(curr.value);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 0:\r\n                        log.debug('}');\r\n                        if (length > 0 && length !== ltype.pattern.length)\r\n                            log.warn('lengths do not match on LTYPE pattern');\r\n                        ltypes[ltypeName] = ltype;\r\n                        ltype = {};\r\n                        log.debug('LType {');\r\n                        curr = scanner.next();\r\n                        break;\r\n                    default:\r\n                        curr = scanner.next();\r\n                }\r\n            }\r\n            log.debug('}');\r\n            ltypes[ltypeName] = ltype;\r\n            return ltypes;\r\n        }\r\n        function parseLayers() {\r\n            const layers = {};\r\n            let layer = {};\r\n            let layerName;\r\n            log.debug('Layer {');\r\n            curr = scanner.next();\r\n            while (!groupIs(curr, 0, 'ENDTAB')) {\r\n                switch (curr.code) {\r\n                    case 2: // layer name\r\n                        layer.name = curr.value;\r\n                        layerName = curr.value;\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 62: // color, visibility\r\n                        layer.visible = curr.value >= 0;\r\n                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\r\n                        layer.colorIndex = Math.abs(curr.value);\r\n                        layer.color = getAcadColor(layer.colorIndex);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 70: // frozen layer\r\n                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\r\n                        curr = scanner.next();\r\n                        break;\r\n                    case 0:\r\n                        // New Layer\r\n                        if (curr.value === 'LAYER') {\r\n                            log.debug('}');\r\n                            layers[layerName] = layer;\r\n                            log.debug('Layer {');\r\n                            layer = {};\r\n                            layerName = undefined;\r\n                            curr = scanner.next();\r\n                        }\r\n                        break;\r\n                    default:\r\n                        logUnhandledGroup(curr);\r\n                        curr = scanner.next();\r\n                        break;\r\n                }\r\n            }\r\n            // Note: do not call scanner.next() here,\r\n            //  parseLayerTable() needs the current group\r\n            log.debug('}');\r\n            layers[layerName] = layer;\r\n            return layers;\r\n        }\r\n        const tableDefinitions = {\r\n            VPORT: {\r\n                tableRecordsProperty: 'viewPorts',\r\n                tableName: 'viewPort',\r\n                dxfSymbolName: 'VPORT',\r\n                parseTableRecords: parseViewPortRecords\r\n            },\r\n            LTYPE: {\r\n                tableRecordsProperty: 'lineTypes',\r\n                tableName: 'lineType',\r\n                dxfSymbolName: 'LTYPE',\r\n                parseTableRecords: parseLineTypes\r\n            },\r\n            LAYER: {\r\n                tableRecordsProperty: 'layers',\r\n                tableName: 'layer',\r\n                dxfSymbolName: 'LAYER',\r\n                parseTableRecords: parseLayers\r\n            }\r\n        };\r\n        /**\r\n         * Is called after the parser first reads the 0:ENTITIES group. The scanner\r\n         * should be on the start of the first entity already.\r\n         * @return {Array} the resulting entities\r\n         */\r\n        function parseEntities(forBlock) {\r\n            const entities = [];\r\n            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\r\n            if (!forBlock) {\r\n                curr = scanner.next();\r\n            }\r\n            while (true) {\r\n                if (curr.code === 0) {\r\n                    if (curr.value === endingOnValue) {\r\n                        break;\r\n                    }\r\n                    const handler = self._entityHandlers[curr.value];\r\n                    if (handler != null) {\r\n                        log.debug(curr.value + ' {');\r\n                        const entity = handler.parseEntity(scanner, curr);\r\n                        curr = scanner.lastReadGroup;\r\n                        log.debug('}');\r\n                        ensureHandle(entity);\r\n                        entities.push(entity);\r\n                    }\r\n                    else {\r\n                        log.warn('Unhandled entity ' + curr.value);\r\n                        curr = scanner.next();\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    // ignored lines from unsupported entity\r\n                    curr = scanner.next();\r\n                }\r\n            }\r\n            if (endingOnValue == 'ENDSEC')\r\n                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\r\n            return entities;\r\n        }\r\n        /**\r\n         * Parses a 2D or 3D point, returning it as an object with x, y, and\r\n         * (sometimes) z property if it is 3D. It is assumed the current group\r\n         * is x of the point being read in, and scanner.next() will return the\r\n         * y. The parser will determine if there is a z point automatically.\r\n         * @return {Object} The 2D or 3D point as an object with x, y[, z]\r\n         */\r\n        function parsePoint(curr) {\r\n            const point = {};\r\n            let code = curr.code;\r\n            point.x = curr.value;\r\n            code += 10;\r\n            curr = scanner.next();\r\n            if (curr.code != code)\r\n                throw new Error('Expected code for point value to be ' + code +\r\n                    ' but got ' + curr.code + '.');\r\n            point.y = curr.value;\r\n            code += 10;\r\n            curr = scanner.next();\r\n            if (curr.code != code) {\r\n                scanner.rewind();\r\n                return point;\r\n            }\r\n            point.z = curr.value;\r\n            return point;\r\n        }\r\n        function ensureHandle(entity) {\r\n            if (!entity)\r\n                throw new TypeError('entity cannot be undefined or null');\r\n            if (!entity.handle)\r\n                entity.handle = lastHandle++;\r\n        }\r\n        parseAll();\r\n        return dxf;\r\n    }\r\n}\r\nfunction groupIs(group, code, value) {\r\n    return group.code === code && group.value === value;\r\n}\r\nfunction logUnhandledGroup(curr) {\r\n    log.debug('unhandled group ' + debugCode(curr));\r\n}\r\nfunction debugCode(curr) {\r\n    return curr.code + ':' + curr.value;\r\n}\r\n/**\r\n * Returns the truecolor value of the given AutoCad color index value\r\n * @return {Number} truecolor value as a number\r\n */\r\nfunction getAcadColor(index) {\r\n    return AUTO_CAD_COLOR_INDEX[index];\r\n}\r\n// const BLOCK_ANONYMOUS_FLAG = 1;\r\n// const BLOCK_NON_CONSTANT_FLAG = 2;\r\n// const BLOCK_XREF_FLAG = 4;\r\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\r\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\r\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\r\n// const BLOCK_REFERENCED_XREF = 64;\r\n/* Notes */\r\n// Code 6 of an entity indicates inheritance of properties (eg. color).\r\n//   BYBLOCK means inherits from block\r\n//   BYLAYER (default) mean inherits from layer\r\n", "import DxfParser from './DxfParser';\r\nexport { default as DxfParser } from './DxfParser';\r\nexport default DxfParser;\r\n"],
  "mappings": "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A;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;;;AClQO,SAAS,aAAa,OAAO;AAChC,SAAO,0BAAqB,KAAK;AACrC;AAMO,SAAS,WAAW,SAAS;AAChC,QAAM,QAAQ,CAAC;AAEf,UAAQ,OAAO;AACf,MAAI,OAAO,QAAQ,KAAK;AACxB,MAAI,OAAO,KAAK;AAChB,QAAM,IAAI,KAAK;AACf,UAAQ;AACR,SAAO,QAAQ,KAAK;AACpB,MAAI,KAAK,QAAQ;AACb,UAAM,IAAI,MAAM,yCAAyC,OACrD,cAAc,KAAK,OAAO,GAAG;AACrC,QAAM,IAAI,KAAK;AACf,UAAQ;AACR,SAAO,QAAQ,KAAK;AACpB,MAAI,KAAK,QAAQ,MAAM;AAEnB,YAAQ,OAAO;AACf,WAAO;AAAA,EACX;AACA,QAAM,IAAI,KAAK;AACf,SAAO;AACX;AAOO,SAAS,4BAA4B,QAAQ,MAAM,SAAS;AAC/D,UAAQ,KAAK,MAAM;AAAA,IACf,KAAK;AACD,aAAO,OAAO,KAAK;AACnB;AAAA,IACJ,KAAK;AACD,aAAO,SAAS,KAAK;AACrB;AAAA,IACJ,KAAK;AACD,aAAO,WAAW,KAAK;AACvB;AAAA,IACJ,KAAK;AACD,aAAO,QAAQ,KAAK;AACpB;AAAA,IACJ,KAAK;AACD,aAAO,gBAAgB,KAAK;AAC5B;AAAA,IACJ,KAAK;AACD,aAAO,UAAU,KAAK,UAAU;AAChC;AAAA,IACJ,KAAK;AACD,aAAO,aAAa,KAAK;AACzB,aAAO,QAAQ,aAAa,KAAK,IAAI,KAAK,KAAK,CAAC;AAChD;AAAA,IACJ,KAAK;AACD,aAAO,eAAe,KAAK,UAAU;AACrC;AAAA,IACJ,KAAK;AAED;AAAA,IACJ,KAAK;AAED,aAAO,KAAK,QAAQ,GAAG;AACnB,eAAO,QAAQ,KAAK;AAAA,MACxB;AACA,cAAQ,OAAO;AACf;AAAA,IACJ,KAAK;AACD,aAAO,cAAc,KAAK;AAC1B;AAAA,IACJ,KAAK;AACD,aAAO,uBAAuB,KAAK;AACnC;AAAA,IACJ,KAAK;AAKD,aAAO,aAAa,KAAK;AACzB;AAAA,IACJ,KAAK;AACD,aAAO,QAAQ,KAAK;AACpB;AAAA,IACJ,KAAK;AACD,aAAO,eAAe,OAAO,gBAAgB,CAAC;AAC9C,aAAO,aAAa,gBAAgB,OAAO,aAAa,iBAAiB,CAAC;AAC1E,aAAO,aAAa,cAAc,KAAK,KAAK,KAAK;AACjD;AAAA,IACJ,KAAK;AACD,aAAO,eAAe,OAAO,gBAAgB,CAAC;AAC9C,aAAO,aAAa,kBAAkB,KAAK;AAC3C;AAAA,IACJ;AACI,aAAO;AAAA,EACf;AACA,SAAO;AACX;;;AC3GA,IAAqB,aAArB,MAAgC;AAAA,EAC5B,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,OAAO,UAAU,CAAC,EAAE;AAChD,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,SAAU,KAAK,QAAQ,OAAO;AACrC,iBAAO,gCAAiC,KAAK,QAAQ,SAAS;AAC9D;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,oBAAoB,SAAS,IAAI;AACnD,iBAAO,QAAQ;AACf;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,oBAAoB,SAAS,MAAM;AACxC,MAAI,WAAW,CAAC;AAChB,MAAI,kBAAkB;AACtB,MAAI,mBAAmB;AACvB,MAAI,oBAAoB;AACxB,WAAS,IAAI,GAAG,KAAK,mBAAmB,KAAK;AACzC,QAAI,SAAS,CAAC;AACd,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS,KAAK;AACnB;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,cAAI,iBAAiB;AACjB,+BAAmB;AACnB;AAAA,UACJ;AACA,iBAAO,IAAI,KAAK;AAChB,4BAAkB;AAClB;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ;AAGI,iBAAO;AAAA,MACf;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AAEA,aAAS,KAAK,MAAM;AACpB,sBAAkB;AAClB,uBAAmB;AAAA,EACvB;AACA,UAAQ,OAAO;AACf,SAAO;AACX;;;AC5EA,IAAqB,MAArB,MAAyB;AAAA,EACrB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,SAAiB,WAAW,OAAO;AAC1C;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK,KAAK,MAAM,KAAK;AACzC;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK,KAAK,MAAM,KAAK;AACvC,iBAAO,cAAc,OAAO,WAAW,OAAO;AAC9C;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACzCA,IAAqB,SAArB,MAA4B;AAAA,EACxB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,QAAI,SAAS;AAAA,MACT,MAAM,KAAK;AAAA,MACX,OAAO;AAAA,MACP,WAAW;AAAA,IACf;AACA,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS,GAAG;AACjB;AAAA,MACJ;AACA,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,OAAO,KAAK;AACnB;AAAA,QACJ,KAAK;AACD,iBAAO,MAAM,KAAK;AAClB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAqB,WAAW,OAAO;AAC9C;AAAA,QACJ,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK;AACzB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,eAAe,KAAK;AAC3B;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,CAAC,EAAE,KAAK,QAAQ;AACnC,iBAAO,WAAW,CAAC,EAAE,KAAK,QAAQ;AAClC,iBAAO,uBAAuB,CAAC,EAAE,KAAK,QAAQ;AAC9C,iBAAO,SAAS,CAAC,EAAE,KAAK,QAAQ;AAChC;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,CAAC,EAAE,KAAK,QAAQ;AACnC,iBAAO,WAAW,CAAC,EAAE,KAAK,QAAQ;AAClC;AAAA,QACJ,KAAK;AAED,iBAAO,0BAA0B,KAAK;AACtC;AAAA,QACJ,KAAK;AACD,iBAAO,cAAc,KAAK;AAC1B;AAAA,QACJ,KAAK;AAED,iBAAO,wBAAwB,KAAK;AACpC;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACzFA,IAAqB,SAArB,MAA4B;AAAA,EACxB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,SAAiB,WAAW,OAAO;AAC1C;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK,KAAK,MAAM,KAAK;AACzC;AAAA,QACJ,KAAK;AACD,gBAAM,WAAW,KAAK,KAAK,MAAM,KAAK;AACtC,cAAI,WAAW,OAAO;AAClB,mBAAO,cAAc,WAAW,IAAI,KAAK,KAAK,OAAO;AAAA;AAErD,mBAAO,cAAc,WAAW,OAAO;AAC3C,iBAAO,WAAW;AAClB;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACpCA,IAAqB,YAArB,MAA+B;AAAA,EAC3B,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,cAAsB,WAAW,OAAO;AAC/C;AAAA,QACJ,KAAK;AACD,iBAAO,eAAuB,WAAW,OAAO;AAChD;AAAA,QACJ,KAAK;AACD,iBAAO,iBAAyB,WAAW,OAAO;AAClD;AAAA,QACJ,KAAK;AACD,iBAAO,wBAAgC,WAAW,OAAO;AACzD;AAAA,QACJ,KAAK;AACD,iBAAO,wBAAgC,WAAW,OAAO;AACzD;AAAA,QACJ,KAAK;AACD,iBAAO,wBAAgC,WAAW,OAAO;AACzD;AAAA,QACJ,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,gBAAgB,KAAK;AAC5B;AAAA,QACJ,KAAK;AACD,iBAAO,kBAAkB,KAAK;AAC9B;AAAA,QACJ,KAAK;AACD,iBAAO,oBAAoB,KAAK;AAChC;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,KAAK;AACnB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC1DA,IAAqB,UAArB,MAA6B;AAAA,EACzB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,SAAiB,WAAW,OAAO;AAC1C;AAAA,QACJ,KAAK;AACD,iBAAO,oBAA4B,WAAW,OAAO;AACrD;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK;AACzB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,KAAK;AACnB;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACrCA,IAAqB,SAArB,MAA4B;AAAA,EACxB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,OAAO,KAAK;AACnB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,cAAc,KAAK;AAC1B;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,gBAAgB,KAAK;AAC5B;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK;AACzB;AAAA,QACJ,KAAK;AACD,iBAAO,qBAA6B,WAAW,OAAO;AACtD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACpDA,IAAqB,OAArB,MAA0B;AAAA,EACtB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,OAAO,UAAU,CAAC,EAAE;AAChD,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,SAAS,QAAgB,WAAW,OAAO,CAAC;AACnD;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAa,WAAW,OAAO,CAAC;AAChD;AAAA,QACJ,KAAK;AACD,iBAAO,qBAA6B,WAAW,OAAO;AACtD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC9BA,IAAqB,aAArB,MAAgC;AAAA,EAC5B,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,OAAO,UAAU,CAAC,EAAE;AAChD,QAAI,mBAAmB;AACvB,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAU,KAAK,QAAQ,OAAO;AACrC,iBAAO,gCAAiC,KAAK,QAAQ,SAAS;AAC9D;AAAA,QACJ,KAAK;AACD,6BAAmB,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,wBAAwB,kBAAkB,OAAO;AACnE;AAAA,QACJ,KAAK;AACD,cAAI,KAAK,UAAU;AACf,mBAAO,QAAQ,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,wBAAwB,GAAG,SAAS;AACzC,MAAI,CAAC,KAAK,KAAK;AACX,UAAM,MAAM,oCAAoC;AACpD,QAAM,WAAW,CAAC;AAClB,MAAI,kBAAkB;AACtB,MAAI,mBAAmB;AACvB,MAAI,OAAO,QAAQ;AACnB,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAM,SAAS,CAAC;AAChB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS,KAAK;AACnB;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,cAAI,iBAAiB;AACjB,+BAAmB;AACnB;AAAA,UACJ;AACA,iBAAO,IAAI,KAAK;AAChB,4BAAkB;AAClB;AAAA,QACJ,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK;AACzB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,cAAI,KAAK,SAAS;AACd,mBAAO,QAAQ,KAAK;AACxB;AAAA,QACJ;AAEI,kBAAQ,OAAO;AACf,cAAI,iBAAiB;AACjB,qBAAS,KAAK,MAAM;AAAA,UACxB;AACA,kBAAQ,OAAO;AACf,iBAAO;AAAA,MACf;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AAEA,aAAS,KAAK,MAAM;AACpB,sBAAkB;AAClB,uBAAmB;AAAA,EACvB;AACA,UAAQ,OAAO;AACf,SAAO;AACX;;;ACzGA,IAAqB,QAArB,MAA2B;AAAA,EACvB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,OAAO,OAAO,QAAQ,KAAK,QAAQ,OAAO,OAAO,KAAK;AAC7D;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,OAAO,QAAQ,KAAK,QAAQ,OAAO,OAAO,KAAK;AAC7D;AAAA,QACJ,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,kBAA0B,WAAW,OAAO;AACnD;AAAA,QACJ,KAAK;AAED,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,kBAAkB,KAAK;AAC9B;AAAA,QACJ,KAAK;AACD,iBAAO,mBAAmB,KAAK;AAC/B;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC/CA,IAAqB,QAArB,MAA2B;AAAA,EACvB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,OAAO,KAAK;AAClB,UAAM,SAAS,EAAE,KAAK;AACtB,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,qBAA6B,WAAW,OAAO;AACtD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC/BA,IAAqB,SAArB,MAA4B;AAAA,EACxB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,QAAI,SAAS,EAAE,MAAM,KAAK,MAAM;AAChC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AACD,iBAAO,IAAI,KAAK;AAChB;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,cAAI,KAAK,SAAS;AACd,mBAAO,QAAQ,KAAK;AACxB;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK,QAAQ,OAAO;AACjD,iBAAO,mBAAmB,KAAK,QAAQ,OAAO;AAC9C,iBAAO,gBAAgB,KAAK,QAAQ,OAAO;AAC3C,iBAAO,sBAAsB,KAAK,QAAQ,QAAQ;AAClD,iBAAO,wBAAwB,KAAK,QAAQ,QAAQ;AACpD,iBAAO,sBAAsB,KAAK,QAAQ,QAAQ;AAClD,iBAAO,sBAAsB,KAAK,QAAQ,SAAS;AACnD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ,KAAK;AACD,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC1DA,IAAqB,WAArB,MAA8B;AAAA,EAC1B,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,QAAI,SAAS,EAAE,MAAM,KAAK,OAAO,UAAU,CAAC,EAAE;AAC9C,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAO,YAAY,KAAK;AACxB;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK,QAAQ,OAAO;AACpC,iBAAO,4BAA4B,KAAK,QAAQ,OAAO;AACvD,iBAAO,6BAA6B,KAAK,QAAQ,OAAO;AACxD,iBAAO,gBAAgB,KAAK,QAAQ,OAAO;AAC3C,iBAAO,mBAAmB,KAAK,QAAQ,QAAQ;AAC/C,iBAAO,yBAAyB,KAAK,QAAQ,QAAQ;AACrD,iBAAO,kBAAkB,KAAK,QAAQ,QAAQ;AAC9C,iBAAO,gCAAgC,KAAK,QAAQ,SAAS;AAC7D;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAO,qBAA6B,WAAW,OAAO;AACtD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO,WAAW,sBAAsB,SAAS,IAAI;AACrD,WAAO;AAAA,EACX;AACJ;AACA,SAAS,sBAAsB,SAAS,MAAM;AAC1C,QAAM,eAAe,IAAI,OAAa;AACtC,QAAM,WAAW,CAAC;AAClB,SAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,QAAI,KAAK,SAAS,GAAG;AACjB,UAAI,KAAK,UAAU,UAAU;AACzB,iBAAS,KAAK,aAAa,YAAY,SAAS,IAAI,CAAC;AACrD,eAAO,QAAQ;AAAA,MACnB,WACS,KAAK,UAAU,UAAU;AAC9B,oBAAY,SAAS,IAAI;AACzB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,YAAY,SAAS,MAAM;AAChC,QAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,SAAO,QAAQ,KAAK;AACpB,SAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,QAAI,KAAK,QAAQ;AACb;AACJ,IAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD,WAAO,QAAQ,KAAK;AAAA,EACxB;AACA,SAAO;AACX;;;ACrFA,IAAqB,QAArB,MAA2B;AAAA,EACvB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,OAAO,QAAQ,CAAC,EAAE;AAC9C,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,OAAO,CAAC,IAAY,WAAW,OAAO;AAC7C;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,CAAC,IAAY,WAAW,OAAO;AAC7C;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,CAAC,IAAY,WAAW,OAAO;AAC7C;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,CAAC,IAAY,WAAW,OAAO;AAC7C;AAAA,QACJ,KAAK;AACD,iBAAO,qBAA6B,WAAW,OAAO;AACtD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AClCA,IAAqB,SAArB,MAA4B;AAAA,EACxB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,cAAI,CAAC,OAAO;AACR,mBAAO,gBAAgB,CAAC;AAC5B,iBAAO,cAAc,KAAa,WAAW,OAAO,CAAC;AACrD;AAAA,QACJ,KAAK;AACD,cAAI,CAAC,OAAO;AACR,mBAAO,YAAY,CAAC;AACxB,iBAAO,UAAU,KAAa,WAAW,OAAO,CAAC;AACjD;AAAA,QACJ,KAAK;AACD,iBAAO,eAAuB,WAAW,OAAO;AAChD;AAAA,QACJ,KAAK;AACD,iBAAO,aAAqB,WAAW,OAAO;AAC9C;AAAA,QACJ,KAAK;AACD,cAAI,CAAC,OAAO;AACR,mBAAO,aAAa,CAAC;AACzB,iBAAO,WAAW,KAAK,KAAK,KAAK;AACjC;AAAA,QACJ,KAAK;AACD,eAAK,KAAK,QAAQ,MAAM;AACpB,mBAAO,SAAS;AACpB,eAAK,KAAK,QAAQ,MAAM;AACpB,mBAAO,WAAW;AACtB,eAAK,KAAK,QAAQ,MAAM;AACpB,mBAAO,WAAW;AACtB,eAAK,KAAK,QAAQ,MAAM;AACpB,mBAAO,SAAS;AACpB,eAAK,KAAK,QAAQ,OAAO,GAAG;AACxB,mBAAO,SAAS;AAChB,mBAAO,SAAS;AAAA,UACpB;AACA;AAAA,QACJ,KAAK;AACD,iBAAO,sBAAsB,KAAK;AAClC;AAAA,QACJ,KAAK;AACD,iBAAO,gBAAgB,KAAK;AAC5B;AAAA,QACJ,KAAK;AACD,iBAAO,wBAAwB,KAAK;AACpC;AAAA,QACJ,KAAK;AACD,iBAAO,oBAAoB,KAAK;AAChC;AAAA,QACJ,KAAK;AACD,iBAAO,eAAuB,WAAW,OAAO;AAChD;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;ACrEA,IAAqB,OAArB,MAA0B;AAAA,EACtB,cAAc;AACV,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,YAAY,SAAS,MAAM;AACvB,UAAM,SAAS,EAAE,MAAM,KAAK,MAAM;AAClC,WAAO,QAAQ,KAAK;AACpB,WAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,UAAI,KAAK,SAAS;AACd;AACJ,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,iBAAO,aAAqB,WAAW,OAAO;AAC9C;AAAA,QACJ,KAAK;AACD,iBAAO,WAAmB,WAAW,OAAO;AAC5C;AAAA,QACJ,KAAK;AACD,iBAAO,aAAa,KAAK;AACzB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,WAAW,KAAK;AACvB;AAAA,QACJ,KAAK;AACD,iBAAO,OAAO,KAAK;AACnB;AAAA,QAEJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ,KAAK;AACD,iBAAO,SAAS,KAAK;AACrB;AAAA,QACJ;AACI,UAAQ,4BAA4B,QAAQ,MAAM,OAAO;AACzD;AAAA,MACR;AACA,aAAO,QAAQ,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACJ;;;AC3BA,sBAAgB;AAKhB,gBAAAA,QAAI,SAAS,OAAO;AACpB,SAAS,8BAA8B,WAAW;AAE9C,YAAU,sBAAsB,UAAI;AACpC,YAAU,sBAAsB,GAAG;AACnC,YAAU,sBAAsB,MAAM;AACtC,YAAU,sBAAsB,MAAM;AACtC,YAAU,sBAAsB,SAAS;AACzC,YAAU,sBAAsB,OAAO;AACvC,YAAU,sBAAsB,MAAM;AACtC,YAAU,sBAAsB,IAAI;AACpC,YAAU,sBAAsB,UAAU;AAC1C,YAAU,sBAAsB,KAAK;AACrC,YAAU,sBAAsB,KAAK;AACrC,YAAU,sBAAsB,QAAQ;AACxC,YAAU,sBAAsB,KAAK;AACrC,YAAU,sBAAsB,MAAM;AACtC,YAAU,sBAAsB,IAAI;AAExC;AACA,IAAqB,YAArB,MAA+B;AAAA,EAC3B,cAAc;AACV,SAAK,kBAAkB,CAAC;AACxB,kCAA8B,IAAI;AAAA,EACtC;AAAA,EACA,MAAM,QAAQ;AACV,QAAI,OAAO,WAAW,UAAU;AAC5B,aAAO,KAAK,OAAO,MAAM;AAAA,IAC7B,OACK;AACD,cAAQ,MAAM,qCAAqC,OAAQ,MAAO;AAClE,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,sBAAsB,aAAa;AAC/B,UAAM,WAAW,IAAI,YAAY;AACjC,SAAK,gBAAgB,SAAS,aAAa,IAAI;AAAA,EACnD;AAAA,EACA,UAAU,QAAQ;AACd,WAAO,KAAK,MAAM,MAAM;AAAA,EAC5B;AAAA,EACA,YAAY,QAAQ;AAChB,QAAI,YAAY;AAChB,UAAM,OAAO;AACb,WAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC7B,aAAO,GAAG,QAAQ,CAAC,UAAU;AACzB,qBAAa;AAAA,MACjB,CAAC;AACD,aAAO,GAAG,OAAO,MAAM;AACnB,YAAI;AACA,cAAI,KAAK,OAAO,SAAS,CAAC;AAAA,QAC9B,SACO,KAAK;AACR,cAAI,GAAG;AAAA,QACX;AAAA,MACJ,CAAC;AACD,aAAO,GAAG,SAAS,CAAC,QAAQ;AACxB,YAAI,GAAG;AAAA,MACX,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AAAA,EACA,OAAO,WAAW;AACd,UAAM,MAAM,CAAC;AACb,QAAI,aAAa;AACjB,UAAM,gBAAgB,UAAU,MAAM,aAAa;AACnD,UAAM,UAAU,IAAI,gBAAgB,aAAa;AACjD,QAAI,CAAC,QAAQ,QAAQ;AACjB,YAAM,MAAM,YAAY;AAC5B,UAAM,OAAO;AACb,QAAI;AACJ,aAAS,WAAW;AAChB,aAAO,QAAQ,KAAK;AACpB,aAAO,CAAC,QAAQ,MAAM,GAAG;AACrB,YAAI,KAAK,SAAS,KAAK,KAAK,UAAU,WAAW;AAC7C,iBAAO,QAAQ,KAAK;AAEpB,cAAI,KAAK,SAAS,GAAG;AACjB,oBAAQ,MAAM,sCAAsC,UAAU,IAAI,CAAC;AACnE,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ;AACA,cAAI,KAAK,UAAU,UAAU;AACzB,4BAAAA,QAAI,MAAM,UAAU;AACpB,gBAAI,SAAS,YAAY;AACzB,4BAAAA,QAAI,MAAM,GAAG;AAAA,UACjB,WACS,KAAK,UAAU,UAAU;AAC9B,4BAAAA,QAAI,MAAM,UAAU;AACpB,gBAAI,SAAS,YAAY;AACzB,4BAAAA,QAAI,MAAM,GAAG;AAAA,UACjB,WACS,KAAK,UAAU,YAAY;AAChC,4BAAAA,QAAI,MAAM,YAAY;AACtB,gBAAI,WAAW,cAAc,KAAK;AAClC,4BAAAA,QAAI,MAAM,GAAG;AAAA,UACjB,WACS,KAAK,UAAU,UAAU;AAC9B,4BAAAA,QAAI,MAAM,UAAU;AACpB,gBAAI,SAAS,YAAY;AACzB,4BAAAA,QAAI,MAAM,GAAG;AAAA,UACjB,WACS,KAAK,UAAU,OAAO;AAC3B,4BAAAA,QAAI,MAAM,KAAK;AAAA,UACnB,OACK;AACD,4BAAAA,QAAI,KAAK,yBAA2B,KAAK,KAAK;AAAA,UAClD;AAAA,QACJ,OACK;AACD,iBAAO,QAAQ,KAAK;AAAA,QACxB;AAAA,MAEJ;AAAA,IACJ;AAKA,aAAS,cAAc;AAKnB,UAAI,cAAc;AAClB,UAAI,eAAe;AACnB,YAAM,SAAS,CAAC;AAEhB,aAAO,QAAQ,KAAK;AACpB,aAAO,MAAM;AACT,YAAI,QAAQ,MAAM,GAAG,QAAQ,GAAG;AAC5B,cAAI;AACA,mBAAO,WAAW,IAAI;AAC1B;AAAA,QACJ,WACS,KAAK,SAAS,GAAG;AACtB,cAAI;AACA,mBAAO,WAAW,IAAI;AAC1B,wBAAc,KAAK;AAAA,QAEvB,OACK;AACD,cAAI,KAAK,SAAS,IAAI;AAClB,2BAAe,EAAE,GAAG,KAAK,MAAM;AAAA,UACnC,WACS,KAAK,SAAS,IAAI;AACvB,yBAAa,IAAI,KAAK;AAAA,UAC1B,WACS,KAAK,SAAS,IAAI;AACvB,yBAAa,IAAI,KAAK;AAAA,UAC1B,OACK;AACD,2BAAe,KAAK;AAAA,UACxB;AAAA,QACJ;AACA,eAAO,QAAQ,KAAK;AAAA,MACxB;AAEA,aAAO,QAAQ,KAAK;AACpB,aAAO;AAAA,IACX;AAIA,aAAS,cAAc;AACnB,YAAM,SAAS,CAAC;AAChB,aAAO,QAAQ,KAAK;AACpB,aAAO,KAAK,UAAU,OAAO;AACzB,YAAI,QAAQ,MAAM,GAAG,QAAQ,GAAG;AAC5B;AAAA,QACJ;AACA,YAAI,QAAQ,MAAM,GAAG,OAAO,GAAG;AAC3B,0BAAAA,QAAI,MAAM,SAAS;AACnB,gBAAM,QAAQ,WAAW;AACzB,0BAAAA,QAAI,MAAM,GAAG;AACb,uBAAa,KAAK;AAClB,cAAI,CAAC,MAAM;AACP,4BAAAA,QAAI,MAAM,wBAAwB,MAAM,SAAS,sBAAsB;AAAA;AAEvE,mBAAO,MAAM,IAAI,IAAI;AAAA,QAC7B,OACK;AACD,4BAAkB,IAAI;AACtB,iBAAO,QAAQ,KAAK;AAAA,QACxB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,aAAS,aAAa;AAClB,YAAM,QAAQ,CAAC;AACf,aAAO,QAAQ,KAAK;AACpB,aAAO,KAAK,UAAU,OAAO;AACzB,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,kBAAM,WAAW,KAAK;AACtB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,OAAO,KAAK;AAClB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,QAAQ,KAAK;AACnB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,SAAS,KAAK;AACpB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,QAAQ,KAAK;AACnB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,WAAWC,YAAW,IAAI;AAChC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,aAAc,KAAK,SAAS,KAAK,SAAS,IAAK,OAAO;AAC5D,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK,SAAS,GAAG;AAQjB,oBAAM,OAAO,KAAK;AAAA,YACtB;AACA,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AAED,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,cAAc,KAAK;AACzB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK,SAAS;AACd;AACJ,kBAAM,WAAW,cAAc,IAAI;AACnC;AAAA,UACJ;AACI,8BAAkB,IAAI;AACtB,mBAAO,QAAQ,KAAK;AAAA,QAC5B;AACA,YAAI,QAAQ,MAAM,GAAG,QAAQ,GAAG;AAC5B,iBAAO,QAAQ,KAAK;AACpB;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAKA,aAAS,cAAc;AACnB,YAAM,SAAS,CAAC;AAChB,aAAO,QAAQ,KAAK;AACpB,aAAO,KAAK,UAAU,OAAO;AACzB,YAAI,QAAQ,MAAM,GAAG,QAAQ;AACzB;AACJ,YAAI,QAAQ,MAAM,GAAG,OAAO,GAAG;AAC3B,iBAAO,QAAQ,KAAK;AACpB,gBAAM,kBAAkB,iBAAiB,KAAK,KAAK;AACnD,cAAI,iBAAiB;AACjB,4BAAAD,QAAI,MAAM,KAAK,QAAQ,UAAU;AACjC,mBAAO,iBAAiB,KAAK,KAAK,EAAE,SAAS,IAAI,WAAW,IAAI;AAChE,4BAAAA,QAAI,MAAM,GAAG;AAAA,UACjB,OACK;AACD,4BAAAA,QAAI,MAAM,qBAAqB,KAAK,KAAK;AAAA,UAC7C;AAAA,QACJ,OACK;AAED,iBAAO,QAAQ,KAAK;AAAA,QACxB;AAAA,MACJ;AACA,aAAO,QAAQ,KAAK;AACpB,aAAO;AAAA,IACX;AACA,UAAM,qBAAqB;AAC3B,aAAS,WAAW,OAAO;AACvB,YAAM,kBAAkB,iBAAiB,MAAM,KAAK;AACpD,YAAM,QAAQ,CAAC;AACf,UAAI,gBAAgB;AACpB,aAAO,QAAQ,KAAK;AACpB,aAAO,CAAC,QAAQ,MAAM,GAAG,kBAAkB,GAAG;AAC1C,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,kBAAM,SAAS,KAAK;AACpB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,cAAc,KAAK;AACzB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK,UAAU,mBAAmB;AAElC,qBAAO,QAAQ,KAAK;AAAA,YACxB,OACK;AACD,gCAAkB,IAAI;AACtB,qBAAO,QAAQ,KAAK;AAAA,YACxB;AACA;AAAA,UACJ,KAAK;AACD,4BAAgB,KAAK;AACrB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK,UAAU,gBAAgB,eAAe;AAC9C,oBAAM,gBAAgB,oBAAoB,IAAI,gBAAgB,kBAAkB;AAAA,YACpF,OACK;AACD,gCAAkB,IAAI;AACtB,qBAAO,QAAQ,KAAK;AAAA,YACxB;AACA;AAAA,UACJ;AACI,8BAAkB,IAAI;AACtB,mBAAO,QAAQ,KAAK;AAAA,QAC5B;AAAA,MACJ;AACA,YAAM,eAAe,MAAM,gBAAgB,oBAAoB;AAC/D,UAAI,cAAc;AACd,YAAI,eAAe,MAAM;AACrB,cAAI,aAAa,gBAAgB,OAAO;AACpC,mBAAO,aAAa;AAAA,UACxB,WACS,OAAQ,iBAAkB,UAAU;AACzC,mBAAO,OAAO,KAAK,YAAY,EAAE;AAAA,UACrC;AACA,iBAAO;AAAA,QACX,GAAG;AACH,YAAI,kBAAkB;AAClB,0BAAAA,QAAI,KAAK,YAAY,cAAc,MAAM,gBAAgB,gBAAgB,qBAAsB,aAAa;AAAA,MACpH;AACA,aAAO,QAAQ,KAAK;AACpB,aAAO;AAAA,IACX;AACA,aAAS,uBAAuB;AAC5B,YAAM,YAAY,CAAC;AACnB,UAAI,WAAW,CAAC;AAChB,sBAAAA,QAAI,MAAM,YAAY;AACtB,aAAO,QAAQ,KAAK;AACpB,aAAO,CAAC,QAAQ,MAAM,GAAG,kBAAkB,GAAG;AAC1C,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,qBAAS,OAAO,KAAK;AACrB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,kBAAkBC,YAAW,IAAI;AAC1C,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,mBAAmBA,YAAW,IAAI;AAC3C,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,SAASA,YAAW,IAAI;AACjC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,gBAAgBA,YAAW,IAAI;AACxC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,cAAcA,YAAW,IAAI;AACtC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,cAAcA,YAAW,IAAI;AACtC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,0BAA0BA,YAAW,IAAI;AAClD,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,aAAaA,YAAW,IAAI;AACrC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,aAAa,KAAK;AAC3B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,qBAAqB,KAAK;AACnC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,oBAAoB,KAAK;AAClC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,aAAa,KAAK;AAC3B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,oBAAoB,KAAK;AAClC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,iBAAiB,KAAK;AAC/B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,mBAAmB,KAAK;AACjC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,YAAYA,YAAW,IAAI;AACpC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,WAAWA,YAAW,IAAI;AACnC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,WAAWA,YAAW,IAAI;AACnC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,YAAYA,YAAW,IAAI;AACpC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,aAAa,KAAK;AAC3B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AAED,qBAAS,sBAAsB,KAAK;AACpC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,oBAAoB,KAAK;AAClC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,cAAc,KAAK;AAC5B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,qBAAS,eAAe,KAAK;AAC7B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AAED,gBAAI,KAAK,UAAU,SAAS;AACxB,8BAAAD,QAAI,MAAM,GAAG;AACb,wBAAU,KAAK,QAAQ;AACvB,8BAAAA,QAAI,MAAM,YAAY;AACtB,yBAAW,CAAC;AACZ,qBAAO,QAAQ,KAAK;AAAA,YACxB;AACA;AAAA,UACJ;AACI,8BAAkB,IAAI;AACtB,mBAAO,QAAQ,KAAK;AACpB;AAAA,QACR;AAAA,MACJ;AAGA,sBAAAA,QAAI,MAAM,GAAG;AACb,gBAAU,KAAK,QAAQ;AACvB,aAAO;AAAA,IACX;AACA,aAAS,iBAAiB;AACtB,YAAM,SAAS,CAAC;AAChB,UAAI,QAAQ,CAAC;AACb,UAAI,SAAS;AACb,UAAI;AACJ,sBAAAA,QAAI,MAAM,SAAS;AACnB,aAAO,QAAQ,KAAK;AACpB,aAAO,CAAC,QAAQ,MAAM,GAAG,QAAQ,GAAG;AAChC,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,kBAAM,OAAO,KAAK;AAClB,wBAAY,KAAK;AACjB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,cAAc,KAAK;AACzB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,qBAAS,KAAK;AACd,gBAAI,SAAS;AACT,oBAAM,UAAU,CAAC;AACrB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,gBAAgB,KAAK;AAC3B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,QAAQ,KAAK,KAAK,KAAK;AAC7B,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,4BAAAA,QAAI,MAAM,GAAG;AACb,gBAAI,SAAS,KAAK,WAAW,MAAM,QAAQ;AACvC,8BAAAA,QAAI,KAAK,uCAAuC;AACpD,mBAAO,SAAS,IAAI;AACpB,oBAAQ,CAAC;AACT,4BAAAA,QAAI,MAAM,SAAS;AACnB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ;AACI,mBAAO,QAAQ,KAAK;AAAA,QAC5B;AAAA,MACJ;AACA,sBAAAA,QAAI,MAAM,GAAG;AACb,aAAO,SAAS,IAAI;AACpB,aAAO;AAAA,IACX;AACA,aAAS,cAAc;AACnB,YAAM,SAAS,CAAC;AAChB,UAAI,QAAQ,CAAC;AACb,UAAI;AACJ,sBAAAA,QAAI,MAAM,SAAS;AACnB,aAAO,QAAQ,KAAK;AACpB,aAAO,CAAC,QAAQ,MAAM,GAAG,QAAQ,GAAG;AAChC,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,kBAAM,OAAO,KAAK;AAClB,wBAAY,KAAK;AACjB,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,UAAU,KAAK,SAAS;AAE9B,kBAAM,aAAa,KAAK,IAAI,KAAK,KAAK;AACtC,kBAAM,QAAQE,cAAa,MAAM,UAAU;AAC3C,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AACD,kBAAM,UAAW,KAAK,QAAQ,MAAM,MAAM,KAAK,QAAQ,MAAM;AAC7D,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ,KAAK;AAED,gBAAI,KAAK,UAAU,SAAS;AACxB,8BAAAF,QAAI,MAAM,GAAG;AACb,qBAAO,SAAS,IAAI;AACpB,8BAAAA,QAAI,MAAM,SAAS;AACnB,sBAAQ,CAAC;AACT,0BAAY;AACZ,qBAAO,QAAQ,KAAK;AAAA,YACxB;AACA;AAAA,UACJ;AACI,8BAAkB,IAAI;AACtB,mBAAO,QAAQ,KAAK;AACpB;AAAA,QACR;AAAA,MACJ;AAGA,sBAAAA,QAAI,MAAM,GAAG;AACb,aAAO,SAAS,IAAI;AACpB,aAAO;AAAA,IACX;AACA,UAAM,mBAAmB;AAAA,MACrB,OAAO;AAAA,QACH,sBAAsB;AAAA,QACtB,WAAW;AAAA,QACX,eAAe;AAAA,QACf,mBAAmB;AAAA,MACvB;AAAA,MACA,OAAO;AAAA,QACH,sBAAsB;AAAA,QACtB,WAAW;AAAA,QACX,eAAe;AAAA,QACf,mBAAmB;AAAA,MACvB;AAAA,MACA,OAAO;AAAA,QACH,sBAAsB;AAAA,QACtB,WAAW;AAAA,QACX,eAAe;AAAA,QACf,mBAAmB;AAAA,MACvB;AAAA,IACJ;AAMA,aAAS,cAAc,UAAU;AAC7B,YAAM,WAAW,CAAC;AAClB,YAAM,gBAAgB,WAAW,WAAW;AAC5C,UAAI,CAAC,UAAU;AACX,eAAO,QAAQ,KAAK;AAAA,MACxB;AACA,aAAO,MAAM;AACT,YAAI,KAAK,SAAS,GAAG;AACjB,cAAI,KAAK,UAAU,eAAe;AAC9B;AAAA,UACJ;AACA,gBAAM,UAAU,KAAK,gBAAgB,KAAK,KAAK;AAC/C,cAAI,WAAW,MAAM;AACjB,4BAAAA,QAAI,MAAM,KAAK,QAAQ,IAAI;AAC3B,kBAAM,SAAS,QAAQ,YAAY,SAAS,IAAI;AAChD,mBAAO,QAAQ;AACf,4BAAAA,QAAI,MAAM,GAAG;AACb,yBAAa,MAAM;AACnB,qBAAS,KAAK,MAAM;AAAA,UACxB,OACK;AACD,4BAAAA,QAAI,KAAK,sBAAsB,KAAK,KAAK;AACzC,mBAAO,QAAQ,KAAK;AACpB;AAAA,UACJ;AAAA,QACJ,OACK;AAED,iBAAO,QAAQ,KAAK;AAAA,QACxB;AAAA,MACJ;AACA,UAAI,iBAAiB;AACjB,eAAO,QAAQ,KAAK;AACxB,aAAO;AAAA,IACX;AAQA,aAASC,YAAWE,OAAM;AACtB,YAAM,QAAQ,CAAC;AACf,UAAI,OAAOA,MAAK;AAChB,YAAM,IAAIA,MAAK;AACf,cAAQ;AACR,MAAAA,QAAO,QAAQ,KAAK;AACpB,UAAIA,MAAK,QAAQ;AACb,cAAM,IAAI,MAAM,yCAAyC,OACrD,cAAcA,MAAK,OAAO,GAAG;AACrC,YAAM,IAAIA,MAAK;AACf,cAAQ;AACR,MAAAA,QAAO,QAAQ,KAAK;AACpB,UAAIA,MAAK,QAAQ,MAAM;AACnB,gBAAQ,OAAO;AACf,eAAO;AAAA,MACX;AACA,YAAM,IAAIA,MAAK;AACf,aAAO;AAAA,IACX;AACA,aAAS,aAAa,QAAQ;AAC1B,UAAI,CAAC;AACD,cAAM,IAAI,UAAU,oCAAoC;AAC5D,UAAI,CAAC,OAAO;AACR,eAAO,SAAS;AAAA,IACxB;AACA,aAAS;AACT,WAAO;AAAA,EACX;AACJ;AACA,SAAS,QAAQ,OAAO,MAAM,OAAO;AACjC,SAAO,MAAM,SAAS,QAAQ,MAAM,UAAU;AAClD;AACA,SAAS,kBAAkB,MAAM;AAC7B,kBAAAH,QAAI,MAAM,qBAAqB,UAAU,IAAI,CAAC;AAClD;AACA,SAAS,UAAU,MAAM;AACrB,SAAO,KAAK,OAAO,MAAM,KAAK;AAClC;AAKA,SAASE,cAAa,OAAO;AACzB,SAAO,0BAAqB,KAAK;AACrC;;;ACpsBA,IAAO,eAAQ;",
  "names": ["log", "parsePoint", "getAcadColor", "curr"]
}
